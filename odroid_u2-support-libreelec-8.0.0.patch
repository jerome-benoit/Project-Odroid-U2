diff --git a/config/graphic b/config/graphic
index 79ad74a..c149380 100644
--- a/config/graphic
+++ b/config/graphic
@@ -12,7 +12,7 @@ fi
 
 get_graphicdrivers() {
   if [ "$GRAPHIC_DRIVERS" = "all" ]; then
-    GRAPHIC_DRIVERS="i915 i965 r200 r300 r600 nvidia vmware virtualbox"
+    GRAPHIC_DRIVERS="armsoc i915 i965 r200 r300 r600 nvidia vmware virtualbox"
   fi
 
   for drv in $GRAPHIC_DRIVERS; do
@@ -77,5 +77,10 @@ get_graphicdrivers() {
 #      LLVM_SUPPORT="yes"
     fi
 
+    if [ "$drv" = "armsoc" ]; then
+      XORG_DRIVERS="$XORG_DRIVERS armsoc"
+      COMPOSITE_SUPPORT="yes"
+    fi
+
   done
 }
diff --git a/packages/devel/libcec/package.mk b/packages/devel/libcec/package.mk
index 969a650..ab32b4d 100644
--- a/packages/devel/libcec/package.mk
+++ b/packages/devel/libcec/package.mk
@@ -61,6 +61,12 @@ else
   PKG_CMAKE_OPTS_TARGET="$PKG_CMAKE_OPTS_TARGET -DHAVE_AOCEC_API=0 -DHAVE_AMLOGIC_API=0"
 fi
 
+if [ "$KODIPLAYER_DRIVER" = "odroid-mfc" ]; then
+  PKG_CMAKE_OPTS_TARGET="$PKG_CMAKE_OPTS_TARGET -DHAVE_EXYNOS_API=1"
+else
+  PKG_CMAKE_OPTS_TARGET="$PKG_CMAKE_OPTS_TARGET -DHAVE_EXYNOS_API=0"
+fi
+
 pre_configure_target() {
   if [ "$KODIPLAYER_DRIVER" = "bcm2835-firmware" ]; then
     export CXXFLAGS="$CXXFLAGS \
@@ -77,3 +83,15 @@ post_makeinstall_target() {
     mv $INSTALL/usr/lib/python2.7/dist-packages $INSTALL/usr/lib/python2.7/site-packages
   fi
 }
+
+post_install() {
+  case $PROJECT in
+    Odroid_U2)
+      cat > $INSTALL/etc/profile.d/20-cec-hdmi-port.conf << EoF
+# Default:
+# CEC_HDMI_PORT=1
+EoF
+      ln -sfn /storage/.config/cec-hdmi-port.conf $INSTALL/etc/profile.d/20-cec-hdmi-port.conf
+    ;;
+  esac
+}
diff --git a/packages/devel/libcec/udev.d/50-cec.rules b/packages/devel/libcec/udev.d/50-cec.rules
new file mode 100644
index 0000000..31251c6
--- /dev/null
+++ b/packages/devel/libcec/udev.d/50-cec.rules
@@ -0,0 +1 @@
+KERNEL=="CEC", MODE="0660"
diff --git a/packages/graphics/libdrm/package.mk b/packages/graphics/libdrm/package.mk
index f1cc2a0..4c21b68 100644
--- a/packages/graphics/libdrm/package.mk
+++ b/packages/graphics/libdrm/package.mk
@@ -35,6 +35,7 @@ get_graphicdrivers
 
 DRM_CONFIG="--disable-libkms --disable-intel --disable-radeon --disable-amdgpu"
 DRM_CONFIG="$DRM_CONFIG --disable-nouveau --disable-vmwgfx"
+DRM_CONFIG="$DRM_CONFIG --disable-exynos-experimental-api"
 
 for drv in $GRAPHIC_DRIVERS; do
   [ "$drv" = "i915" -o "$drv" = "i965" ] && \
@@ -49,6 +50,10 @@ for drv in $GRAPHIC_DRIVERS; do
   [ "$drv" = "vmware" ] && \
     DRM_CONFIG=`echo $DRM_CONFIG | sed -e 's/disable-libkms/enable-libkms/'` && \
     DRM_CONFIG=`echo $DRM_CONFIG | sed -e 's/disable-vmwgfx/enable-vmwgfx/'`
+
+  [ "$drv" = "armsoc" ] && \
+    DRM_CONFIG=`echo $DRM_CONFIG | sed -e 's/disable-libkms/enable-libkms/'` && \
+    DRM_CONFIG=`echo $DRM_CONFIG | sed -e 's/disable-exynos/enable-exynos/'`
 done
 
 PKG_CONFIGURE_OPTS_TARGET="--disable-udev \
diff --git a/packages/graphics/mesa/package.mk b/packages/graphics/mesa/package.mk
index 716b46a..9e1d4fd 100644
--- a/packages/graphics/mesa/package.mk
+++ b/packages/graphics/mesa/package.mk
@@ -109,7 +109,7 @@ pre_configure_target() {
 }
 
 post_makeinstall_target() {
-  # rename and relink for cooperate with nvidia drivers
+  # rename and relink to cooperate with nvidia drivers
     rm -rf $INSTALL/usr/lib/libGL.so
     rm -rf $INSTALL/usr/lib/libGL.so.1
     ln -sf libGL.so.1 $INSTALL/usr/lib/libGL.so
diff --git a/packages/graphics/opengl-mali/package.mk b/packages/graphics/opengl-mali/package.mk
index 07531c3..5e46a43 100644
--- a/packages/graphics/opengl-mali/package.mk
+++ b/packages/graphics/opengl-mali/package.mk
@@ -17,12 +17,14 @@
 ################################################################################
 
 PKG_NAME="opengl-mali"
-PKG_VERSION="20130520"
+PKG_VERSION="4412_r5p0_x11"
+PKG_DEPENDS_TARGET="toolchain"
+PKG_URL="http://people.piment-noir.org/~fraggle/download/odroid/$PKG_NAME-$PKG_VERSION.tar.xz"
+PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET libXfixes libXrender libXcomposite libxcb"
+PKG_SOURCE_DIR="${PKG_NAME}-${PKG_VERSION}"
 PKG_ARCH="arm"
 PKG_LICENSE="nonfree"
-PKG_SITE="http://www.arm.com/products/multimedia/mali-graphics-hardware/mali-400-mp.php"
-PKG_URL="$DISTRO_SRC/$PKG_NAME-$PKG_VERSION.tar.xz"
-PKG_DEPENDS_TARGET="toolchain"
+PKG_SITE="http://www.arm.com/products/multimedia/mali-gpu/ultra-low-power/mali-400.php"
 PKG_SECTION="graphics"
 PKG_SHORTDESC="opengl-mali: OpenGL-ES and Mali driver for Mali 400 GPUs"
 PKG_LONGDESC="opengl-mali: OpenGL-ES and Mali driver for Mali 400 GPUs"
@@ -38,16 +40,40 @@ makeinstall_target() {
   mkdir -p $SYSROOT_PREFIX/usr/include
     cp -PR src/include/* $SYSROOT_PREFIX/usr/include
 
+  # EGL pkgconfig definition is needed since Kodi Krypton
+  mkdir -p $SYSROOT_PREFIX/usr/lib/pkgconfig
+    cat > $SYSROOT_PREFIX/usr/lib/pkgconfig/egl.pc <<\ \ \ \ EoF
+prefix=/usr
+exec_prefix=${prefix}
+libdir=${prefix}/lib/
+includedir=${prefix}/include
+
+Name: EGL
+Description: EGL
+Version: @PKG_VERSION@
+Requires:
+Libs: -L${libdir} -lEGL
+Cflags: -I${includedir}/EGL
+    EoF
+    sed -i "s/@PKG_VERSION@/$PKG_VERSION/" $SYSROOT_PREFIX/usr/lib/pkgconfig/egl.pc
+
+  # cleanup packaged unused links
+  rm -f libEGL.so.1
+  rm -f libEGL.so.1.4
+  rm -f libGLESv1_CM.so
+  rm -f libGLESv1_CM.so.1
+  rm -f libGLESv1_CM.so.1.1
+  rm -f libGLESv2.so.2
+  rm -f libGLESv2.so.2.0
+
   mkdir -p $SYSROOT_PREFIX/usr/lib
-    cp -PR src/lib/*.so* $SYSROOT_PREFIX/usr/lib
-    ln -sf libEGL.so.1.4 $SYSROOT_PREFIX/usr/lib/libEGL.so
-    ln -sf libGLESv1_CM.so.1.1 $SYSROOT_PREFIX/usr/lib/libGLESv1_CM.so
-    ln -sf libGLESv2.so.2.0 $SYSROOT_PREFIX/usr/lib/libGLESv2.so
+    cp -PR *.so* $SYSROOT_PREFIX/usr/lib
+    ln -sf libMali.so $SYSROOT_PREFIX/usr/lib/libEGL.so
+    ln -sf libMali.so $SYSROOT_PREFIX/usr/lib/libGLESv2.so
 
   mkdir -p $INSTALL/usr/lib
-    cp -PR src/lib/*.so* $INSTALL/usr/lib
-    ln -sf libEGL.so.1.4 $INSTALL/usr/lib/libEGL.so
-    ln -sf libGLESv1_CM.so.1.1 $INSTALL/usr/lib/libGLESv1_CM.so
-    ln -sf libGLESv2.so.2.0 $INSTALL/usr/lib/libGLESv2.so
+    cp -PR *.so* $INSTALL/usr/lib
+    ln -sf libMali.so $INSTALL/usr/lib/libEGL.so
+    ln -sf libMali.so $INSTALL/usr/lib/libGLESv2.so
 }
 
diff --git a/packages/graphics/opengl-mali/system.d/xorg.service b/packages/graphics/opengl-mali/system.d/xorg.service
new file mode 100644
index 0000000..3194170
--- /dev/null
+++ b/packages/graphics/opengl-mali/system.d/xorg.service
@@ -0,0 +1,17 @@
+[Unit]
+Description=Xorg Server
+Before=graphical.target kodi.service
+Requires=xorg-configure@mali.service
+After=xorg-configure@mali.service multi-user.target
+ConditionKernelCommandLine=!installer
+
+[Service]
+Type=notify
+EnvironmentFile=-/run/libreelec/debug/xorg.conf
+ExecStart=/usr/bin/xorg-launch -nolisten tcp vt01 $XORG_DEBUG
+Restart=always
+RestartSec=2
+StartLimitInterval=0
+
+[Install]
+WantedBy=graphical.target
diff --git a/packages/linux-firmware/samsung-firmware/package.mk b/packages/linux-firmware/samsung-firmware/package.mk
new file mode 100644
index 0000000..c0324e7
--- /dev/null
+++ b/packages/linux-firmware/samsung-firmware/package.mk
@@ -0,0 +1,45 @@
+################################################################################
+#      This file is part of OpenELEC - http://www.openelec.tv
+#      Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
+#
+#  OpenELEC is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  OpenELEC is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with OpenELEC.  If not, see <http://www.gnu.org/licenses/>.
+################################################################################
+
+PKG_NAME="samsung-firmware"
+PKG_VERSION="20141026.0e5f637"
+PKG_REV="1"
+PKG_ARCH="any"
+PKG_LICENSE=""
+PKG_SITE="http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git"
+PKG_URL="http://people.piment-noir.org/~fraggle/download/odroid/$PKG_NAME-$PKG_VERSION.tar.xz"
+PKG_DEPENDS_TARGET="toolchain"
+PKG_PRIORITY="optional"
+PKG_SECTION="firmware"
+PKG_SHORTDESC="samsung-firmware: firmwares for various samsung devices"
+PKG_LONGDESC="samsung-firmware: firmwares for various samsung devices"
+
+PKG_IS_ADDON="no"
+PKG_AUTORECONF="no"
+
+make_target() {
+  : # nothing todo
+}
+
+makeinstall_target() {
+  mkdir -p $INSTALL/usr/lib/firmware/s5p-mfc
+    cp -R * $INSTALL/usr/lib/firmware
+    for fw in s5p-* ; do
+      ln -sf ../${fw} $INSTALL/usr/lib/firmware/s5p-mfc/${fw}
+    done
+}
diff --git a/packages/linux/package.mk b/packages/linux/package.mk
index c939158..0fd4482 100644
--- a/packages/linux/package.mk
+++ b/packages/linux/package.mk
@@ -58,6 +58,11 @@ case "$LINUX" in
     PKG_SOURCE_DIR="xbian-sources-kernel-${PKG_COMMIT}*"   
     PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET imx6-status-led imx6-soc-fan irqbalanced"
     ;;
+  mfc-3.8)
+    PKG_COMMIT="ddfddf8"
+    PKG_VERSION="${PKG_COMMIT}"
+    PKG_URL="https://github.com/hardkernel/linux/archive/$PKG_VERSION.tar.gz"
+    ;;
   *)
     PKG_VERSION="4.9.8"
     PKG_URL="http://www.kernel.org/pub/linux/kernel/v4.x/$PKG_NAME-$PKG_VERSION.tar.xz"
@@ -243,6 +248,11 @@ makeinstall_init() {
 }
 
 post_install() {
+  case $PROJECT in
+    Odroid_U2)
+      ln -sfn /storage/.config/smsc95xx_mac_addr $INSTALL/etc/smsc95xx_mac_addr
+    ;;
+  esac
   mkdir -p $INSTALL/usr/lib/firmware/
     ln -sf /storage/.config/firmware/ $INSTALL/usr/lib/firmware/updates
 
diff --git a/packages/mediacenter/kodi/package.mk b/packages/mediacenter/kodi/package.mk
index 5090d0c..30abcef 100644
--- a/packages/mediacenter/kodi/package.mk
+++ b/packages/mediacenter/kodi/package.mk
@@ -198,6 +198,9 @@ if [ ! "$KODIPLAYER_DRIVER" = default ]; then
     CXXFLAGS="$CXXFLAGS -DHAS_IMXVPU -DLINUX -DEGL_API_FB"
   elif [ "$KODIPLAYER_DRIVER" = libamcodec ]; then
     KODI_PLAYER="-DENABLE_AML=ON"
+  elif [ "$KODIPLAYER_DRIVER" = odroid-mfc ]; then
+    PKG_DEPENDS_TARGET="${PKG_DEPENDS_TARGET/ $KODIPLAYER_DRIVER/}"
+    KODI_PLAYER="-DENABLE_MFC=ON"
   fi
 fi
 
diff --git a/packages/tools/dtc/package.mk b/packages/tools/dtc/package.mk
index 49b53a7..c50ff2c 100644
--- a/packages/tools/dtc/package.mk
+++ b/packages/tools/dtc/package.mk
@@ -35,3 +35,7 @@ makeinstall_target() {
   mkdir -p $INSTALL/usr/bin
     cp -P $ROOT/$PKG_BUILD/dtc $INSTALL/usr/bin
 }
+
+makeinstall_host() {
+  make install PREFIX=$ROOT/$TOOLCHAIN
+}
diff --git a/packages/tools/u-boot/package.mk b/packages/tools/u-boot/package.mk
index 6f69747..1ddde00 100644
--- a/packages/tools/u-boot/package.mk
+++ b/packages/tools/u-boot/package.mk
@@ -18,22 +18,34 @@
 
 PKG_NAME="u-boot"
 PKG_DEPENDS_TARGET="toolchain"
-if [ "$UBOOT_VERSION" = "imx6-cuboxi" ]; then
-  PKG_COMMIT="c8d1200"
-  PKG_VERSION="imx6-$PKG_COMMIT"
-  PKG_SITE="http://solid-run.com/wiki/doku.php?id=products:imx6:software:development:u-boot"
-  PKG_URL="https://github.com/SolidRun/u-boot-imx6/archive/$PKG_COMMIT.tar.gz"
-  PKG_SOURCE_NAME="$PKG_NAME-sr-$PKG_VERSION.tar.gz"
-  PKG_SOURCE_DIR="$PKG_NAME-imx6-${PKG_COMMIT}*"
+case "$UBOOT_VERSION" in
+  "imx6-cuboxi")
+    PKG_COMMIT="c8d1200"
+    PKG_VERSION="imx6-$PKG_COMMIT"
+    PKG_SITE="http://solid-run.com/wiki/doku.php?id=products:imx6:software:development:u-boot"
+    PKG_URL="https://github.com/SolidRun/u-boot-imx6/archive/$PKG_COMMIT.tar.gz"
+    PKG_SOURCE_NAME="$PKG_NAME-sr-$PKG_VERSION.tar.gz"
+    PKG_SOURCE_DIR="$PKG_NAME-imx6-${PKG_COMMIT}*"
   [ -n "$UBOOT_CONFIG_V2" ] && PKG_DEPENDS_TARGET="toolchain u-boot-v2"
-elif [ "$UBOOT_VERSION" = "hardkernel" ]; then
-  PKG_VERSION="6e4e886"
-  PKG_SITE="https://github.com/hardkernel/u-boot"
-  PKG_URL="https://github.com/hardkernel/u-boot/archive/$PKG_VERSION.tar.gz"
-  PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET gcc-linaro-aarch64-elf:host gcc-linaro-arm-eabi:host"
-else
-  exit 0
-fi
+    ;;
+  "hardkernel")
+    PKG_VERSION="6e4e886"
+    PKG_SITE="https://github.com/hardkernel/u-boot"
+    PKG_URL="https://github.com/hardkernel/u-boot/archive/$PKG_VERSION.tar.gz"
+    PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET gcc-linaro-aarch64-elf:host gcc-linaro-arm-eabi:host"
+    ;;
+  "mainline"|*)
+    PKG_VERSION="2016.11"
+    PKG_SITE="http://www.denx.de/wiki/U-Boot/WebHome"
+    PKG_URL="ftp://ftp.denx.de/pub/u-boot/u-boot-$PKG_VERSION.tar.bz2"
+    PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET dtc:host"
+    ;;
+esac
+case "$PROJECT" in
+  "Odroid_U2")
+    PKG_DEPENDS_TARGET="$PKG_DEPENDS_TARGET odroid-u2-bootloader"
+    ;;
+esac
 PKG_ARCH="arm aarch64"
 PKG_LICENSE="GPL"
 PKG_SECTION="tools"
@@ -59,7 +71,9 @@ pre_configure_target() {
   MAKEFLAGS=-j1
 
 # copy compiler-gcc5.h to compiler-gcc6. for fake building
-  cp include/linux/compiler-gcc5.h include/linux/compiler-gcc6.h
+  if [ "$UBOOT_VERSION" != "mainline" ]; then
+    cp include/linux/compiler-gcc5.h include/linux/compiler-gcc6.h
+  fi
 }
 
 make_target() {
@@ -130,15 +144,34 @@ makeinstall_target() {
 
   cp -PR $PROJECT_DIR/$PROJECT/bootloader/uEnv*.txt $INSTALL/usr/share/bootloader 2>/dev/null || :
 
+  mk_u-boot_splash()
+  {
+  if [ -f $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz ]; then
+    cp -PRv $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz $INSTALL/usr/share/bootloader
+  elif [ -f $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz ]; then
+    cp -PRv $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz $INSTALL/usr/share/bootloader
+  fi
+  }
+
   case $PROJECT in
     Odroid_C2)
       cp -PRv $PKG_DIR/scripts/update-c2.sh $INSTALL/usr/share/bootloader/update.sh
       cp -PRv $ROOT/$PKG_BUILD/u-boot.bin $INSTALL/usr/share/bootloader/u-boot
-      if [ -f $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz ]; then
-        cp -PRv $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz $INSTALL/usr/share/bootloader
-      elif [ -f $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz ]; then
-        cp -PRv $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz $INSTALL/usr/share/bootloader
+      mk_u-boot_splash
+      ;;
+    Odroid_U2)
+      # FIXME: this code path is more specific to mainline u-boot version than a project
+      if [ -f "$ROOT/$PKG_BUILD/u-boot-dtb.bin" ]; then
+        cp -PRv $ROOT/$PKG_BUILD/u-boot-dtb.bin $INSTALL/usr/share/bootloader/u-boot
+      elif [ -f "$ROOT/$PKG_BUILD/u-boot.bin" ]; then
+        cp -PRv $ROOT/$PKG_BUILD/u-boot.bin $INSTALL/usr/share/bootloader/u-boot
+      elif [ -f "$ROOT/$PKG_BUILD/sd_fuse/u-boot.bin" ]; then
+        cp -PRv $ROOT/$PKG_BUILD/sd_fuse/u-boot.bin $INSTALL/usr/share/bootloader/u-boot
+      elif [ -f "$ROOT/$PKG_BUILD/build/u-boot.bin" ]; then
+        cp -PRv $ROOT/$PKG_BUILD/build/u-boot.bin $INSTALL/usr/share/bootloader/u-boot
       fi
+      cp -PRv $PKG_DIR/scripts/update-u2.sh $INSTALL/usr/share/bootloader/update.sh
+      mk_u-boot_splash
       ;;
     imx6)
       cp -PRv $PKG_DIR/scripts/update.sh $INSTALL/usr/share/bootloader
diff --git a/packages/tools/u-boot/release b/packages/tools/u-boot/release
index 6787a2f..b2c4782 100755
--- a/packages/tools/u-boot/release
+++ b/packages/tools/u-boot/release
@@ -37,14 +37,28 @@ mkdir -p $RELEASE_DIR/3rdparty/bootloader
 
   cp -PR $BUILD/linux-*/arch/$TARGET_KERNEL_ARCH/boot/dts/*.dtb $RELEASE_DIR/3rdparty/bootloader 2>/dev/null || :
 
+  mk_u-boot_splash()
+  {
+  if [ -f $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz ]; then
+    cp -PR $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz $RELEASE_DIR/3rdparty/bootloader
+  elif [ -f $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz ]; then
+    cp -PR $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz $RELEASE_DIR/3rdparty/bootloader
+  fi
+  }
+
   case $PROJECT in
     Odroid_C2)
       cp -PR $BUILD/$BOOTLOADER-*/u-boot.bin $RELEASE_DIR/3rdparty/bootloader/u-boot
       cp -PR $PROJECT_DIR/$PROJECT/bootloader/boot.ini $RELEASE_DIR/3rdparty/bootloader
-      if [ -f $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz ]; then
-        cp -PR $PROJECT_DIR/$PROJECT/splash/boot-logo.bmp.gz $RELEASE_DIR/3rdparty/bootloader
-      elif [ -f $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz ]; then
-        cp -PR $DISTRO_DIR/$DISTRO/splash/boot-logo.bmp.gz $RELEASE_DIR/3rdparty/bootloader
-      fi
+      mk_u-boot_splash
+      ;;
+    Odroid_U2)
+      cp -PR $BUILD/$BOOTLOADER-*/u-boot.bin $RELEASE_DIR/3rdparty/bootloader/u-boot
+      for blob in $INSTALL/usr/share/bootloader/* ; do
+        cp -PR $blob $RELEASE_DIR/3rdparty/bootloader 2>/dev/null || :
+      done
+      cp -PR $PROJECT_DIR/$PROJECT/bootloader/boot.ini $RELEASE_DIR/3rdparty/bootloader
+      cp -PR $PROJECT_DIR/$PROJECT/bootloader/u-boot-fuse $RELEASE_DIR/3rdparty/bootloader
+      mk_u-boot_splash
       ;;
   esac
diff --git a/packages/tools/u-boot/scripts/update-u2.sh b/packages/tools/u-boot/scripts/update-u2.sh
new file mode 100644
index 0000000..42e6760
--- /dev/null
+++ b/packages/tools/u-boot/scripts/update-u2.sh
@@ -0,0 +1,73 @@
+#!/bin/sh
+
+################################################################################
+#      This file is part of OpenELEC - http://www.openelec.tv
+#      Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
+#
+#  OpenELEC is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  OpenELEC is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with OpenELEC.  If not, see <http://www.gnu.org/licenses/>.
+################################################################################
+
+[ -z "$SYSTEM_ROOT" ] && SYSTEM_ROOT=""
+[ -z "$BOOT_ROOT" ] && BOOT_ROOT="/flash"
+[ -z "$BOOT_PART" ] && BOOT_PART=$(df "$BOOT_ROOT" | tail -1 | awk {' print $1 '})
+if [ -z "$BOOT_DISK" ]; then
+  case $BOOT_PART in
+    /dev/sd[a-z][0-9]*)
+      BOOT_DISK=$(echo $BOOT_PART | sed -e "s,[0-9]*,,g")
+      ;;
+    /dev/mmcblk*)
+      BOOT_DISK=$(echo $BOOT_PART | sed -e "s,p[0-9]*,,g")
+      ;;
+  esac
+fi
+
+# mount $BOOT_ROOT r/w
+  mount -o remount,rw $BOOT_ROOT
+
+# update Device Tree Blobs
+  for all_dtb in /flash/*.dtb /flash/DTB; do
+    dtb=$(basename $all_dtb)
+    if [ -f $SYSTEM_ROOT/usr/share/bootloader/$dtb ]; then
+      echo "*** updating Device Tree Blob: $dtb ..."
+      cp -p $SYSTEM_ROOT/usr/share/bootloader/$dtb $BOOT_ROOT
+    fi
+  done
+
+# stop if on eMMC that won't accept the new bootloader
+if [ -f /sys/block/${BOOT_DISK}boot0/force_ro ]; then
+  emmc=1
+  D="eMMC"
+  device=/dev/${BOOT_DISK}boot0
+  if ! echo 0 > /sys/block/${BOOT_DISK}boot0/force_ro; then
+    msgbox "I've found a running eMMC but I couldn't get it to accept the new bootloaders."
+    exit
+  fi
+fi
+
+echo "*** updating u-boot for Odroid on: $BOOT_DISK ..."
+if [ -n "${emmc}" ]; then
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/bl1 of=$BOOT_DISK seek=0
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/bl2 of=$BOOT_DISK seek=30
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/u-boot of=$BOOT_DISK seek=62
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/tzsw of=$BOOT_DISK seek=2110
+else
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/bl1 of=$BOOT_DISK seek=1
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/bl2 of=$BOOT_DISK seek=31
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/u-boot of=$BOOT_DISK seek=63
+  dd bs=512 if=$SYSTEM_ROOT/usr/share/bootloader/tzsw of=$BOOT_DISK seek=2111
+fi
+
+# mount $BOOT_ROOT r/o
+  sync
+  mount -o remount,ro $BOOT_ROOT
diff --git a/packages/tools/u-boot/scripts/update.sh b/packages/tools/u-boot/scripts/update.sh
old mode 100755
new mode 100644
diff --git a/packages/x11/driver/xf86-video-armsoc/config/xorg-armsoc.conf b/packages/x11/driver/xf86-video-armsoc/config/xorg-armsoc.conf
new file mode 100644
index 0000000..e1fb459
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/config/xorg-armsoc.conf
@@ -0,0 +1,32 @@
+Section "Device"
+    Identifier     "ARMSoC Device"
+    Driver         "armsoc"
+
+    Option         "fbdev"        "/dev/fb0"
+    Option         "Debug"        "false"
+    Option         "DPMS"         "false
+EndSection
+
+Section "Screen"
+    Identifier     "ARMSoC Screen"
+    Device         "ARMSoC Device"
+    DefaultDepth   24
+    Option         "ColorRange"   "Full"
+EndSection
+
+Section "ServerLayout"
+    Identifier     "ARMSoC Layout"
+    Option         "Blanktime"    "0"
+    Option         "StandbyTime"  "0"
+    Option         "SuspendTime"  "0"
+    Option         "OffTime"      "0"
+EndSection
+
+Section "Extensions"
+    Option         "Composite"    "false"
+EndSection
+
+Section "DRI"
+    Mode           0666
+EndSection
+
diff --git a/packages/x11/driver/xf86-video-armsoc/package.mk b/packages/x11/driver/xf86-video-armsoc/package.mk
new file mode 100644
index 0000000..efcccbf
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/package.mk
@@ -0,0 +1,41 @@
+################################################################################
+#      This file is part of OpenELEC - http://www.openelec.tv
+#      Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
+#
+#  OpenELEC is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  OpenELEC is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with OpenELEC.  If not, see <http://www.gnu.org/licenses/>.
+################################################################################
+
+PKG_NAME="xf86-video-armsoc"
+PKG_VERSION="3.1.0-rc1"
+PKG_REV="1"
+PKG_ARCH="arm"
+PKG_LICENSE="OSS"
+PKG_SITE="https://github.com/endlessm/xf86-video-armsoc"
+PKG_URL="https://github.com/endlessm/xf86-video-armsoc/archive/Release_${PKG_VERSION}.tar.gz"
+PKG_DEPENDS_TARGET="toolchain util-macros xorg-server"
+PKG_NEED_UNPACK="$LINUX_DEPENDS"
+PKG_SECTION="x11/driver"
+PKG_SHORTDESC="xf86-video-armsoc: The Xorg driver for some ARM video chips"
+PKG_LONGDESC="The Xorg driver for some ARM video chips"
+PKG_SOURCE_DIR="${PKG_NAME}-Release_${PKG_VERSION}"
+
+PKG_IS_ADDON="no"
+PKG_AUTORECONF="yes"
+
+PKG_CONFIGURE_OPTS_TARGET="--with-xorg-module-dir=$XORG_PATH_MODULES --with-drmmode=exynos"
+
+post_makeinstall_target() {
+  mkdir -p $INSTALL/etc/X11/xorg.conf.d
+    cp $PKG_DIR/config/*.conf $INSTALL/etc/X11/xorg.conf.d/20-armsoc.conf
+}
diff --git a/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0000-update-compat-api.h-xorg-1.19.X.patch b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0000-update-compat-api.h-xorg-1.19.X.patch
new file mode 100644
index 0000000..49c601b
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0000-update-compat-api.h-xorg-1.19.X.patch
@@ -0,0 +1,52 @@
+---
+ src/compat-api.h |   17 +++++++++++++++++
+ 1 file changed, 17 insertions(+)
+
+--- a/src/compat-api.h
++++ b/src/compat-api.h
+@@ -28,6 +28,8 @@
+ #ifndef COMPAT_API_H
+ #define COMPAT_API_H
+ 
++#include <xf86Module.h>
++
+ #ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
+ #define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
+ #define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
+@@ -38,6 +40,10 @@
+ #define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
+ #endif
+ 
++#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 22
++#define HAVE_NOTIFY_FD 1
++#endif
++
+ #ifndef XF86_SCRN_INTERFACE
+ 
+ #define SCRN_ARG_TYPE int
+@@ -77,9 +83,15 @@
+ 
+ #define SCREEN_INIT_ARGS_DECL ScreenPtr pScreen, int argc, char **argv
+ 
++#if ABI_VIDEODRV_VERSION >= SET_ABI_VERSION(23, 0)
++#define RELOAD_CURSORS_DEPRECATED 1
++#define BLOCKHANDLER_ARGS_DECL ScreenPtr arg, pointer pTimeout
++#define BLOCKHANDLER_ARGS arg, pTimeout
++#else
+ #define BLOCKHANDLER_ARGS_DECL \
+ 	ScreenPtr arg, pointer pTimeout, pointer pReadmask
+ #define BLOCKHANDLER_ARGS arg, pTimeout, pReadmask
++#endif
+ 
+ #define CLOSE_SCREEN_ARGS_DECL ScreenPtr pScreen
+ #define CLOSE_SCREEN_ARGS pScreen
+@@ -100,4 +112,9 @@
+ 
+ #endif
+ 
++#if !HAVE_NOTIFY_FD
++#define SetNotifyFd(fd, cb, mode, data) AddGeneralSocket(fd);
++#define RemoveNotifyFd(fd) RemoveGeneralSocket(fd)
++#endif
++
+ #endif
diff --git a/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0001-compilation-fixes.patch b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0001-compilation-fixes.patch
new file mode 100644
index 0000000..64be4be
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0001-compilation-fixes.patch
@@ -0,0 +1,69 @@
+---
+ src/drmmode_display.c |   24 +++++++++++++++++++++++-
+ 1 file changed, 23 insertions(+), 1 deletion(-)
+
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -450,9 +450,11 @@ done_setting:
+ 		drmmode_output_dpms(output, DPMSModeOn);
+ 	}
+ 
++	#ifndef RELOAD_CURSORS_DEPRECATED
+ 	/* if hw cursor is initialized, reload it */
+ 	if (drmmode->cursor)
+ 		xf86_reload_cursors(pScrn->pScreen);
++	#endif
+ 
+ cleanup:
+ 	if (newcrtc)
+@@ -2038,6 +2040,16 @@ drmmode_uevent_fini(ScrnInfoPtr pScrn)
+ 	TRACE_EXIT();
+ }
+ 
++#if HAVE_NOTIFY_FD
++static void
++drmmode_notify_fd(int fd, int notify, void *data)
++{
++	ScrnInfoPtr pScrn = data;
++	struct drmmode_rec *drmmode;
++	drmmode = drmmode_from_scrn(pScrn);
++	drmHandleEvent(drmmode->fd, &event_context);
++}
++#else
+ static void
+ drmmode_wakeup_handler(pointer data, int err, pointer p)
+ {
+@@ -2053,6 +2065,7 @@ drmmode_wakeup_handler(pointer data, int
+ 	if (FD_ISSET(drmmode->fd, read_mask))
+ 		drmHandleEvent(drmmode->fd, &event_context);
+ }
++#endif
+ 
+ void
+ drmmode_wait_for_event(ScrnInfoPtr pScrn)
+@@ -2068,15 +2081,24 @@ drmmode_screen_init(ScrnInfoPtr pScrn)
+ 
+ 	drmmode_uevent_init(pScrn);
+ 
+-	AddGeneralSocket(drmmode->fd);
++	SetNotifyFd(drmmode->fd, drmmode_notify_fd, X_NOTIFY_READ, pScrn);
+ 
++	#ifndef HAVE_NOTIFY_FD
+ 	/* Register a wakeup handler to get informed on DRM events */
+ 	RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
+ 			drmmode_wakeup_handler, pScrn);
++	#endif
+ }
+ 
+ void
+ drmmode_screen_fini(ScrnInfoPtr pScrn)
+ {
++	struct drmmode_rec *drmmode = drmmode_from_scrn(pScrn);
++	#ifndef HAVE_NOTIFY_FD
++	/* Unregister wakeup handler */
++	RemoveBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
++	                             drmmode_wakeup_handler, pScrn);
++	#endif
++	RemoveNotifyFd(drmmode->fd);
+ 	drmmode_uevent_fini(pScrn);
+ }
diff --git a/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0002-fix-a-segfault-when-switching-VT.patch b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0002-fix-a-segfault-when-switching-VT.patch
new file mode 100644
index 0000000..ecbaa2e
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0002-fix-a-segfault-when-switching-VT.patch
@@ -0,0 +1,24 @@
+---
+ src/armsoc_driver.c |    4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/src/armsoc_driver.c
++++ b/src/armsoc_driver.c
+@@ -1334,7 +1334,7 @@ ARMSOCEnterVT(VT_FUNC_ARGS_DECL)
+ 	TRACE_ENTER();
+ 
+ 	for (i = 1; i < currentMaxClients; i++) {
+-		if (clients[i])
++		if (clients[i] && !clients[i]->clientGone)
+ 			AttendClient(clients[i]);
+ 	}
+ 
+@@ -1369,7 +1369,7 @@ ARMSOCLeaveVT(VT_FUNC_ARGS_DECL)
+ 	TRACE_ENTER();
+ 
+ 	for (i = 1; i < currentMaxClients; i++) {
+-		if (clients[i])
++		if (clients[i] && !clients[i]->clientGone)
+ 			IgnoreClient(clients[i]);
+ 	}
+ 
diff --git a/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0003-fix-all-calloc-syntax-mistakes.patch b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0003-fix-all-calloc-syntax-mistakes.patch
new file mode 100644
index 0000000..1cb6ab3
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/patches/xf86-video-armsoc-0003-fix-all-calloc-syntax-mistakes.patch
@@ -0,0 +1,67 @@
+---
+ src/armsoc_exa.c      |    3 +--
+ src/armsoc_exa_null.c |    2 +-
+ src/drmmode_display.c |    8 ++++----
+ 3 files changed, 6 insertions(+), 7 deletions(-)
+
+--- a/src/armsoc_exa.c
++++ b/src/armsoc_exa.c
+@@ -164,8 +164,7 @@ ARMSOCCreatePixmap2(ScreenPtr pScreen, i
+ 		int depth, int usage_hint, int bitsPerPixel,
+ 		int *new_fb_pitch)
+ {
+-	struct ARMSOCPixmapPrivRec *priv =
+-				calloc(sizeof(struct ARMSOCPixmapPrivRec), 1);
++	struct ARMSOCPixmapPrivRec *priv = calloc(1, sizeof(struct ARMSOCPixmapPrivRec));
+ 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+ 	struct ARMSOCRec *pARMSOC = ARMSOCPTR(pScrn);
+ 
+--- a/src/armsoc_exa_null.c
++++ b/src/armsoc_exa_null.c
+@@ -109,7 +109,7 @@ Bool InstallAlphaHack(ScreenPtr pScreen)
+ struct ARMSOCEXARec *
+ InitNullEXA(ScreenPtr pScreen, ScrnInfoPtr pScrn, int fd)
+ {
+-	struct ARMSOCNullEXARec *null_exa = calloc(sizeof(*null_exa), 1);
++	struct ARMSOCNullEXARec *null_exa = calloc(1, sizeof(*null_exa));
+ 	struct ARMSOCEXARec *armsoc_exa;
+ 	ExaDriverPtr exa;
+ 
+--- a/src/drmmode_display.c
++++ b/src/drmmode_display.c
+@@ -341,7 +341,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc,
+ 	crtc->y = y;
+ 	crtc->rotation = rotation;
+ 
+-	output_ids = calloc(sizeof(uint32_t), xf86_config->num_output);
++	output_ids = calloc(xf86_config->num_output, sizeof(uint32_t));
+ 	if (!output_ids) {
+ 		ERROR_MSG(
+ 				"memory allocation failed in drmmode_set_mode_major()");
+@@ -991,7 +991,7 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, str
+ 	if (crtc == NULL)
+ 		return;
+ 
+-	drmmode_crtc = xnfcalloc(sizeof(struct drmmode_crtc_private_rec), 1);
++	drmmode_crtc = xnfcalloc(1, sizeof(struct drmmode_crtc_private_rec));
+ 	drmmode_crtc->crtc_id = drmmode->mode_res->crtcs[num];
+ 	drmmode_crtc->drmmode = drmmode;
+ 	drmmode_crtc->last_good_mode = NULL;
+@@ -1510,7 +1510,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, s
+ 	if (!connector)
+ 		goto exit;
+ 
+-	encoders = calloc(sizeof(drmModeEncoderPtr), connector->count_encoders);
++	encoders = calloc(connector->count_encoders, sizeof(drmModeEncoderPtr));
+ 	if (!encoders)
+ 		goto free_connector_exit;
+ 
+@@ -1529,7 +1529,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, s
+ 	if (!output)
+ 		goto free_encoders_exit;
+ 
+-	drmmode_output = calloc(sizeof(struct drmmode_output_priv), 1);
++	drmmode_output = calloc(1, sizeof(struct drmmode_output_priv));
+ 	if (!drmmode_output) {
+ 		xf86OutputDestroy(output);
+ 		goto free_encoders_exit;
diff --git a/packages/x11/driver/xf86-video-armsoc/udev.d/50-mali.rules b/packages/x11/driver/xf86-video-armsoc/udev.d/50-mali.rules
new file mode 100644
index 0000000..d973c8c
--- /dev/null
+++ b/packages/x11/driver/xf86-video-armsoc/udev.d/50-mali.rules
@@ -0,0 +1,3 @@
+KERNEL=="mali", MODE="0777", GROUP="video"
+KERNEL=="ump", MODE="0777", GROUP="video"
+KERNEL=="umplock", MODE="0777", GROUP="video"
diff --git a/packages/x11/lib/libXfixes/package.mk b/packages/x11/lib/libXfixes/package.mk
index cadfda3..e88f3ff 100644
--- a/packages/x11/lib/libXfixes/package.mk
+++ b/packages/x11/lib/libXfixes/package.mk
@@ -30,7 +30,11 @@ PKG_LONGDESC="X Fixes Library"
 PKG_IS_ADDON="no"
 PKG_AUTORECONF="no"
 
-PKG_CONFIGURE_OPTS_TARGET="--enable-static --disable-shared"
+if [ "$OPENGLES" = "opengl-mali" ]; then
+  PKG_CONFIGURE_OPTS_TARGET="--enable-static --enable-shared"
+else
+  PKG_CONFIGURE_OPTS_TARGET="--enable-static --disable-shared"
+fi
 
 pre_configure_target() {
   export CFLAGS="$CFLAGS -fPIC"
diff --git a/projects/Odroid_U2/bootloader/boot.ini b/projects/Odroid_U2/bootloader/boot.ini
new file mode 100644
index 0000000..5444e7b
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/boot.ini
@@ -0,0 +1,62 @@
+#------------------------------------------------------------------------------------------------------
+#
+# boot.ini identification
+#
+#------------------------------------------------------------------------------------------------------
+ODROID4412-UBOOT-CONFIG
+
+#------------------------------------------------------------------------------------------------------
+#
+# Boot Specific Stuff
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootrootfs "boot=/dev/mmcblk0p1 disk=/dev/mmcblk0p2 ro"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Console Setup
+#
+#------------------------------------------------------------------------------------------------------
+setenv console "console=tty1 console=ttySAC1,115200n8"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Video output
+#
+# Setup the video output
+#   Unset variable = automatic
+#
+#   setenv video_output "video=HDMI-A-1:1920x1080M@60" : 1080p (Use connected display's EDID)
+#   setenv video_output "video=HDMI-A-1:1280x720@60"   :  720p (Use connected display's EDID)
+# 
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1920x1080.bin" : 1080p (Use system EDID)
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1280x720.bin"  :  720p (Use system EDID)
+#------------------------------------------------------------------------------------------------------
+# setenv video_output "video=HDMI-A-1:1920x1080M@60"
+
+#------------------------------------------------------------------------------------------------------
+#
+# LibreELEC variables
+#
+# Setup the LibreELEC options
+#   valid values are: progress ssh debugging quiet break verbose
+#------------------------------------------------------------------------------------------------------
+setenv libreelec "quiet ssh"
+
+#------------------------------------------------------------------------------------------------------
+#
+# U-Boot bootcmd command
+#  
+#------------------------------------------------------------------------------------------------------
+setenv kernel "fatload mmc 0:1 40008000 KERNEL" 
+setenv bootcmd "${kernel}; bootz 40008000 -"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Kernel boot
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootargs "${console} ${bootrootfs} ${libreelec}"
+
+# Boot the board
+boot
diff --git a/projects/Odroid_U2/bootloader/boot.ini.emmc b/projects/Odroid_U2/bootloader/boot.ini.emmc
new file mode 100644
index 0000000..6acc2f3
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/boot.ini.emmc
@@ -0,0 +1,62 @@
+#------------------------------------------------------------------------------------------------------
+#
+# boot.ini identification
+#
+#------------------------------------------------------------------------------------------------------
+ODROID4412-UBOOT-CONFIG
+
+#------------------------------------------------------------------------------------------------------
+#
+# Boot Specific Stuff
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootrootfs "boot=/dev/mmcblk0p1 disk=/dev/mmcblk0p2 ro"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Console Setup
+#
+#------------------------------------------------------------------------------------------------------
+setenv console "console=tty1 console=ttySAC1,115200n8"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Video output
+#
+# Setup the video output
+#   Unset variable = automatic
+#
+#   setenv video_output "video=HDMI-A-1:1920x1080M@60" : 1080p (Use connected display's EDID)
+#   setenv video_output "video=HDMI-A-1:1280x720@60"   :  720p (Use connected display's EDID)
+# 
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1920x1080.bin" : 1080p (Use system EDID)
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1280x720.bin"  :  720p (Use system EDID)
+#------------------------------------------------------------------------------------------------------
+# setenv video_output "video=HDMI-A-1:1920x1080M@60"
+
+#------------------------------------------------------------------------------------------------------
+#
+# LibreELEC variables
+#
+# Setup the LibreELEC options
+#   valid values are: progress ssh debugging quiet break verbose
+#------------------------------------------------------------------------------------------------------
+setenv libreelec "quiet ssh"
+
+#------------------------------------------------------------------------------------------------------
+#
+# U-Boot bootcmd command
+#  
+#------------------------------------------------------------------------------------------------------
+setenv kernel "fatload mmc 0:1 40008000 KERNEL" 
+setenv bootcmd "${kernel}; bootm 40008000 -"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Kernel boot
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootargs "${console} ${bootrootfs} ${libreelec}"
+
+# Boot the board
+boot
diff --git a/projects/Odroid_U2/bootloader/boot.ini.sd b/projects/Odroid_U2/bootloader/boot.ini.sd
new file mode 100644
index 0000000..5444e7b
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/boot.ini.sd
@@ -0,0 +1,62 @@
+#------------------------------------------------------------------------------------------------------
+#
+# boot.ini identification
+#
+#------------------------------------------------------------------------------------------------------
+ODROID4412-UBOOT-CONFIG
+
+#------------------------------------------------------------------------------------------------------
+#
+# Boot Specific Stuff
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootrootfs "boot=/dev/mmcblk0p1 disk=/dev/mmcblk0p2 ro"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Console Setup
+#
+#------------------------------------------------------------------------------------------------------
+setenv console "console=tty1 console=ttySAC1,115200n8"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Video output
+#
+# Setup the video output
+#   Unset variable = automatic
+#
+#   setenv video_output "video=HDMI-A-1:1920x1080M@60" : 1080p (Use connected display's EDID)
+#   setenv video_output "video=HDMI-A-1:1280x720@60"   :  720p (Use connected display's EDID)
+# 
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1920x1080.bin" : 1080p (Use system EDID)
+#   setenv video_output "drm_kms_helper.edid_firmware=edid/1280x720.bin"  :  720p (Use system EDID)
+#------------------------------------------------------------------------------------------------------
+# setenv video_output "video=HDMI-A-1:1920x1080M@60"
+
+#------------------------------------------------------------------------------------------------------
+#
+# LibreELEC variables
+#
+# Setup the LibreELEC options
+#   valid values are: progress ssh debugging quiet break verbose
+#------------------------------------------------------------------------------------------------------
+setenv libreelec "quiet ssh"
+
+#------------------------------------------------------------------------------------------------------
+#
+# U-Boot bootcmd command
+#  
+#------------------------------------------------------------------------------------------------------
+setenv kernel "fatload mmc 0:1 40008000 KERNEL" 
+setenv bootcmd "${kernel}; bootz 40008000 -"
+
+#------------------------------------------------------------------------------------------------------
+#
+# Kernel boot
+#
+#------------------------------------------------------------------------------------------------------
+setenv bootargs "${console} ${bootrootfs} ${libreelec}"
+
+# Boot the board
+boot
diff --git a/projects/Odroid_U2/bootloader/u-boot-fuse b/projects/Odroid_U2/bootloader/u-boot-fuse
new file mode 100644
index 0000000..c899ba3
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/u-boot-fuse
@@ -0,0 +1,7 @@
+# Drop in Project Specific U-Boot Custom Fusing script | ODROID_U2
+# This script is run inside the scripts/mkimage script when the device we are fusing is different than the defaults
+echo "image: fusing for ${PROJECT}..."
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl1" of="$DISK" conv=fsync,notrunc bs=512 seek=1 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl2" of="$DISK" conv=fsync,notrunc bs=512 seek=31 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/u-boot" of="$DISK" conv=fsync,notrunc bs=512 seek=63 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/tzsw" of="$DISK" conv=fsync,notrunc bs=512 seek=2111 >"$SAVE_ERROR" 2>&1 || show_error
diff --git a/projects/Odroid_U2/bootloader/u-boot-fuse-emmc b/projects/Odroid_U2/bootloader/u-boot-fuse-emmc
new file mode 100644
index 0000000..0ff53dc
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/u-boot-fuse-emmc
@@ -0,0 +1,7 @@
+# Drop in Project Specific U-Boot Custom Fusing script | ODROID_U2
+# This script is run inside the scripts/mkimage script when the device we are fusing is different than the defaults
+echo "image: fusing for ${PROJECT}..."
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl1" of="$DISK" conv=fsync,notrunc bs=512 seek=0 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl2" of="$DISK" conv=fsync,notrunc bs=512 seek=30 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/u-boot" of="$DISK" conv=fsync,notrunc bs=512 seek=62 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/tzsw" of="$DISK" conv=fsync,notrunc bs=512 seek=2110 >"$SAVE_ERROR" 2>&1 || show_error
diff --git a/projects/Odroid_U2/bootloader/u-boot-fuse-sd b/projects/Odroid_U2/bootloader/u-boot-fuse-sd
new file mode 100644
index 0000000..c899ba3
--- /dev/null
+++ b/projects/Odroid_U2/bootloader/u-boot-fuse-sd
@@ -0,0 +1,7 @@
+# Drop in Project Specific U-Boot Custom Fusing script | ODROID_U2
+# This script is run inside the scripts/mkimage script when the device we are fusing is different than the defaults
+echo "image: fusing for ${PROJECT}..."
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl1" of="$DISK" conv=fsync,notrunc bs=512 seek=1 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/bl2" of="$DISK" conv=fsync,notrunc bs=512 seek=31 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/u-boot" of="$DISK" conv=fsync,notrunc bs=512 seek=63 >"$SAVE_ERROR" 2>&1 || show_error
+dd if="$RELEASE_DIR/3rdparty/bootloader/tzsw" of="$DISK" conv=fsync,notrunc bs=512 seek=2111 >"$SAVE_ERROR" 2>&1 || show_error
diff --git a/projects/Odroid_U2/linux/ddfddf8/linux.arm.conf b/projects/Odroid_U2/linux/ddfddf8/linux.arm.conf
new file mode 100644
index 0000000..1213d39
--- /dev/null
+++ b/projects/Odroid_U2/linux/ddfddf8/linux.arm.conf
@@ -0,0 +1,4231 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.8.13.30 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_GPIO_H=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_INIT_PASS_ALL_PARAMS is not set
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="@DISTRONAME@"
+CONFIG_VERSION_SIGNATURE=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_FHANDLE=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_MEMCG_SWAP_ENABLED=y
+CONFIG_MEMCG_KMEM=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_HAVE_UID16=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+CONFIG_SOLARIS_X86_PARTITION=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_VT8500_SINGLE is not set
+CONFIG_GPIO_PCA953X=m
+CONFIG_KEYBOARD_GPIO_POLLED=m
+CONFIG_PLAT_SAMSUNG=y
+CONFIG_PLAT_S5P=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=1
+CONFIG_SAMSUNG_CLOCK=y
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_S5P_CLOCK=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_S5P_IRQ=y
+CONFIG_S5P_GPIO_INT=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=64
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+# CONFIG_S3C_ADC is not set
+CONFIG_S3C_DEV_HSMMC=y
+CONFIG_S3C_DEV_HSMMC1=y
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_S3C_DEV_USB_HSOTG=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_S3C64XX_DEV_SPI0=y
+CONFIG_S3C64XX_DEV_SPI1=y
+CONFIG_S3C64XX_DEV_SPI2=y
+CONFIG_SAMSUNG_DEV_KEYPAD=y
+CONFIG_SAMSUNG_DEV_PWM=y
+CONFIG_SAMSUNG_DEV_BACKLIGHT=y
+CONFIG_S5P_DEV_CSIS0=y
+CONFIG_S5P_DEV_FIMC0=y
+CONFIG_S5P_DEV_FIMC1=y
+CONFIG_S5P_DEV_FIMC2=y
+CONFIG_S5P_DEV_FIMC3=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_S5P_DEV_G2D=y
+CONFIG_S5P_DEV_I2C_HDMIPHY=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_DEV_TV=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_SAMSUNG_DMADEV=y
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+CONFIG_S5P_PM=y
+CONFIG_S5P_SLEEP=y
+CONFIG_DEBUG_S3C_UART=0
+
+#
+# SAMSUNG EXYNOS SoCs Support
+#
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+
+#
+# EXYNOS SoCs
+#
+# CONFIG_CPU_EXYNOS4210 is not set
+CONFIG_SOC_EXYNOS4212=y
+CONFIG_SOC_EXYNOS4412=y
+CONFIG_EXYNOS4_MCT=y
+CONFIG_EXYNOS_DEV_DMA=y
+CONFIG_EXYNOS_DEV_DRM=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_EXYNOS_DEV_SYSMMU=y
+CONFIG_EXYNOS4_DEV_DWMCI=y
+CONFIG_EXYNOS4_DEV_USB_OHCI=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_EXYNOS4_SETUP_KEYPAD=y
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_DWMCI=y
+CONFIG_EXYNOS4_SETUP_DWMCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_FIMC=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_EXYNOS_SETUP_SPI=y
+
+#
+# EXYNOS4210 Boards
+#
+# CONFIG_MACH_SMDKC210 is not set
+# CONFIG_MACH_SMDKV310 is not set
+# CONFIG_MACH_ARMLEX4210 is not set
+# CONFIG_MACH_UNIVERSAL_C210 is not set
+# CONFIG_MACH_NURI is not set
+# CONFIG_MACH_ORIGEN is not set
+
+#
+# EXYNOS4212 Boards
+#
+CONFIG_MACH_SMDK4212=y
+
+#
+# EXYNOS4412 Boards
+#
+CONFIG_MACH_SMDK4412=y
+CONFIG_MACH_HKDK4412=y
+# CONFIG_ODROID_X is not set
+# CONFIG_ODROID_X2 is not set
+CONFIG_ODROID_U2=y
+
+#
+# Flattened Device Tree based board for EXYNOS SoCs
+#
+# CONFIG_MACH_EXYNOS4_DT is not set
+
+#
+# Configuration for HSMMC 8-bit bus width
+#
+CONFIG_EXYNOS4_SDHCI_CH0_8BIT=y
+CONFIG_EXYNOS4_SDHCI_CH2_8BIT=y
+# CONFIG_ARCH_VT8500 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_ARM_VIRT_EXT is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_PL310_ERRATA_769419 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+CONFIG_ARM_GIC=y
+CONFIG_GIC_NON_BANKED=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=200
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+CONFIG_SECCOMP=y
+# CONFIG_CC_STACKPROTECTOR is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="mem=2047M"
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_CMDLINE_EXTEND=y
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+
+#
+# ARM CPU frequency scaling drivers
+#
+CONFIG_ARM_EXYNOS_CPUFREQ=y
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+CONFIG_ARM_EXYNOS4X12_CPUFREQ=y
+CONFIG_ARM_EXYNOS4x12_DVFS_HOTPLUG=y
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_RUNTIME=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_ROUTE_CLASSID=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_ACCT=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=m
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=m
+# CONFIG_NF_CONNTRACK_H323 is not set
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NF_CT_NETLINK_HELPER is not set
+CONFIG_NETFILTER_NETLINK_QUEUE_CT=y
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+CONFIG_NETFILTER_XT_SET=m
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NETMAP=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ECN=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_MAX=256
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PPTP=m
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+CONFIG_SCTP_DBG_MSG=y
+CONFIG_SCTP_DBG_OBJCNT=y
+CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 is not set
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_NONE is not set
+CONFIG_SCTP_COOKIE_HMAC_MD5=y
+CONFIG_SCTP_COOKIE_HMAC_SHA1=y
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=m
+# CONFIG_L2TP_DEBUGFS is not set
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=m
+CONFIG_L2TP_ETH=m
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=m
+CONFIG_NET_SCH_PLUG=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_EMATCH_CANID is not set
+# CONFIG_NET_EMATCH_IPSET is not set
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=m
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+# CONFIG_NETROM is not set
+# CONFIG_ROSE is not set
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+# CONFIG_6PACK is not set
+# CONFIG_BPQETHER is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_YAM is not set
+CONFIG_CAN=m
+# CONFIG_CAN_RAW is not set
+# CONFIG_CAN_BCM is not set
+# CONFIG_CAN_GW is not set
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=m
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_MCP251X=m
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_SOFTING is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_3WIRE=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_ATH3K=m
+CONFIG_AF_RXRPC=m
+# CONFIG_AF_RXRPC_DEBUG is not set
+CONFIG_RXKAD=m
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_LIB80211=m
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE="edid/1024x768.bin edid/1280x1024.bin edid/1280x720.bin edid/1680x1050.bin edid/1920x1080.bin"
+CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=m
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+CONFIG_SENSORS_BH1780=m
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+CONFIG_MULTICORE_RAID456=y
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_BUFIO=m
+CONFIG_DM_BIO_PRISON=m
+CONFIG_DM_PERSISTENT_DATA=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_DM_DEBUG_BLOCK_STACK_TRACING=y
+CONFIG_DM_MIRROR=m
+CONFIG_DM_RAID=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+CONFIG_DM_DELAY=m
+# CONFIG_DM_UEVENT is not set
+CONFIG_DM_FLAKEY=m
+CONFIG_DM_VERITY=m
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+CONFIG_NET_TEAM=m
+# CONFIG_NET_TEAM_MODE_BROADCAST is not set
+# CONFIG_NET_TEAM_MODE_ROUNDROBIN is not set
+# CONFIG_NET_TEAM_MODE_ACTIVEBACKUP is not set
+# CONFIG_NET_TEAM_MODE_LOADBALANCE is not set
+CONFIG_MACVLAN=m
+# CONFIG_MACVTAP is not set
+# CONFIG_VXLAN is not set
+CONFIG_NETCONSOLE=m
+CONFIG_NETPOLL=y
+CONFIG_NETPOLL_TRAP=y
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_TUN=m
+CONFIG_VETH=m
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_CADENCE is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_SMC91X=m
+CONFIG_SMC911X=m
+CONFIG_SMSC911X=m
+# CONFIG_SMSC911X_ARCH_HOOKS is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_AT803X_PHY=m
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+CONFIG_DAVICOM_PHY=m
+# CONFIG_QSEMI_PHY is not set
+CONFIG_LXT_PHY=m
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=m
+CONFIG_BROADCOM_PHY=m
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+CONFIG_REALTEK_PHY=m
+CONFIG_NATIONAL_PHY=m
+CONFIG_STE10XP=m
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=m
+CONFIG_PPPOL2TP=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_AX88179_178A=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_NCM=m
+# CONFIG_USB_NET_CDC_MBIM is not set
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_NET_QMI_WWAN=m
+# CONFIG_USB_HSO is not set
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_CDC_PHONET=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+CONFIG_WLAN=y
+CONFIG_LIBERTAS_THINFIRM=m
+# CONFIG_LIBERTAS_THINFIRM_DEBUG is not set
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_AT76C50X_USB=m
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8187=m
+CONFIG_RTL8187_LEDS=y
+CONFIG_MAC80211_HWSIM=m
+CONFIG_ATH_COMMON=m
+CONFIG_ATH_CARDS=m
+CONFIG_ATH_DEBUG=y
+CONFIG_ATH9K_HW=m
+CONFIG_ATH9K_COMMON=m
+CONFIG_ATH9K_BTCOEX_SUPPORT=y
+CONFIG_ATH9K=m
+CONFIG_ATH9K_AHB=y
+# CONFIG_ATH9K_DEBUGFS is not set
+# CONFIG_ATH9K_LEGACY_RATE_CONTROL is not set
+CONFIG_ATH9K_HTC=m
+# CONFIG_ATH9K_HTC_DEBUGFS is not set
+CONFIG_CARL9170=m
+CONFIG_CARL9170_LEDS=y
+CONFIG_CARL9170_WPC=y
+CONFIG_CARL9170_HWRNG=y
+CONFIG_ATH6KL=m
+# CONFIG_ATH6KL_SDIO is not set
+CONFIG_ATH6KL_USB=m
+# CONFIG_ATH6KL_DEBUG is not set
+CONFIG_AR5523=m
+CONFIG_B43=m
+CONFIG_B43_SSB=y
+# CONFIG_B43_SDIO is not set
+CONFIG_B43_PIO=y
+# CONFIG_B43_PHY_N is not set
+CONFIG_B43_PHY_LP=y
+# CONFIG_B43_PHY_HT is not set
+CONFIG_B43_LEDS=y
+CONFIG_B43_HWRNG=y
+# CONFIG_B43_DEBUG is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+# CONFIG_HOSTAP_FIRMWARE_NVRAM is not set
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+# CONFIG_LIBERTAS_SDIO is not set
+# CONFIG_LIBERTAS_SPI is not set
+# CONFIG_LIBERTAS_DEBUG is not set
+# CONFIG_LIBERTAS_MESH is not set
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+# CONFIG_P54_SPI is not set
+CONFIG_P54_LEDS=y
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+# CONFIG_RT2800USB_UNKNOWN is not set
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_RTL8192CU is not set
+CONFIG_RTL8192CU_V40=m
+CONFIG_RTL8812AU=m
+# CONFIG_WL_TI is not set
+# CONFIG_ZD1211RW is not set
+CONFIG_MWIFIEX=m
+# CONFIG_MWIFIEX_SDIO is not set
+CONFIG_MWIFIEX_USB=m
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+CONFIG_INPUT_POLLDEV=m
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=m
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=m
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ADP5588=m
+CONFIG_KEYBOARD_ADP5589=m
+CONFIG_KEYBOARD_ATKBD=m
+CONFIG_KEYBOARD_QT1070=m
+CONFIG_KEYBOARD_QT2160=m
+CONFIG_KEYBOARD_LKKBD=m
+CONFIG_KEYBOARD_GPIO=m
+CONFIG_KEYBOARD_TCA6416=m
+CONFIG_KEYBOARD_TCA8418=m
+CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_LM8323=m
+CONFIG_KEYBOARD_LM8333=m
+CONFIG_KEYBOARD_MAX7359=m
+CONFIG_KEYBOARD_MCS=m
+CONFIG_KEYBOARD_MPR121=m
+CONFIG_KEYBOARD_NEWTON=m
+CONFIG_KEYBOARD_OPENCORES=m
+CONFIG_KEYBOARD_SAMSUNG=m
+CONFIG_KEYBOARD_STOWAWAY=m
+# CONFIG_KEYBOARD_SUNKBD is not set
+CONFIG_KEYBOARD_XTKBD=m
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_MOUSE_GPIO=m
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_MOUSE_SYNAPTICS_USB=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_ANALOG=m
+CONFIG_JOYSTICK_A3D=m
+CONFIG_JOYSTICK_ADI=m
+CONFIG_JOYSTICK_COBRA=m
+CONFIG_JOYSTICK_GF2K=m
+CONFIG_JOYSTICK_GRIP=m
+CONFIG_JOYSTICK_GRIP_MP=m
+CONFIG_JOYSTICK_GUILLEMOT=m
+CONFIG_JOYSTICK_INTERACT=m
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_JOYSTICK_TMDC=m
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_IFORCE_USB=y
+CONFIG_JOYSTICK_IFORCE_232=y
+CONFIG_JOYSTICK_WARRIOR=m
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_JOYSTICK_ZHENHUA=m
+CONFIG_JOYSTICK_AS5011=m
+CONFIG_JOYSTICK_JOYDUMP=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+CONFIG_TABLET_USB_HANWANG=m
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_AUO_PIXCIR=m
+CONFIG_TOUCHSCREEN_BU21013=m
+CONFIG_TOUCHSCREEN_CY8CTMG110=m
+CONFIG_TOUCHSCREEN_CYTTSP_CORE=m
+CONFIG_TOUCHSCREEN_CYTTSP_I2C=m
+# CONFIG_TOUCHSCREEN_CYTTSP_SPI is not set
+CONFIG_TOUCHSCREEN_DYNAPRO=m
+CONFIG_TOUCHSCREEN_HAMPSHIRE=m
+# CONFIG_TOUCHSCREEN_EETI is not set
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_ILI210X=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+CONFIG_TOUCHSCREEN_WACOM_I2C=m
+CONFIG_TOUCHSCREEN_MAX11801=m
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MMS114=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_PIXCIR=m
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+# CONFIG_TOUCHSCREEN_USB_GOTOP is not set
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_TOUCHSCREEN_USB_ELO=y
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_TOUCHSCREEN_USB_ZYTRONIC=y
+CONFIG_TOUCHSCREEN_USB_ETT_TC45USB=y
+CONFIG_TOUCHSCREEN_USB_NEXIO=y
+CONFIG_TOUCHSCREEN_USB_EASYTOUCH=y
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+CONFIG_TOUCHSCREEN_TSC_SERIO=m
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+CONFIG_TOUCHSCREEN_TSC2007=m
+CONFIG_TOUCHSCREEN_W90X900=m
+CONFIG_TOUCHSCREEN_ST1232=m
+CONFIG_TOUCHSCREEN_TPS6507X=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_AD714X=m
+# CONFIG_INPUT_AD714X_I2C is not set
+CONFIG_INPUT_AD714X_SPI=m
+CONFIG_INPUT_BMA150=m
+CONFIG_INPUT_MMA8450=m
+CONFIG_INPUT_MPU3050=m
+CONFIG_INPUT_GP2A=m
+CONFIG_INPUT_GPIO_TILT_POLLED=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_KXTJ9=m
+CONFIG_INPUT_KXTJ9_POLLED_MODE=y
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_PCF8574=m
+# CONFIG_INPUT_PWM_BEEPER is not set
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_INPUT_ADXL34X=m
+# CONFIG_INPUT_ADXL34X_I2C is not set
+CONFIG_INPUT_ADXL34X_SPI=m
+CONFIG_INPUT_CMA3000=m
+# CONFIG_INPUT_CMA3000_I2C is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=m
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+CONFIG_GAMEPORT=m
+# CONFIG_GAMEPORT_NS558 is not set
+# CONFIG_GAMEPORT_L4 is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_KGDB_NMI is not set
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+# CONFIG_SERIAL_SAMSUNG_DEBUG is not set
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+CONFIG_HW_RANDOM_EXYNOS=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_MUX=m
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_GPIO_CUSTOM=m
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_I2C_STUB=m
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+CONFIG_SPI_S3C64XX=m
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=m
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_TS5500 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=m
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=m
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_FAIR_SHARE is not set
+CONFIG_STEP_WISE=y
+# CONFIG_USER_SPACE is not set
+CONFIG_CPU_THERMAL=y
+CONFIG_EXYNOS_THERMAL=y
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_BLOCKIO=y
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+# CONFIG_SSB_SDIOHOST is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+# CONFIG_SSB_DRIVER_GPIO is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_LP8788 is not set
+CONFIG_MFD_MAX77686=y
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_AS3711 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+CONFIG_REGULATOR_MAX77686=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_TUNER=m
+CONFIG_V4L2_MEM2MEM_DEV=y
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_VIDEOBUF_DVB=m
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_DVB_CORE=y
+CONFIG_DVB_NET=y
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+
+#
+# Media drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_RC_MAP=y
+CONFIG_RC_DECODERS=y
+CONFIG_LIRC=m
+CONFIG_IR_LIRC_CODEC=m
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_SONY_DECODER=m
+CONFIG_IR_RC5_SZ_DECODER=m
+CONFIG_IR_SANYO_DECODER=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_RC_DEVICES=y
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_IR_IMON is not set
+CONFIG_IR_MCEUSB=m
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_IGUANA is not set
+# CONFIG_IR_TTUSBIR is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_IR_GPIO_CIR is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_USB_PWC=m
+# CONFIG_USB_PWC_DEBUG is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_USB_SN9C102=m
+
+#
+# Analog TV USB devices
+#
+CONFIG_VIDEO_AU0828=m
+CONFIG_VIDEO_PVRUSB2=m
+# CONFIG_VIDEO_PVRUSB2_SYSFS is not set
+CONFIG_VIDEO_PVRUSB2_DVB=y
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_TLG2300=m
+CONFIG_VIDEO_USBVISION=m
+CONFIG_VIDEO_STK1160=m
+CONFIG_VIDEO_STK1160_AC97=y
+
+#
+# Analog/digital TV USB devices
+#
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_RC=y
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_TM6000=m
+CONFIG_VIDEO_TM6000_ALSA=m
+CONFIG_VIDEO_TM6000_DVB=m
+
+#
+# Digital TV USB devices
+#
+CONFIG_DVB_USB=m
+# CONFIG_DVB_USB_DEBUG is not set
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+# CONFIG_DVB_USB_DIBUSB_MB_FAULTY is not set
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_PCTV452E=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_USB_V2=m
+CONFIG_DVB_USB_CYPRESS_FIRMWARE=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_AF9035=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_AZ6007=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_IT913X=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_MXL111SF=m
+CONFIG_DVB_USB_RTL28XXU=m
+CONFIG_DVB_USB_DVBSKY=m
+CONFIG_SMS_USB_DRV=m
+# CONFIG_DVB_B2C2_FLEXCOP_USB is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_VIDEO_EM28XX_RC=m
+CONFIG_TTPCI_EEPROM=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_TIMBERDALE is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_SAMSUNG_S5P_FIMC=y
+CONFIG_VIDEO_S5P_FIMC=y
+# CONFIG_VIDEO_S5P_MIPI_CSIS is not set
+CONFIG_VIDEO_EXYNOS_FIMC_LITE=y
+# CONFIG_VIDEO_SAMSUNG_S5P_TV is not set
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_MEM2MEM_DEINTERLACE=y
+# CONFIG_VIDEO_SAMSUNG_S5P_G2D is not set
+CONFIG_VIDEO_SAMSUNG_S5P_JPEG=y
+CONFIG_VIDEO_SAMSUNG_S5P_MFC=y
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_SMS_SDIO_DRV is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SHARK is not set
+# CONFIG_RADIO_SHARK2 is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+CONFIG_MEDIA_COMMON_OPTIONS=y
+
+#
+# common driver options
+#
+CONFIG_SMS_SIANO_MDTV=m
+CONFIG_SMS_SIANO_RC=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+CONFIG_VIDEO_MSP3400=m
+# CONFIG_VIDEO_CS5345 is not set
+CONFIG_VIDEO_CS53L32A=m
+# CONFIG_VIDEO_TLV320AIC23B is not set
+CONFIG_VIDEO_WM8775=m
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+CONFIG_VIDEO_SAA711X=m
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+CONFIG_VIDEO_CX25840=m
+
+#
+# MPEG video encoders
+#
+CONFIG_VIDEO_CX2341X=m
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_AD9389B is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9M032 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T001 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+# CONFIG_VIDEO_S5K6AA is not set
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_SMIAPP is not set
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_AS3645A is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+
+#
+# Sensors used on soc_camera driver
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2063=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_XC4000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_FC0011=m
+CONFIG_MEDIA_TUNER_FC0012=m
+CONFIG_MEDIA_TUNER_FC0013=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_MEDIA_TUNER_E4000=m
+CONFIG_MEDIA_TUNER_FC2580=m
+CONFIG_MEDIA_TUNER_TUA9001=m
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+CONFIG_DVB_CX24120=m
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_STV090x=m
+CONFIG_DVB_STV6110x=m
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+CONFIG_DVB_DRXK=m
+CONFIG_DVB_TDA18271C2DD=m
+# CONFIG_DVB_STV0367DD is not set
+# CONFIG_DVB_TDA18212DD is not set
+
+#
+# DVB-S (satellite) frontends
+#
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_ZL10039=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_M88DS3103=m
+CONFIG_DVB_M88DC2800=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_DS3000=m
+CONFIG_DVB_MB86A16=m
+CONFIG_DVB_TDA10071=m
+
+#
+# DVB-T (terrestrial) frontends
+#
+CONFIG_DVB_SP8870=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_S5H1432=m
+CONFIG_DVB_DRXD=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_DIB9000=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_AF9013=m
+CONFIG_DVB_EC100=m
+CONFIG_DVB_HD29L2=m
+CONFIG_DVB_STV0367=m
+CONFIG_DVB_CXD2820R=m
+CONFIG_DVB_RTL2830=m
+CONFIG_DVB_RTL2832=m
+
+#
+# DVB-C (cable) frontends
+#
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0297=m
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_LG2160=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_AU8522_DTV=m
+CONFIG_DVB_AU8522_V4L=m
+CONFIG_DVB_S5H1411=m
+
+#
+# ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_S921=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_MB86A20S=m
+
+#
+# Digital terrestrial only tuners/PLL
+#
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_TUNER_DIB0090=m
+
+#
+# SEC control devices for DVB-S
+#
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_LNBP22=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_ISL6423=m
+CONFIG_DVB_A8293=m
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DVB_LGS8GXX=m
+CONFIG_DVB_ATBM8830=m
+CONFIG_DVB_TDA665x=m
+CONFIG_DVB_IX2505V=m
+CONFIG_DVB_IT913X_FE=m
+CONFIG_DVB_M88RS2000=m
+CONFIG_DVB_TS2020=m
+CONFIG_DVB_AF9033=m
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+CONFIG_MALI400=y
+# CONFIG_MALI450 is not set
+# CONFIG_MALI400_DEBUG is not set
+# CONFIG_MALI400_PROFILING is not set
+# CONFIG_MALI400_UMP is not set
+# CONFIG_MALI_DVFS is not set
+CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH=y
+# CONFIG_MALI_SHARED_INTERRUPTS is not set
+# CONFIG_MALI_PMU_PARALLEL_POWER_UP is not set
+# CONFIG_MALI_QUIET is not set
+
+#
+# Graphics support
+#
+CONFIG_DRM=y
+CONFIG_DRM_USB=m
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+CONFIG_DRM_EXYNOS=y
+CONFIG_DRM_EXYNOS_DMABUF=y
+# CONFIG_DRM_EXYNOS_FIMD is not set
+CONFIG_DRM_EXYNOS_HDMI=y
+# CONFIG_DRM_EXYNOS_VIDI is not set
+CONFIG_DRM_EXYNOS_G2D=y
+# CONFIG_DRM_EXYNOS_IPP is not set
+CONFIG_DRM_UDL=m
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=m
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_FB_SMSCUFX is not set
+CONFIG_FB_UDL=m
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_LCD_LP101WH1=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_FONT_AUTOSELECT=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=m
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_RAWMIDI_SEQ=m
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_AC97_CODEC=m
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_AC97_POWER_SAVE is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_I2S=y
+# CONFIG_SND_SOC_SAMSUNG_SMDK_WM8994 is not set
+# CONFIG_SND_SOC_SAMSUNG_SMDK_SPDIF is not set
+# CONFIG_SND_SOC_SMDK_WM8994_PCM is not set
+CONFIG_SND_SOC_HKDK_MAX98090=y
+CONFIG_MAX98090_HEADSET=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_MAX98090=y
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=m
+
+#
+# HID support
+#
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=m
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACRUX=m
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=m
+CONFIG_HID_AUREAL=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_PRODIKEYS=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_HOLTEK=m
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+# CONFIG_HID_ICADE is not set
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+CONFIG_HID_LCPOWER=m
+CONFIG_HID_LENOVO_TPKBD=m
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_LOGITECH_DJ=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MAGICMOUSE=m
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_BACKLIGHT=y
+CONFIG_HID_PICOLCD_LCD=y
+CONFIG_HID_PICOLCD_LEDS=y
+# CONFIG_HID_PICOLCD_CIR is not set
+CONFIG_HID_PRIMAX=m
+# CONFIG_HID_PS3REMOTE is not set
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAITEK=m
+CONFIG_HID_SAMSUNG=m
+# CONFIG_HID_SONY is not set
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_WIIMOTE_EXT=y
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=m
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_MON=m
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_USB_S5P_HSIC0=y
+CONFIG_USB_S5P_HSIC1=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_EXYNOS=y
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_U132_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_SSB is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_TMC=m
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_REALTEK_AUTOPM=y
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_METRO=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_VIVOPAY_SERIAL=m
+CONFIG_USB_SERIAL_ZIO=m
+# CONFIG_USB_SERIAL_ZTE is not set
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_SERIAL_QT2=m
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_YUREX=m
+CONFIG_USB_EZUSB_FX2=m
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_EXYNOS_SWITCH=y
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_RCAR_PHY is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+CONFIG_USB_S3C_HSOTG=y
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_ZERO=m
+CONFIG_USB_AUDIO=m
+CONFIG_GADGET_UAC1=y
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_ETH_EEM=y
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_FUNCTIONFS_ETH=y
+CONFIG_USB_FUNCTIONFS_RNDIS=y
+CONFIG_USB_FUNCTIONFS_GENERIC=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_MIDI_GADGET=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_USB_G_NOKIA=m
+CONFIG_USB_G_ACM_MS=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+# CONFIG_USB_G_MULTI_CDC is not set
+CONFIG_USB_G_HID=m
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SDHCI_S3C_DMA is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_IDMAC=y
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_MAX77686=y
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_HAVE_S3C_RTC=y
+# CONFIG_RTC_DRV_S3C is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_TIMB_DMA is not set
+CONFIG_PL330_DMA=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_VHCI_HCD=m
+CONFIG_USBIP_HOST=m
+CONFIG_USBIP_DEBUG=y
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+CONFIG_R8712U=m
+CONFIG_RTS5139=m
+# CONFIG_RTS5139_DEBUG is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_VT6656 is not set
+
+#
+# IIO staging drivers
+#
+# CONFIG_IIO_ST_HWMON is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16204 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16220 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_LIS3L02DQ is not set
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7291 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_ADT7410 is not set
+# CONFIG_AD7280 is not set
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7152 is not set
+# CONFIG_AD7746 is not set
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD5930 is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_AD9850 is not set
+# CONFIG_AD9852 is not set
+# CONFIG_AD9910 is not set
+# CONFIG_AD9951 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16060 is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+
+#
+# Light sensors
+#
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2x7x is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_SENSORS_HMC5843 is not set
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7753 is not set
+# CONFIG_ADE7754 is not set
+# CONFIG_ADE7758 is not set
+# CONFIG_ADE7759 is not set
+# CONFIG_ADE7854 is not set
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+CONFIG_ZRAM=m
+# CONFIG_ZRAM_DEBUG is not set
+CONFIG_ZSMALLOC=y
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+# CONFIG_CED1401 is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# Hardware Spinlock drivers
+#
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_EXYNOS_IOMMU is not set
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+# CONFIG_IIO_BUFFER is not set
+# CONFIG_IIO_TRIGGER is not set
+
+#
+# Accelerometers
+#
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7266 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_TI_ADC081C is not set
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+
+#
+# Hid Sensor IIO Common
+#
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5686 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MCP4725 is not set
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16136 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16480 is not set
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_VCNL4000 is not set
+
+#
+# Magnetometer sensors
+#
+CONFIG_PWM=y
+CONFIG_PWM_SAMSUNG=y
+CONFIG_PWM_SOFTWARE=y
+# CONFIG_IPACK_BUS is not set
+
+#
+# Hardkernel Specific Hardware
+#
+CONFIG_ODROID_U2_FAN=y
+CONFIG_VIDEO_SAMSUNG_S5P_HDMI_CEC=y
+CONFIG_ODROID_IOBOARD=m
+
+#
+# Ubuntu Supplied Third-Party Device Drivers
+#
+CONFIG_DM_RAID45=m
+CONFIG_AUFS_FS=m
+CONFIG_AUFS_BRANCH_MAX_127=y
+# CONFIG_AUFS_BRANCH_MAX_511 is not set
+# CONFIG_AUFS_BRANCH_MAX_1023 is not set
+# CONFIG_AUFS_BRANCH_MAX_32767 is not set
+CONFIG_AUFS_SBILIST=y
+# CONFIG_AUFS_HNOTIFY is not set
+# CONFIG_AUFS_EXPORT is not set
+# CONFIG_AUFS_RDU is not set
+# CONFIG_AUFS_SP_IATTR is not set
+# CONFIG_AUFS_SHWH is not set
+CONFIG_AUFS_BR_RAMFS=y
+# CONFIG_AUFS_BR_FUSE is not set
+CONFIG_AUFS_BR_HFSPLUS=y
+CONFIG_AUFS_BDEV_LOOP=y
+# CONFIG_AUFS_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+CONFIG_JFS_FS=m
+# CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_XFS_FS=m
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=m
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
+# CONFIG_CUSE is not set
+# CONFIG_OVERLAYFS_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=m
+# CONFIG_HFS_FS is not set
+CONFIG_HFSPLUS_FS=m
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=m
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+CONFIG_ROMFS_FS=m
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=m
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_PNFS_BLOCK=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_FAULT_INJECTION=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_SUNRPC_SWAP=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+CONFIG_CIFS_DEBUG=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_SMB2 is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_PI_LIST=y
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+# CONFIG_KGDB_TESTS is not set
+# CONFIG_KGDB_KDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_S3C_UART0=y
+# CONFIG_DEBUG_S3C_UART1 is not set
+# CONFIG_DEBUG_S3C_UART2 is not set
+# CONFIG_DEBUG_S3C_UART3 is not set
+# CONFIG_DEBUG_LL_UART_NONE is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_OC_ETM is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_ARM is not set
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_ARM=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_FCRYPT=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=m
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_PERCPU_RWSEM=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
diff --git a/projects/Odroid_U2/options b/projects/Odroid_U2/options
new file mode 100644
index 0000000..9811f2b
--- /dev/null
+++ b/projects/Odroid_U2/options
@@ -0,0 +1,159 @@
+################################################################################
+# setup system defaults
+################################################################################
+
+  # The TARGET_CPU variable controls which processor should be targeted for
+  # generated code.
+    case $TARGET_ARCH in
+      arm)
+        # TARGET_CPU:
+        # arm2 arm250 arm3 arm6 arm60 arm600 arm610 arm620 arm7 arm7m arm7d
+        # arm7dm arm7di arm7dmi arm70 arm700 arm700i arm710 arm710c
+        # arm7100 arm720 arm7500 arm7500fe arm7tdmi arm7tdmi-s arm710t
+        # arm720t arm740t strongarm strongarm110 strongarm1100
+        # strongarm1110 arm8 arm810 arm9 arm9e arm920 arm920t arm922t
+        # arm946e-s arm966e-s arm968e-s arm926ej-s arm940t arm9tdmi
+        # arm10tdmi arm1020t arm1026ej-s arm10e arm1020e arm1022e
+        # arm1136j-s arm1136jf-s mpcore mpcorenovfp arm1156t2-s
+        # arm1176jz-s arm1176jzf-s cortex-a8 cortex-a9 cortex-r4
+        # cortex-r4f cortex-m3 cortex-m1 xscale iwmmxt iwmmxt2 ep9312.
+        #
+        TARGET_CPU="cortex-a9"
+
+        # TARGET_FLOAT:
+        # Specifies which floating-point ABI to use. Permissible values are:
+        # soft softfp hard
+        TARGET_FLOAT="hard"
+
+        # TARGET_FPU:
+        # This specifies what floating point hardware (or hardware emulation) is
+        # available on the target. Permissible names are:
+        # fpa fpe2 fpe3 maverick vfp vfpv3 vfpv3-fp16 vfpv3-d16 vfpv3-d16-fp16
+        # vfpv3xd vfpv3xd-fp16 neon neon-fp16 vfpv4 vfpv4-d16 fpv4-sp-d16
+        # neon-vfpv4.
+        TARGET_FPU="neon-fp16"
+        ;;
+    esac
+
+  # Bootloader to use (syslinux / u-boot / atv-bootloader / bcm2835-bootloader)
+    BOOTLOADER="u-boot"
+
+  # u-boot version to use (default to mainline)
+    UBOOT_VERSION="mainline"
+
+  # Configuration for u-boot
+    UBOOT_CONFIG="odroid_defconfig"
+
+  # Target Configfile for u-boot
+    UBOOT_CONFIGFILE="boot.ini"
+
+  # Kernel target
+    KERNEL_TARGET="zImage"
+
+  # Kernel extra targets to build
+    KERNEL_UBOOT_EXTRA_TARGET=""
+
+  # Additional kernel make parameters (for example to specify the u-boot loadaddress)
+    KERNEL_MAKE_EXTRACMD="dtbs"
+
+  # Kernel to use. values can be:
+  # default:  default mainline kernel
+    LINUX="mfc-3.8"
+
+################################################################################
+# setup build defaults
+################################################################################
+
+  # Build optimizations (size/normal)
+    OPTIMIZATIONS="size"
+
+  # Project CFLAGS
+    PROJECT_CFLAGS=""
+
+  # LTO (Link Time Optimization) support
+    LTO_SUPPORT="yes"
+
+  # GOLD (Google Linker) support
+    GOLD_SUPPORT="yes"
+
+  # SquashFS compression method (gzip / lzo / xz)
+    SQUASHFS_COMPRESSION="gzip"
+
+################################################################################
+# setup project defaults
+################################################################################
+
+  # build and install ALSA Audio support (yes / no)
+    ALSA_SUPPORT="yes"
+
+  # OpenGL(X) implementation to use (no / mesa)
+    OPENGL="no"
+
+  # OpenGL-ES implementation to use (no / bcm2835-driver / gpu-viv-bin-mx6q / opengl-mali / opengl-meson6)
+    OPENGLES="opengl-mali"
+
+  # include uvesafb support (yes / no)
+    UVESAFB_SUPPORT="no"
+
+  # Displayserver to use (x11 / no)
+    DISPLAYSERVER="x11"
+
+  # Windowmanager to use (ratpoison / fluxbox / none)
+    WINDOWMANAGER="none"
+
+  # Xorg Graphic drivers to use (all / i915,i965,r200,r300,r600,nvidia)
+  # Space separated list is supported,
+  # e.g. GRAPHIC_DRIVERS="i915 i965 r300 r600 radeonsi nvidia"
+    GRAPHIC_DRIVERS="armsoc"
+
+  # KODI Player implementation to use (default / bcm2835-driver / libfslvpuwrap / libamcodec)
+    KODIPLAYER_DRIVER="odroid-mfc"
+
+  # Modules to install in initramfs for early boot
+    INITRAMFS_MODULES=""
+
+  # additional drivers to install:
+  # for a list of additinoal drivers see packages/linux-drivers
+  # Space separated list is supported,
+  # e.g. ADDITIONAL_DRIVERS="DRIVER1 DRIVER2"
+    ADDITIONAL_DRIVERS="$ADDITIONAL_DRIVERS"
+
+  # additional Firmware to use (dvb-firmware, misc-firmware, wlan-firmware)
+  # Space separated list is supported,
+  # e.g. FIRMWARE="dvb-firmware misc-firmware wlan-firmware"
+    FIRMWARE="misc-firmware wlan-firmware dvb-firmware samsung-firmware"
+
+  # build and install ATV IR remote support (yes / no)
+    ATVCLIENT_SUPPORT="no"
+
+  # build and install IRServer IR/LCD support (yes / no)
+    IRSERVER_SUPPORT="no"
+
+  # Amlogic IR remote support (yes / no)
+    AMREMOTE_SUPPORT="no"
+
+  # build with swap support (yes / no)
+    SWAP_SUPPORT="yes"
+
+  # swap support enabled per default (yes / no)
+    SWAP_ENABLED_DEFAULT="no"
+
+  # swapfile size if SWAP_SUPPORT=yes in MB
+    SWAPFILESIZE="128"
+
+  # build with installer (yes / no)
+    INSTALLER_SUPPORT="no"
+
+  # extra build dependeices
+    EXTRA_DEPS="mkimage"
+    EXTRA_DEPS_PKG="u-boot-tools"
+
+  # kernel image name
+    KERNEL_NAME="KERNEL"
+
+  # set the addon dirs
+    ADDON_PATH="$ADDON_VERSION/imx6/$TARGET_ARCH"
+    ADDON_URL="$ADDON_SERVER_URL/$ADDON_PATH"
+
+  # set the start of the system partition during the mkimage process
+    SYSTEM_PART_START=3072
diff --git a/projects/Odroid_U2/packages/odroid-u2-bootloader/package.mk b/projects/Odroid_U2/packages/odroid-u2-bootloader/package.mk
new file mode 100644
index 0000000..4fd7831
--- /dev/null
+++ b/projects/Odroid_U2/packages/odroid-u2-bootloader/package.mk
@@ -0,0 +1,44 @@
+################################################################################
+#      This file is part of LibreELEC - http://www.libreelec.tv
+#      Copyright (C) 2009-2016
+#
+#  LibreELEC is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  LibreELEC is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with LibreELEC.  If not, see <http://www.gnu.org/licenses/>.
+################################################################################
+
+PKG_NAME="odroid-u2-bootloader"
+PKG_VERSION="33e05ff"
+PKG_REV="1"
+PKG_ARCH="any"
+PKG_LICENSE="other"
+PKG_SITE="http://hardkernel.com"
+#FIXME: upload source tarball to sources.libreelec.tv
+PKG_URL="http://people.piment-noir.org/~fraggle/download/odroid/$PKG_NAME-$PKG_VERSION.tar.xz"
+PKG_TARGET_DEPENDS_TARGET="toolchain"
+PKG_SECTION=""
+PKG_SHORTDESC="Hardkernel binary boot blobs"
+PKG_LONGDESC="Hardkernel binary boot blobs"
+
+PKG_IS_ADDON="no"
+PKG_AUTORECONF="no"
+
+make_target() {
+  : # Do nothing
+}
+
+makeinstall_target() {
+  install -D -m 0644 bl1.bin $INSTALL/usr/share/bootloader/bl1
+  install -D -m 0644 bl2.bin $INSTALL/usr/share/bootloader/bl2
+  install -D -m 0644 tzsw.bin $INSTALL/usr/share/bootloader/tzsw
+}
+
diff --git a/projects/Odroid_U2/patches/kodi/9999.9990_kodi_default-fixed-441khz-audio.patch b/projects/Odroid_U2/patches/kodi/9999.9990_kodi_default-fixed-441khz-audio.patch
new file mode 100644
index 0000000..9342ba2
--- /dev/null
+++ b/projects/Odroid_U2/patches/kodi/9999.9990_kodi_default-fixed-441khz-audio.patch
@@ -0,0 +1,21 @@
+--- xbmc-13-0f3db05/system/settings/settings.xml.orig	2014-11-04 19:31:55.411680520 -0500
++++ xbmc-13-0f3db05/system/settings/settings.xml	2014-11-04 19:32:17.051519170 -0500
+@@ -2403,7 +2403,7 @@
+         </setting>
+         <setting id="audiooutput.config" type="integer" label="337" help="36361">
+           <level>2</level>
+-          <default>2</default>
++          <default>1</default>
+           <constraints>
+             <options>
+               <option label="338">1</option>
+@@ -2415,7 +2415,7 @@
+         </setting>
+         <setting id="audiooutput.samplerate" type="integer" label="458" help="36523">
+           <level>2</level>
+-          <default>48000</default>
++          <default>44100</default>
+           <dependencies>
+             <dependency type="visible">
+               <and>
+
diff --git a/projects/Odroid_U2/patches/kodi/9999.9991_kodi_add-mfc-codec-full.patch b/projects/Odroid_U2/patches/kodi/9999.9991_kodi_add-mfc-codec-full.patch
new file mode 100644
index 0000000..bdac3fe
--- /dev/null
+++ b/projects/Odroid_U2/patches/kodi/9999.9991_kodi_add-mfc-codec-full.patch
@@ -0,0 +1,2688 @@
+---
+ configure.ac                                                |   41 	40 +	1 -	0 !
+ m4/xbmc_arch.m4                                             |    2 	1 +	1 -	0 !
+ project/cmake/CMakeLists.txt                                |    1 	1 +	0 -	0 !
+ project/cmake/scripts/common/ArchSetup.cmake                |    8 	8 +	0 -	0 !
+ xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp                 |   39 	26 +	13 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp        |    5 	5 +	0 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp         |   29 	24 +	5 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt       |    5 	5 +	0 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp |  579 	579 +	0 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h   |   63 	63 +	0 -	0 !
+ xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in          |    5 	4 +	1 -	0 !
+ xbmc/linux/CMakeLists.txt                                   |    2 	2 +	0 -	0 !
+ xbmc/linux/LinuxV4l2Sink.cpp                                |  311 	311 +	0 -	0 !
+ xbmc/linux/LinuxV4l2Sink.h                                  |   71 	71 +	0 -	0 !
+ xbmc/linux/Makefile.in                                      |    1 	1 +	0 -	0 !
+ xbmc/system_gl.h                                            |    4 	4 +	0 -	0 !
+ xbmc/utils/AMLUtils.cpp                                     |   93 	87 +	6 -	0 !
+ xbmc/utils/CPUInfo.cpp                                      |   25 	13 +	12 -	0 !
+ xbmc/windowing/X11/WinSystemX11.cpp                         |    2 	1 +	1 -	0 !
+ xbmc/windowing/egl/CMakeLists.txt                           |    6 	4 +	2 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp                 |   93 	67 +	26 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeAmlogic.h                   |   19 	17 +	2 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeFbdev.cpp                   |  183 	183 +	0 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeFbdev.h                     |   68 	68 +	0 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeHybris.cpp                  |  279 	279 +	0 -	0 !
+ xbmc/windowing/egl/EGLNativeTypeHybris.h                    |   77 	77 +	0 -	0 !
+ xbmc/windowing/egl/EGLWrapper.cpp                           |   17 	12 +	5 -	0 !
+ xbmc/windowing/egl/Makefile.in                              |    4 	4 +	0 -	0 !
+ 28 files changed, 1957 insertions(+), 75 deletions(-)
+
+--- a/configure.ac
++++ b/configure.ac
+@@ -214,6 +214,10 @@ libbluetooth_enabled="== libbluetooth en
+ libbluetooth_disabled="== libbluetooth disabled. Bluetooth support will not be available. =="
+ 
+ 
++# Odroid stuff
++hybris_enabled="== Libhybris enabled. =="
++hybris_disabled="== Libhybris disabled. =="
++
+ AC_ARG_WITH([ffmpeg],
+   [AS_HELP_STRING([--with-ffmpeg],
+   [ffmpeg options: auto (search pkg-config or auto build), force (always build ffmpeg), shared (link dynamically), path_to_ffmpeg [default=force]])],
+@@ -475,7 +479,7 @@ AC_ARG_ENABLE([gtest],
+ 
+ AC_ARG_ENABLE([codec],
+   [AS_HELP_STRING([--enable-codec],
+-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec and imxvpu)])],
++  [enable additional codecs from a list of comma separated names, (default is none, choices are mfc, amcodec and imxvpu)])],
+   [add_codecs=$enableval],
+   [add_codecs=no])
+ 
+@@ -486,6 +490,13 @@ AC_ARG_ENABLE([libav-compat],
+   [use_libav_hacks=$enableval],
+   [use_libav_hacks=no])
+ 
++# Odroid stuff
++AC_ARG_ENABLE([hybris],
++  [AS_HELP_STRING([--enable-hybris],
++  [enable use of Libhybris (default is no) 'Linux only'])],
++  [use_hybris=$enableval],
++  [use_hybris=no])
++
+ ### End of external library options
+ 
+ if test "x$host_vendor" != "xapple"; then
+@@ -1524,6 +1535,23 @@ else
+   AC_MSG_NOTICE($libcap_disabled)
+ fi
+ 
++# Odroid stuff
++if test "x$use_hybris" != "xno"; then
++  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_HYBRIS")
++  USE_HYBRIS=1;
++  AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
++  AC_DEFINE(HAS_HYBRIS, [1], [Define if supporting Hybris based systems])
++  PKG_CHECK_MODULES([HWCOMPOSEREGL],  [hwcomposer-egl >= 0.1],
++    [INCLUDES="$INCLUDES -I/usr/include/hybris $HWCOMPOSEREGL_CFLAGS"; LIBS="$LIBS $HWCOMPOSEREGL_LIBS"],
++    AC_MSG_ERROR($missing_library))
++  PKG_CHECK_MODULES([HYBRISEGL],  [hybris-egl-platform >= 0.1],
++    [INCLUDES="$INCLUDES $HYBRISEGL_CFLAGS"; LIBS="$LIBS $HYBRISEGL_LIBS"],
++    AC_MSG_ERROR($missing_library))
++  PKG_CHECK_MODULES([LIBHARDWARE],  [libhardware >= 0.1],
++    [INCLUDES="$INCLUDES $LIBHARDWARE_CFLAGS"; LIBS="$LIBS $LIBHARDWARE_LIBS -lsync -lmedia"],
++    AC_MSG_ERROR($missing_library))
++fi
++
+ # FFmpeg
+ FFMPEG_LIBNAMES="libavcodec >= 56.26.100
+                  libavfilter >= 5.11.102
+@@ -1745,6 +1773,9 @@ esac
+ # remember to convert commas to spaces
+ for codecs in `echo $add_codecs | sed 's/,/ /g'`; do
+   case $codecs in
++    *mfc*)
++        XB_ADD_CODEC([MFC], [mfc], [$codecs])
++        ;;
+     *amcodec*)
+       AC_CHECK_HEADER([amcodec/codec_error.h],, AC_MSG_ERROR($missing_headers))
+       XB_ADD_CODEC([LIBAMCODEC], [amcodec], [$codecs])
+@@ -2133,6 +2164,13 @@ else
+   final_message="$final_message\n  additional codecs:\tNo"
+ fi
+ 
++# Odroid stuff
++if test "x$use_hybris" != "xno"; then
++  final_message="$final_message\n  Odroid Hybris support:\tYes"
++else
++  final_message="$final_message\n  Odroid Hybris support:\tNo"
++fi
++
+ ### External libraries messages
+ 
+ if test "$host_vendor" = "apple" ; then
+@@ -2329,6 +2367,7 @@ AC_SUBST(HAVE_SSE4)
+ AC_SUBST(USE_MMAL)
+ AC_SUBST(USE_X11)
+ AC_SUBST(USE_OPTICAL_DRIVE)
++AC_SUBST(USE_HYBRIS)
+ 
+ # pushd and popd are not available in other shells besides bash, so implement
+ # our own pushd/popd functions
+--- a/m4/xbmc_arch.m4
++++ b/m4/xbmc_arch.m4
+@@ -23,7 +23,7 @@ case $build in
+   powerpc64-*-linux-gnu*|powerpc64-*-linux-uclibc*)
+      AC_SUBST(NATIVE_ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_POWERPC64")
+      ;;
+-  arm*-*-linux-gnu*|arm*-*-linux-uclibc*)
++  arm*-*-linux-gnu*|arm*-*-linux-uclibc*|aarch64*-*-linux-gnu*|aarch64*-*-linux-uclibc*)
+      AC_SUBST(NATIVE_ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
+      ;;
+   *)
+--- a/project/cmake/scripts/common/ArchSetup.cmake
++++ b/project/cmake/scripts/common/ArchSetup.cmake
+@@ -150,6 +150,14 @@ if(NOT DEFINED NEON OR NEON)
+   endif()
+ endif()
+ 
++if(NOT DEFINED MFC OR MFC)
++  option(ENABLE_MFC "Enable MFC Exynos4/5 codec" ${MFC})
++  if(ENABLE_MFC)
++    message(STATUS "MFC Exynos4/5 codec enabled")
++    list(APPEND SYSTEM_DEFINES -DHAS_MFC=1)
++  endif()
++endif()
++
+ if(CMAKE_BUILD_TYPE STREQUAL "Debug")
+   add_options (ALL_LANGUAGES DEBUG "-g" "-D_DEBUG" "-Wall")
+ endif()
+--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
++++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+@@ -490,6 +490,7 @@ snd_pcm_chmap_t* CAESinkALSA::SelectALSA
+ 
+ void CAESinkALSA::GetAESParams(const AEAudioFormat& format, std::string& params)
+ {
++#if !defined(HAS_LIBAMCODEC)
+   if (m_passthrough)
+     params = "AES0=0x06";
+   else
+@@ -506,6 +507,7 @@ void CAESinkALSA::GetAESParams(const AEA
+   else if (format.m_sampleRate ==  44100) params += ",AES3=0x00";
+   else if (format.m_sampleRate ==  32000) params += ",AES3=0x03";
+   else params += ",AES3=0x01";
++#endif
+ }
+ 
+ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
+@@ -743,16 +745,16 @@ bool CAESinkALSA::InitializeHW(const ALS
+   snd_pcm_hw_params_get_buffer_size_max(hw_params, &bufferSize);
+   snd_pcm_hw_params_get_period_size_max(hw_params, &periodSize, NULL);
+ 
+-  /* 
+-   We want to make sure, that we have max 200 ms Buffer with 
++  /*
++   We want to make sure, that we have max 200 ms Buffer with
+    a periodSize of approx 50 ms. Choosing a higher bufferSize
+    will cause problems with menu sounds. Buffer will be increased
+    after those are fixed.
+   */
+   periodSize  = std::min(periodSize, (snd_pcm_uframes_t) sampleRate / 20);
+   bufferSize  = std::min(bufferSize, (snd_pcm_uframes_t) sampleRate / 5);
+-  
+-  /* 
++
++  /*
+    According to upstream we should set buffer size first - so make sure it is always at least
+    4x period size to not get underruns (some systems seem to have issues with only 2 periods)
+   */
+@@ -771,7 +773,7 @@ bool CAESinkALSA::InitializeHW(const ALS
+     snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
+     CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Request: Failed to limit periodSize to %lu", periodSizeMax);
+   }
+-  
++
+   // first trying bufferSize, PeriodSize
+   // for more info see here:
+   // http://mailman.alsa-project.org/pipermail/alsa-devel/2009-September/021069.html
+@@ -781,22 +783,24 @@ bool CAESinkALSA::InitializeHW(const ALS
+   snd_pcm_uframes_t periodSizeTemp, bufferSizeTemp;
+   periodSizeTemp = periodSize;
+   bufferSizeTemp = bufferSize;
+-  if (snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+-    || snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0
++  int dir = 0;
++
++  if (snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, &dir) != 0
++    || snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+     || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+   {
+     bufferSize = bufferSizeTemp;
+     periodSize = periodSizeTemp;
+     // retry with PeriodSize, bufferSize
+     snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
+-    if (snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0
++    if (snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, &dir) != 0
+       || snd_pcm_hw_params_set_buffer_size_near(m_pcm, hw_params_copy, &bufferSize) != 0
+       || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+     {
+       // try only periodSize
+       periodSize = periodSizeTemp;
+       snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
+-      if(snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0 
++      if(snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, &dir) != 0
+         || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
+       {
+         // try only BufferSize
+@@ -818,7 +822,7 @@ bool CAESinkALSA::InitializeHW(const ALS
+       snd_pcm_get_params(m_pcm, &bufferSize, &periodSize);
+     }
+   }
+-  
++
+   CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Got: periodSize %lu, bufferSize %lu", periodSize, bufferSize);
+ 
+   /* set the format parameters */
+@@ -1300,6 +1304,15 @@ void CAESinkALSA::EnumerateDevicesEx(AED
+ 
+ AEDeviceType CAESinkALSA::AEDeviceTypeFromName(const std::string &name)
+ {
++
++#if defined(HAS_LIBAMCODEC)
++  // ugly workaround to show DTS / AC3 caps
++  // but don't run into multi channel issues
++  // as we can only open 2 pcm channels
++  // God, forgive me I wrote this
++  return AE_DEVTYPE_IEC958;
++#endif
++
+   if (name.substr(0, 4) == "hdmi")
+     return AE_DEVTYPE_HDMI;
+   else if (name.substr(0, 6) == "iec958" || name.substr(0, 5) == "spdif")
+@@ -1404,9 +1417,9 @@ void CAESinkALSA::EnumerateDevice(AEDevi
+ 
+             if (badHDMI)
+             {
+-              /* 
+-               * Warn about disconnected devices, but keep them enabled 
+-               * Detection can go wrong on Intel, Nvidia and on all 
++              /*
++               * Warn about disconnected devices, but keep them enabled
++               * Detection can go wrong on Intel, Nvidia and on all
+                * AMD (fglrx) hardware, so it is not safe to close those
+                * handles
+                */
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
+@@ -41,6 +41,9 @@
+ #include "Video/DVDVideoCodecAndroidMediaCodec.h"
+ #include "platform/android/activity/AndroidFeatures.h"
+ #endif
++#if defined(HAS_MFC)
++#include "Video/DVDVideoCodecMFC.h"
++#endif
+ #include "Audio/DVDAudioCodecFFmpeg.h"
+ #include "Audio/DVDAudioCodecPassthrough.h"
+ #include "Overlay/DVDOverlayCodecSSA.h"
+@@ -149,6 +152,8 @@ CDVDVideoCodec* CDVDFactoryCodec::Create
+     pCodec = OpenCodec(new CDVDVideoCodecOpenMax(processInfo), hint, options);
+ #elif defined(HAS_MMAL)
+     pCodec = OpenCodec(new CMMALVideo(processInfo), hint, options);
++#elif defined(HAS_MFC)
++    pCodec = OpenCodec(new CDVDVideoCodecMFC(processInfo), hint, options);
+ #endif
+     if (pCodec)
+       return pCodec;
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
+@@ -427,7 +427,25 @@ void dumpfile_write(am_private_t *para,
+   }
+ 
+   if (para->dumpdemux && para->dumpfile != -1)
+-    write(para->dumpfile, buf, bufsiz);
++    int ret = write(para->dumpfile, buf, bufsiz);
++}
++
++static int set_pts_pcrscr(int64_t value)
++{
++  int ret;
++  int fd = open("/sys/class/tsync/pts_pcrscr", O_WRONLY);
++  if (fd >= 0)
++  {
++    char pts_str[64];
++    unsigned long pts = (unsigned long)value;
++    sprintf(pts_str, "0x%lx", pts);
++    ret = write(fd, pts_str, strlen(pts_str));
++    close(fd);
++    return 0;
++  }
++
++  CLog::Log(LOGERROR, "set_pts_pcrscr: open pts_pcrscr error");
++  return -1;
+ }
+ 
+ static vformat_t codecid_to_vformat(enum AVCodecID id)
+@@ -1582,7 +1600,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamIn
+       // h264 in an avi file
+       if (m_hints.ptsinvalid)
+         am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+-      break; 
++      break;
+     case VFORMAT_REAL:
+       am_private->stream_type = AM_STREAM_RM;
+       am_private->vcodec.noblock = 1;
+@@ -1646,7 +1664,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamIn
+   am_private->am_pkt.codec = &am_private->vcodec;
+   pre_header_feeding(am_private, &am_private->am_pkt);
+ 
+-  m_display_rect = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight);
++  m_display_rect = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight);
+ 
+   std::string strScaler;
+   SysfsUtils::GetString("/sys/class/ppmgr/ppscaler", strScaler);
+@@ -2200,7 +2218,6 @@ void CAMLCodec::SetVideoRect(const CRect
+         int diff = (int) ((dst_rect.Height() - dst_rect.Width()) / 2);
+         dst_rect = CRect(DestRect.x1 - diff, DestRect.y1, DestRect.x2 + diff, DestRect.y2);
+       }
+-
+   }
+ 
+   if (m_dst_rect != dst_rect)
+@@ -2222,7 +2239,7 @@ void CAMLCodec::SetVideoRect(const CRect
+ #ifdef TARGET_ANDROID
+   display = m_display_rect;
+ #else
+-  display = gui;
++  display = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight);;
+ #endif
+   if (gui != display)
+   {
+@@ -2294,6 +2311,8 @@ void CAMLCodec::SetVideoRect(const CRect
+   std::string s_gui = StringUtils::Format("%i,%i,%i,%i",
+     (int)gui.x1, (int)gui.y1,
+     (int)gui.Width(), (int)gui.Height());
++  CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:SrcRect(%i,%i,%i,%i)", (int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.Width(), (int)SrcRect.Height());
++  CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:DestRect(%i,%i,%i,%i)", (int)DestRect.x1, (int)DestRect.y1, (int)DestRect.Width(), (int)DestRect.Height());
+   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:display(%s)", s_display.c_str());
+   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:gui(%s)", s_gui.c_str());
+   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:m_dst_rect(%s)", s_m_dst_rect.c_str());
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
+@@ -16,6 +16,11 @@ if(AML_FOUND)
+                       DVDVideoCodecAmlogic.h)
+ endif()
+ 
++if(ENABLE_MFC)
++  list(APPEND SOURCES DVDVideoCodecMFC.cpp)
++  list(APPEND HEADERS DVDVideoCodecMFC.h)
++endif()
++
+ if(OPENMAX_FOUND)
+   list(APPEND SOURCES DVDVideoCodecOpenMax.cpp
+                       OpenMax.cpp
+--- /dev/null
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
+@@ -0,0 +1,579 @@
++#include "system.h"
++
++#ifndef THIS_IS_NOT_XBMC
++  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
++    #include "config.h"
++  #endif
++  #include "DVDDemuxers/DVDDemux.h"
++  #include "DVDStreamInfo.h"
++  #include "DVDClock.h"
++  #include "guilib/GraphicContext.h"
++  #include "DVDCodecs/DVDCodecs.h"
++  #include "DVDCodecs/DVDCodecUtils.h"
++  #include "settings/Settings.h"
++  #include "settings/DisplaySettings.h"
++  #include "settings/AdvancedSettings.h"
++  #include "utils/log.h"
++#endif
++
++#include "DVDVideoCodecMFC.h"
++
++#include <sys/mman.h>
++#include <sys/ioctl.h>
++#include <unistd.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++#include <poll.h>
++#include <sys/mman.h>
++#include <dirent.h>
++
++#ifdef CLASSNAME
++#undef CLASSNAME
++#endif
++#define CLASSNAME "CDVDVideoCodecMFC"
++
++CDVDVideoCodecMFC::CDVDVideoCodecMFC(CProcessInfo &processInfo) : CDVDVideoCodec(processInfo) {
++
++  m_iDecoderHandle = NULL;
++  m_iConverterHandle = NULL;
++  m_MFCOutput = NULL;
++  m_MFCCapture = NULL;
++  m_FIMCOutput = NULL;
++  m_FIMCCapture = NULL;
++
++  m_Buffer = NULL;
++  m_BufferNowOnScreen = NULL;
++
++  memzero(m_videoBuffer);
++
++}
++
++CDVDVideoCodecMFC::~CDVDVideoCodecMFC() {
++
++  Dispose();
++
++}
++
++bool CDVDVideoCodecMFC::OpenDevices() {
++  DIR *dir;
++
++  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
++    struct dirent *ent;
++    while ((ent = readdir (dir)) != NULL) {
++      if (strncmp(ent->d_name, "video", 5) == 0) {
++        char *p;
++        char name[64];
++        char devname[64];
++        char sysname[64];
++        char drivername[32];
++        char target[1024];
++        int ret;
++
++        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
++        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
++
++        FILE* fp = fopen(name, "r");
++        if (fgets(drivername, 32, fp) != NULL) {
++          p = strchr(drivername, '\n');
++          if (p != NULL)
++            *p = '\0';
++        } else {
++          fclose(fp);
++          continue;
++        }
++        fclose(fp);
++
++        ret = readlink(sysname, target, sizeof(target));
++        if (ret < 0)
++          continue;
++        target[ret] = '\0';
++        p = strrchr(target, '/');
++        if (p == NULL)
++          continue;
++
++        sprintf(devname, "/dev/%s", ++p);
++
++        if (!m_iDecoderHandle && strstr(drivername, "mfc") != NULL && strstr(drivername, "dec") != NULL) {
++          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
++          if (fd > -1) {
++            struct v4l2_capability cap;
++            memzero(cap);
++            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
++              if (cap.capabilities & V4L2_CAP_STREAMING &&
++                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
++                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
++                m_iDecoderHandle = new V4l2Device;
++                m_iDecoderHandle->device = fd;
++                strcpy(m_iDecoderHandle->name, drivername);
++                CLog::Log(LOGDEBUG, "%s::%s - MFC Found %s %s", CLASSNAME, __func__, drivername, devname);
++                struct v4l2_format fmt;
++                memzero(fmt);
++                fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
++                fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
++                if (ioctl(fd, VIDIOC_TRY_FMT, &fmt) == 0) {
++                  CLog::Log(LOGDEBUG, "%s::%s - Direct decoding to untiled picture on device %s is supported, no conversion needed", CLASSNAME, __func__, m_iDecoderHandle->name);
++                  delete m_iConverterHandle;
++                  m_iConverterHandle = NULL;
++                  return true;
++                }
++              }
++          }
++          if (!m_iDecoderHandle)
++            close(fd);
++        }
++        if (!m_iConverterHandle && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
++          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
++          if (fd > -1) {
++            struct v4l2_capability cap;
++            memzero(cap);
++            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
++              if (cap.capabilities & V4L2_CAP_STREAMING &&
++                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
++                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
++                m_iConverterHandle = new V4l2Device;
++                m_iConverterHandle->device = fd;
++                strcpy(m_iConverterHandle->name, drivername);
++                CLog::Log(LOGDEBUG, "%s::%s - FIMC Found %s %s", CLASSNAME, __func__, drivername, devname);
++              }
++          }
++          if (!m_iConverterHandle)
++            close(fd);
++        }
++        if (m_iDecoderHandle && m_iConverterHandle) {
++          closedir (dir);
++          return true;
++        }
++      }
++    }
++    closedir (dir);
++  }
++
++  return false;
++
++}
++
++void CDVDVideoCodecMFC::Dispose() {
++
++  CLog::Log(LOGDEBUG, "%s::%s - Starting cleanup", CLASSNAME, __func__);
++
++  delete m_BufferNowOnScreen;
++  delete m_Buffer;
++
++  m_Buffer = NULL;
++  m_BufferNowOnScreen = NULL;
++
++  delete m_FIMCCapture;
++  delete m_FIMCOutput;
++  delete m_MFCCapture;
++  delete m_MFCOutput;
++
++  m_MFCOutput = NULL;
++  m_MFCCapture = NULL;
++  m_FIMCOutput = NULL;
++  m_FIMCCapture = NULL;
++
++  if (m_iConverterHandle) {
++    close(m_iConverterHandle->device);
++    delete m_iConverterHandle;
++    m_iConverterHandle = NULL;
++  }
++
++  if (m_iDecoderHandle) {
++    close(m_iDecoderHandle->device);
++    delete m_iDecoderHandle;
++    m_iDecoderHandle = NULL;
++  }
++
++}
++
++bool CDVDVideoCodecMFC::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
++  struct v4l2_format fmt;
++  struct v4l2_crop crop;
++  struct V4l2SinkBuffer sinkBuffer;
++  V4l2Device *finalSink = NULL;
++  int finalFormat = -1;
++  int resultVideoWidth;
++  int resultVideoHeight;
++  int resultLineSize;
++  unsigned int extraSize = 0;
++  uint8_t *extraData = NULL;
++
++  m_hints = hints;
++  if (m_hints.software)
++    return false;
++
++  Dispose();
++
++  m_Buffer = new V4l2SinkBuffer();
++  m_BufferNowOnScreen = new V4l2SinkBuffer();
++  m_BufferNowOnScreen->iIndex = -1;
++  m_bVideoConvert = false;
++  m_bDropPictures = false;
++  memzero(m_videoBuffer);
++
++  if (!OpenDevices()) {
++    CLog::Log(LOGERROR, "%s::%s - No Exynos MFC Decoder/Converter found", CLASSNAME, __func__);
++    return false;
++  }
++
++  m_bVideoConvert = m_converter.Open(m_hints.codec, (uint8_t *)m_hints.extradata, m_hints.extrasize, true);
++
++  if(m_bVideoConvert) {
++    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
++      extraSize = m_converter.GetExtraSize();
++      extraData = m_converter.GetExtraData();
++    }
++  } else {
++    if(m_hints.extrasize > 0 && m_hints.extradata != NULL) {
++      extraSize = m_hints.extrasize;
++      extraData = (uint8_t*)m_hints.extradata;
++    }
++  }
++
++  // Test what formats we can get finally
++  // If converter is present, it is our final sink
++  finalSink = m_iConverterHandle ? m_iConverterHandle : m_iDecoderHandle;
++  // Test NV12 2 Planes Y/CbCr
++  memzero(fmt);
++  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
++  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
++  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
++    finalFormat = V4L2_PIX_FMT_NV12M;
++/*
++  memzero(fmt);
++  // Test YUV420 3 Planes Y/Cb/Cr
++  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
++  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
++  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
++    finalFormat = V4L2_PIX_FMT_YUV420M;
++*/
++
++  // No suitable output formats available
++  if (finalFormat < 0) {
++    CLog::Log(LOGERROR, "%s::%s - No suitable format on %s to convert to found", CLASSNAME, __func__, finalSink->name);
++    return false;
++  }
++
++  // Create MFC Output sink (the one where encoded frames are feed)
++  m_MFCOutput = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
++  memzero(fmt);
++  switch(m_hints.codec)
++  {
++    case AV_CODEC_ID_VC1:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
++      m_name = "mfc-vc1";
++      break;
++    case AV_CODEC_ID_MPEG1VIDEO:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
++      m_name = "mfc-mpeg1";
++      break;
++    case AV_CODEC_ID_MPEG2VIDEO:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
++      m_name = "mfc-mpeg2";
++      break;
++    case AV_CODEC_ID_MPEG4:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
++      m_name = "mfc-mpeg4";
++      break;
++    case AV_CODEC_ID_H263:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
++      m_name = "mfc-h263";
++      break;
++    case AV_CODEC_ID_H264:
++      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
++      m_name = "mfc-h264";
++      break;
++    default:
++      return false;
++      break;
++  }
++  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = BUFFER_SIZE;
++  // Set encoded format
++  if (!m_MFCOutput->SetFormat(&fmt))
++    return false;
++  // Init with number of input buffers predefined
++  if (!m_MFCOutput->Init(INPUT_BUFFERS))
++    return false;
++
++  // Get empty buffer to fill
++  if (!m_MFCOutput->GetBuffer(&sinkBuffer))
++    return false;
++  // Fill it with the header
++  sinkBuffer.iBytesUsed[0] = extraSize;
++  memcpy(sinkBuffer.cPlane[0], extraData, extraSize);
++  // Enqueue buffer
++  if (!m_MFCOutput->PushBuffer(&sinkBuffer))
++    return false;
++
++  // Create MFC Capture sink (the one from which decoded frames are read)
++  m_MFCCapture = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
++  memzero(fmt);
++  // If there is no converter set output format on the MFC Capture sink
++  if (!m_iConverterHandle) {
++    fmt.fmt.pix_mp.pixelformat = finalFormat;
++    if (!m_MFCCapture->SetFormat(&fmt))
++        return false;
++  }
++
++  // Turn on MFC Output with header in it to initialize MFC with all we just setup
++  m_MFCOutput->StreamOn(VIDIOC_STREAMON);
++
++  // Initialize MFC Capture
++  if (!m_MFCCapture->Init(0))
++    return false;
++  // Queue all buffers (empty) to MFC Capture
++  m_MFCCapture->QueueAll();
++
++  // Read the format of MFC Capture
++  if (!m_MFCCapture->GetFormat(&fmt))
++    return false;
++  // Size of resulting picture coming out of MFC
++  // It will be aligned by 16 since the picture is tiled
++  // We need this to know where to split buffer line by line
++  resultLineSize = fmt.fmt.pix_mp.width;
++  // Get MFC capture crop settings
++  if (!m_MFCCapture->GetCrop(&crop))
++    return false;
++  // This is the picture boundaries we are interested in, everything outside is alignement because of tiled MFC output
++  resultVideoWidth = crop.c.width;
++  resultVideoHeight = crop.c.height;
++
++  // Turn on MFC Capture
++  m_MFCCapture->StreamOn(VIDIOC_STREAMON);
++
++  // If converter is needed (we need to untile the picture from format MFC produces it)
++  if (m_iConverterHandle) {
++    // Create FIMC Output sink
++    m_FIMCOutput = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
++    // Set the FIMC Output format to the one read from MFC
++    if (!m_FIMCOutput->SetFormat(&fmt))
++      return false;
++    // Set the FIMC Output crop to the one read from MFC
++    if (!m_FIMCOutput->SetCrop(&crop))
++      return false;
++    // Init FIMC Output and link it to buffers of MFC Capture
++    if (!m_FIMCOutput->Init(m_MFCCapture))
++      return false;
++    // Get FIMC Output crop settings
++    if (!m_FIMCOutput->GetCrop(&crop))
++      return false;
++
++    // Create FIMC Capture sink
++    m_FIMCCapture = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
++    // Set the final picture format and the same picture dimension settings to FIMC Capture
++    // as picture crop coming from MFC (original picture dimensions)
++    memzero(fmt);
++    fmt.fmt.pix_mp.pixelformat = finalFormat;
++    fmt.fmt.pix_mp.width = crop.c.width;
++    fmt.fmt.pix_mp.height = crop.c.height;
++    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
++    if (!m_FIMCCapture->SetFormat(&fmt))
++      return false;
++    // Init FIMC capture with number of buffers predefined
++    if (!m_FIMCCapture->Init(OUTPUT_BUFFERS))
++      return false;
++
++    // Queue all buffers (empty) to FIMC Capture
++    m_FIMCCapture->QueueAll();
++
++    // Read FIMC capture format settings
++    if (!m_FIMCCapture->GetFormat(&fmt))
++      return false;
++    resultLineSize = fmt.fmt.pix_mp.width;
++    // Read FIMC capture crop settings
++    if (!m_FIMCCapture->GetCrop(&crop))
++      return false;
++    resultVideoWidth = crop.c.width;
++    resultVideoHeight = crop.c.height;
++
++    // Turn on FIMC Output and Capture enabling the converter
++    m_FIMCOutput->StreamOn(VIDIOC_STREAMON);
++    m_FIMCCapture->StreamOn(VIDIOC_STREAMON);
++  }
++
++  m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
++
++  m_videoBuffer.color_range     = 0;
++  m_videoBuffer.color_matrix    = 4;
++
++  m_videoBuffer.iDisplayWidth   = resultVideoWidth;
++  m_videoBuffer.iDisplayHeight  = resultVideoHeight;
++  m_videoBuffer.iWidth          = resultVideoWidth;
++  m_videoBuffer.iHeight         = resultVideoHeight;
++
++  m_videoBuffer.data[0]         = NULL;
++  m_videoBuffer.data[1]         = NULL;
++  m_videoBuffer.data[2]         = NULL;
++  m_videoBuffer.data[3]         = NULL;
++
++  m_videoBuffer.pts             = DVD_NOPTS_VALUE;
++  m_videoBuffer.dts             = DVD_NOPTS_VALUE;
++
++  m_videoBuffer.iLineSize[0]    = resultLineSize;
++  m_videoBuffer.iLineSize[3]    = 0;
++
++  if (finalFormat == V4L2_PIX_FMT_NV12M) {
++    m_videoBuffer.format          = RENDER_FMT_NV12;
++    m_videoBuffer.iLineSize[1]    = resultLineSize;
++    m_videoBuffer.iLineSize[2]    = 0;
++  } else if (finalFormat == V4L2_PIX_FMT_YUV420M) {
++    /*
++     Due to BUG in MFC v8 (-XU3) firmware the Y plane of the picture has the right line size,
++     but the U and V planes line sizes are actually halves of Y plane line size padded to 32
++     This is pure workaround for -XU3 MFCv8 firmware "MFC v8.0, F/W: 14yy, 01mm, 13dd (D)
++     Seems that only MPEG2 is affected
++    */
++    // Only on -XU3 there are no converter, but the output format can be YUV420
++    // So this is the easiest way to distinguish -XU3 from -U3 with FIMC
++    if (!m_iConverterHandle && m_hints.codec == AV_CODEC_ID_MPEG2VIDEO)
++      resultLineSize = resultLineSize + (32 - resultLineSize%32);
++
++    m_videoBuffer.format          = RENDER_FMT_YUV420P;
++    m_videoBuffer.iLineSize[1]    = resultLineSize >> 1;
++    m_videoBuffer.iLineSize[2]    = resultLineSize >> 1;
++  }
++
++  m_BufferNowOnScreen->iIndex = -1;
++  m_bCodecHealthy = true;
++
++  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull (%dx%d, linesize %d, format 0x%x), start streaming", CLASSNAME, __func__, resultVideoWidth, resultVideoHeight, resultLineSize, finalFormat);
++
++  return true;
++
++}
++
++void CDVDVideoCodecMFC::SetDropState(bool bDrop) {
++
++  debug_log(LOGDEBUG, "%s::%s - setting state to %d", CLASSNAME, __func__, bDrop);
++  m_bDropPictures = bDrop;
++  if (m_bDropPictures)
++    m_videoBuffer.iFlags |= DVP_FLAG_DROPPED;
++  else
++    m_videoBuffer.iFlags &= ~DVP_FLAG_DROPPED;
++
++}
++
++int CDVDVideoCodecMFC::Decode(BYTE* pData, int iSize, double dts, double pts) {
++
++  if (m_hints.ptsinvalid)
++    pts = DVD_NOPTS_VALUE;
++
++  //unsigned int dtime = XbmcThreads::SystemClockMillis();
++  debug_log(LOGDEBUG, "%s::%s - input frame iSize %d, pts %lf, dts %lf", CLASSNAME, __func__, iSize, pts, dts);
++
++  if(pData) {
++    int demuxer_bytes = iSize;
++    uint8_t *demuxer_content = pData;
++
++    if(m_bVideoConvert) {
++      m_converter.Convert(demuxer_content, demuxer_bytes);
++      demuxer_bytes = m_converter.GetConvertSize();
++      demuxer_content = m_converter.GetConvertBuffer();
++    }
++
++    m_MFCOutput->Poll(1000/3); // Wait up to 0.3 of a second for buffer availability
++    if (m_MFCOutput->GetBuffer(m_Buffer)) {
++      debug_log(LOGDEBUG, "%s::%s - Got empty buffer %d from MFC Output, filling", CLASSNAME, __func__, m_Buffer->iIndex);
++      m_Buffer->iBytesUsed[0] = demuxer_bytes;
++      memcpy((uint8_t *)m_Buffer->cPlane[0], demuxer_content, m_Buffer->iBytesUsed[0]);
++      long* longPts = (long*)&pts;
++      m_Buffer->timeStamp.tv_sec = longPts[0];
++      m_Buffer->timeStamp.tv_usec = longPts[1];
++
++      if (!m_MFCOutput->PushBuffer(m_Buffer)) {
++        m_bCodecHealthy = false;
++        return VC_FLUSHED; // MFC unrecoverable error, reset needed
++      }
++    } else {
++      if (errno == EAGAIN)
++        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation. Current encoded frame will be lost", CLASSNAME, __func__);
++      else {
++        m_bCodecHealthy = false;
++        return VC_FLUSHED; // MFC unrecoverable error, reset needed
++      }
++    }
++  }
++
++  // Get a buffer from MFC Capture
++  if (!m_MFCCapture->DequeueBuffer(m_Buffer)) {
++    if (errno == EAGAIN)
++      return VC_BUFFER;
++    else
++      return VC_ERROR;
++  }
++
++  if (m_iConverterHandle) {
++
++    if (m_bDropPictures) {
++      CLog::Log(LOGWARNING, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, m_Buffer->iIndex);
++      // Queue it back to MFC CAPTURE since we are in an underrun condition
++      m_MFCCapture->PushBuffer(m_Buffer);
++      return (VC_DROPPED | VC_BUFFER);
++    }
++
++    // Push the buffer got from MFC Capture to FIMC Output (decoded from decoder to converter)
++    if (!m_FIMCOutput->PushBuffer(m_Buffer)) {
++      m_bCodecHealthy = false;
++      return VC_FLUSHED; // FIMC unrecoverable error, reset needed
++    }
++    // Get a buffer from FIMC Capture
++    if (!m_FIMCCapture->DequeueBuffer(m_Buffer)) {
++      if (errno == EAGAIN)
++        return VC_BUFFER;
++      else
++        return VC_ERROR;
++    }
++  }
++
++  // We got a new buffer to show, so we can enqeue back the buffer wich was on screen
++  if (m_BufferNowOnScreen->iIndex > -1) {
++    if (m_iConverterHandle)
++      m_FIMCCapture->PushBuffer(m_BufferNowOnScreen);
++    else
++      m_MFCCapture->PushBuffer(m_BufferNowOnScreen);
++    m_BufferNowOnScreen->iIndex = -1;
++  }
++
++  long longPts[2] = { m_Buffer->timeStamp.tv_sec, m_Buffer->timeStamp.tv_usec };
++  m_videoBuffer.data[0]         = (BYTE*)m_Buffer->cPlane[0];
++  m_videoBuffer.data[1]         = (BYTE*)m_Buffer->cPlane[1];
++  m_videoBuffer.data[2]         = (BYTE*)m_Buffer->cPlane[2];
++  m_videoBuffer.pts             = *((double*)&longPts[0]);
++
++  std::swap(m_Buffer, m_BufferNowOnScreen);
++
++  if (m_iConverterHandle && m_FIMCOutput->DequeueBuffer(m_Buffer))
++    m_MFCCapture->PushBuffer(m_Buffer);
++
++  //debug_log("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
++  // Picture is finally ready to be processed further and more info can be enqueued
++  return (VC_PICTURE | VC_BUFFER);
++
++}
++
++void CDVDVideoCodecMFC::Reset() {
++
++  if (m_bCodecHealthy) {
++    CLog::Log(LOGDEBUG, "%s::%s - Codec Reset requested, but codec is healthy, doing soft-flush", CLASSNAME, __func__);
++    m_MFCOutput->SoftRestart();
++    m_MFCCapture->SoftRestart();
++    if (!m_iConverterHandle)
++      m_BufferNowOnScreen->iIndex = -1;
++  } else {
++    CLog::Log(LOGERROR, "%s::%s - Codec Reset. Reinitializing", CLASSNAME, __func__);
++    CDVDCodecOptions options;
++    // We need full MFC/FIMC reset with device reopening.
++    // I wasn't able to reinitialize both IP's without fully closing and reopening them.
++    // There are always some clips that cause MFC or FIMC go into state which cannot be reset without close/open
++    Open(m_hints, options);
++  }
++
++}
++
++bool CDVDVideoCodecMFC::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
++
++  *pDvdVideoPicture = m_videoBuffer;
++  debug_log(LOGDEBUG, "%s::%s - output frame pts %lf", CLASSNAME, __func__, m_videoBuffer.pts);
++  return true;
++
++}
+--- /dev/null
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h
+@@ -0,0 +1,63 @@
++#pragma once
++
++#ifndef THIS_IS_NOT_XBMC
++  #include "DVDVideoCodec.h"
++  #include "DVDStreamInfo.h"
++  #include "utils/BitstreamConverter.h"
++  #include "xbmc/linux/LinuxV4l2Sink.h"
++#else
++  #include "xbmcstubs.h"
++  #include "LinuxV4l2Sink.h"
++#endif
++
++#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
++  #define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
++#endif
++
++#define BUFFER_SIZE        1048576 // Compressed frame size. 1080p mpeg4 10Mb/s can be >256k in size, so this is to make sure frame fits into the buffer
++                                   // For very unknown reason lesser than 1Mb buffer causes MFC to corrupt its own setup, setting inapropriate values
++#define INPUT_BUFFERS      3       // 3 input buffers. 2 is enough almost for everything, but on some heavy videos 3 makes a difference
++#define OUTPUT_BUFFERS     3       // Triple buffering for smooth output
++
++#define memzero(x) memset(&(x), 0, sizeof (x))
++
++class CDVDVideoCodecMFC : public CDVDVideoCodec
++{
++public:
++  CDVDVideoCodecMFC(CProcessInfo &processInfo);
++  virtual ~CDVDVideoCodecMFC();
++  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
++  virtual void Dispose();
++  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
++  virtual void Reset();
++  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
++  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
++  virtual void SetDropState(bool bDrop);
++  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
++
++protected:
++  std::string m_name;
++
++  bool m_bCodecHealthy;
++
++  V4l2Device *m_iDecoderHandle;
++  V4l2Device *m_iConverterHandle;
++
++  CLinuxV4l2Sink *m_MFCCapture;
++  CLinuxV4l2Sink *m_MFCOutput;
++  CLinuxV4l2Sink *m_FIMCCapture;
++  CLinuxV4l2Sink *m_FIMCOutput;
++
++  V4l2SinkBuffer *m_Buffer;
++  V4l2SinkBuffer *m_BufferNowOnScreen;
++
++  bool m_bVideoConvert;
++  CDVDStreamInfo m_hints;
++
++  CBitstreamConverter m_converter;
++  bool m_bDropPictures;
++
++  DVDVideoPicture   m_videoBuffer;
++
++  bool OpenDevices();
++};
+--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
++++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
+@@ -34,8 +34,11 @@ ifeq (@USE_MMAL@,1)
+ SRCS += MMALCodec.cpp MMALFFmpeg.cpp
+ endif
+ 
++ifeq (@USE_MFC@,1)
++SRCS += DVDVideoCodecMFC.cpp
++endif
++
+ LIB=Video.a
+ 
+ include @abs_top_srcdir@/Makefile.include
+ -include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
+-
+--- a/xbmc/linux/CMakeLists.txt
++++ b/xbmc/linux/CMakeLists.txt
+@@ -5,6 +5,7 @@ set(SOURCES ConvUtils.cpp
+             FDEventMonitor.cpp
+             LinuxResourceCounter.cpp
+             LinuxTimezone.cpp
++            LinuxV4l2Sink.cpp
+             PosixMountProvider.cpp
+             RBP.cpp
+             XFileUtils.cpp
+@@ -20,6 +21,7 @@ set(HEADERS ConvUtils.h
+             FDEventMonitor.h
+             LinuxResourceCounter.h
+             LinuxTimezone.h
++            LinuxV4l2Sink.h
+             PlatformDefs.h
+             PlatformInclude.h
+             PosixMountProvider.h
+--- /dev/null
++++ b/xbmc/linux/LinuxV4l2Sink.cpp
+@@ -0,0 +1,311 @@
++#include "system.h"
++
++#ifndef THIS_IS_NOT_XBMC
++  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
++    #include "config.h"
++  #endif
++
++  #include "utils/log.h"
++#endif
++
++#include <sys/mman.h>
++#include <sys/ioctl.h>
++#include <unistd.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++#include <poll.h>
++#include <sys/mman.h>
++#include <linux/media.h>
++
++#include "LinuxV4l2Sink.h"
++
++#ifdef CLASSNAME
++#undef CLASSNAME
++#endif
++#define CLASSNAME "CLinuxV4l2Sink"
++
++CLinuxV4l2Sink::CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type) {
++  CLog::Log(LOGDEBUG, "%s::%s - Creating Sink, Device %s, Type %d", CLASSNAME, __func__, device->name, type);
++  m_Device = device;
++  m_Type = type;
++  m_NumBuffers = 0;
++  m_NumPlanes = 0;
++  m_Addresses = NULL;
++  m_Buffers = NULL;
++  m_Planes = NULL;
++}
++
++CLinuxV4l2Sink::~CLinuxV4l2Sink() {
++  CLog::Log(LOGDEBUG, "%s::%s - Destroying Sink, Device %s, Type %d", CLASSNAME, __func__, m_Device->name, m_Type);
++
++  StreamOn(VIDIOC_STREAMOFF);
++
++  if (m_Memory == V4L2_MEMORY_MMAP)
++    for (int i = 0; i < m_NumBuffers*m_NumPlanes; i++)
++      if(m_Addresses[i] != (unsigned long)MAP_FAILED)
++        if (munmap((void *)m_Addresses[i], m_Planes[i].length) == 0)
++          CLog::Log(LOGDEBUG, "%s::%s - Device %s, Munmapped Plane %d size %u at 0x%lx", CLASSNAME, __func__, m_Device->name, i, m_Planes[i].length, m_Addresses[i]);
++  if (m_Planes)
++    delete[] m_Planes;
++  if (m_Buffers)
++    delete[] m_Buffers;
++  if (m_Addresses)
++    delete[] m_Addresses;
++}
++
++// Init for MMAP buffers
++bool CLinuxV4l2Sink::Init(int buffersCount = 0) {
++  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init MMAP %d buffers", CLASSNAME, __func__, m_Device->name, m_Type, buffersCount);
++  m_Memory = V4L2_MEMORY_MMAP;
++
++  struct v4l2_format format;
++  if (!GetFormat(&format))
++    return false;
++
++  if (buffersCount == 0 && m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
++    struct v4l2_control ctrl;
++    ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
++    if (ioctl(m_Device->device, VIDIOC_G_CTRL, &ctrl)) {
++      CLog::Log(LOGERROR, "%s::%s - Device %s, Type %d, Error getting number of buffers for capture (V4L2_CID_MIN_BUFFERS_FOR_CAPTURE VIDIOC_G_CTRL)", CLASSNAME, __func__, m_Device->name, m_Type);
++      return false;
++    }
++    buffersCount = (int)(ctrl.value * 1.5); //Most of the time we need 50% more extra capture buffers than device reported would be enough
++  }
++
++  m_NumBuffers = RequestBuffers(buffersCount);
++  if (m_NumBuffers < 1)
++    return false;
++  m_Buffers = new v4l2_buffer[m_NumBuffers];
++  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
++  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
++  if (!QueryBuffers())
++    return false;
++  if (!MmapBuffers())
++    return false;
++  return true;
++}
++// Init for USERPTR buffers
++bool CLinuxV4l2Sink::Init(CLinuxV4l2Sink *sink) {
++  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init UserPTR", CLASSNAME, __func__, m_Device->name, m_Type);
++  m_Memory = V4L2_MEMORY_USERPTR;
++
++  struct v4l2_format format;
++  if (!GetFormat(&format))
++    return false;
++
++  m_NumBuffers = sink->m_NumBuffers;
++  m_NumBuffers = RequestBuffers(m_NumBuffers);
++  if (m_NumBuffers < 1)
++    return false;
++  m_Buffers = new v4l2_buffer[m_NumBuffers];
++  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
++  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
++  if (!QueryBuffers())
++    return false;
++  for (int i = 0; i < m_NumPlanes * m_NumBuffers; i++) {
++    m_Addresses[i] = sink->m_Addresses[i];
++    m_Planes[i].m.userptr = m_Addresses[i];
++  }
++  return true;
++}
++
++void CLinuxV4l2Sink::SoftRestart() {
++  StreamOn(VIDIOC_STREAMOFF);
++
++  while (!iFreeBuffers.empty())
++    iFreeBuffers.pop();
++  for (int i = 0; i < m_NumBuffers; i++)
++    iFreeBuffers.push(m_Buffers[i].index);
++
++  if (m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
++    QueueAll();
++
++  StreamOn(VIDIOC_STREAMON);
++}
++
++bool CLinuxV4l2Sink::GetFormat(v4l2_format *format) {
++  memset(format, 0, sizeof(struct v4l2_format));
++  format->type = m_Type;
++  if (ioctl(m_Device->device, VIDIOC_G_FMT, format)) {
++    CLog::Log(LOGERROR, "%s::%s - Error getting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
++    return false;
++  }
++  m_NumPlanes = format->fmt.pix_mp.num_planes;
++  CLog::Log(LOGDEBUG, "%s::%s - G_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
++  return true;
++}
++
++bool CLinuxV4l2Sink::SetFormat(v4l2_format *format) {
++  format->type = m_Type;
++  CLog::Log(LOGDEBUG, "%s::%s - S_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
++  if (ioctl(m_Device->device, VIDIOC_S_FMT, format)) {
++    CLog::Log(LOGERROR, "%s::%s - Error setting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
++    return false;
++  }
++  return true;
++}
++
++bool CLinuxV4l2Sink::GetCrop(v4l2_crop *crop) {
++  memset(crop, 0, sizeof(struct v4l2_crop));
++  crop->type = m_Type;
++  if (ioctl(m_Device->device, VIDIOC_G_CROP, crop)) {
++    CLog::Log(LOGERROR, "%s::%s - Error getting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
++    return false;
++  }
++  CLog::Log(LOGDEBUG, "%s::%s - G_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
++  return true;
++}
++
++bool CLinuxV4l2Sink::SetCrop(v4l2_crop *crop) {
++  crop->type = m_Type;
++  CLog::Log(LOGDEBUG, "%s::%s - S_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
++  if (ioctl(m_Device->device, VIDIOC_S_CROP, crop)) {
++    CLog::Log(LOGERROR, "%s::%s - Error setting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
++    return false;
++  }
++  return true;
++}
++
++int CLinuxV4l2Sink::RequestBuffers(int buffersCount) {
++  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, RequestBuffers %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, buffersCount);
++  struct v4l2_requestbuffers reqbuf;
++  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
++  reqbuf.type     = m_Type;
++  reqbuf.memory   = m_Memory;
++  reqbuf.count    = buffersCount;
++
++  if (ioctl(m_Device->device, VIDIOC_REQBUFS, &reqbuf)) {
++    CLog::Log(LOGERROR, "%s::%s - Error requesting buffers. Device %s, Type %d, Memory %d. (VIDIOC_REQBUFS)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
++    return V4L2_ERROR;
++  }
++
++  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, Buffers allowed %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, reqbuf.count);
++  return reqbuf.count;
++}
++
++bool CLinuxV4l2Sink::QueryBuffers() {
++  memset(m_Buffers, 0, m_NumBuffers * sizeof(struct v4l2_buffer));
++  memset(m_Planes, 0, m_NumBuffers * m_NumPlanes * sizeof(struct v4l2_plane));
++
++  for(int i = 0; i < m_NumBuffers; i++) {
++    m_Buffers[i].type      = m_Type;
++    m_Buffers[i].memory    = m_Memory;
++    m_Buffers[i].index     = i;
++    m_Buffers[i].m.planes  = &m_Planes[i*m_NumPlanes];
++    m_Buffers[i].length    = m_NumPlanes;
++
++    if (ioctl(m_Device->device, VIDIOC_QUERYBUF, &m_Buffers[i])) {
++      CLog::Log(LOGERROR, "%s::%s - Error querying buffers. Device %s, Type %d, Memory %d. (VIDIOC_QUERYBUF)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
++      return false;
++    }
++
++    iFreeBuffers.push(m_Buffers[i].index);
++  }
++  return true;
++}
++
++bool CLinuxV4l2Sink::MmapBuffers() {
++  for(int i = 0; i < m_NumBuffers * m_NumPlanes; i++) {
++    if(m_Planes[i].length) {
++      m_Addresses[i] = (unsigned long)mmap(NULL, m_Planes[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, m_Device->device, m_Planes[i].m.mem_offset);
++      if (m_Addresses[i] == (unsigned long)MAP_FAILED)
++        return false;
++      CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, MMapped Plane %d at 0x%x to address 0x%lx", CLASSNAME, __func__, m_Device->name, m_Type, i, m_Planes[i].m.mem_offset, m_Addresses[i]);
++    }
++  }
++  return true;
++}
++
++bool CLinuxV4l2Sink::StreamOn(int state) {
++  if(ioctl(m_Device->device, state, &m_Type)) {
++    CLog::Log(LOGERROR, "%s::%s - Error setting device state to %d, Device %s, Type %d.", CLASSNAME, __func__, state, m_Device->name, m_Type);
++    return false;
++  }
++  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, %d", CLASSNAME, __func__, m_Device->name, m_Type, state);
++  return true;
++}
++
++bool CLinuxV4l2Sink::QueueBuffer(v4l2_buffer *buffer) {
++  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d <- %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
++  if (ioctl(m_Device->device, VIDIOC_QBUF, buffer)) {
++    CLog::Log(LOGERROR, "%s::%s - Error queueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
++    return false;
++  }
++  return true;
++}
++bool CLinuxV4l2Sink::DequeueBuffer(v4l2_buffer *buffer) {
++  if (ioctl(m_Device->device, VIDIOC_DQBUF, buffer)) {
++    if (errno != EAGAIN) CLog::Log(LOGERROR, "%s::%s - Error dequeueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
++    return false;
++  }
++  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d -> %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
++  return true;
++}
++
++bool CLinuxV4l2Sink::DequeueBuffer(V4l2SinkBuffer *buffer) {
++  struct v4l2_buffer buf;
++  struct v4l2_plane  planes[m_NumPlanes];
++  memset(&planes, 0, sizeof(struct v4l2_plane) * m_NumPlanes);
++  memset(&buf, 0, sizeof(struct v4l2_buffer));
++  buf.type     = m_Type;
++  buf.memory   = m_Memory;
++  buf.m.planes = planes;
++  buf.length   = m_NumPlanes;
++  if (!DequeueBuffer(&buf))
++    return false;
++
++  buffer->iIndex = buf.index;
++  buffer->timeStamp = buf.timestamp;
++  for (int i = 0; i < m_NumPlanes; i++)
++    buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
++  return true;
++}
++
++bool CLinuxV4l2Sink::GetBuffer(V4l2SinkBuffer *buffer) {
++  if (iFreeBuffers.empty()) {
++    if (!DequeueBuffer(buffer))
++      return false;
++  } else {
++    buffer->iIndex = iFreeBuffers.front();
++    buffer->timeStamp = m_Buffers[buffer->iIndex].timestamp;
++    iFreeBuffers.pop();
++    for (int i = 0; i < m_NumPlanes; i++)
++      buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
++  }
++  return true;
++}
++
++bool CLinuxV4l2Sink::PushBuffer(V4l2SinkBuffer *buffer) {
++  if (m_Memory == V4L2_MEMORY_USERPTR)
++    for (int i = 0; i < m_NumPlanes; i++)
++      m_Buffers[buffer->iIndex].m.planes[i].m.userptr = (long unsigned int)buffer->cPlane[i];
++
++  if (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
++    m_Buffers[buffer->iIndex].timestamp = buffer->timeStamp;
++    m_Buffers[buffer->iIndex].flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
++    for (int i = 0; i < m_NumPlanes; i++)
++      m_Buffers[buffer->iIndex].m.planes[i].bytesused = buffer->iBytesUsed[i];
++  }
++
++  if (!QueueBuffer(&m_Buffers[buffer->iIndex]))
++    return false;
++  return true;
++}
++
++int CLinuxV4l2Sink::Poll(int timeout) {
++  struct pollfd p;
++  p.fd = m_Device->device;
++  p.events = POLLERR;
++  (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ? p.events |= POLLOUT : p.events |= POLLIN;
++
++  return poll(&p, 1, timeout);
++}
++
++bool CLinuxV4l2Sink::QueueAll() {
++  while (!iFreeBuffers.empty()) {
++    if (!QueueBuffer(&m_Buffers[iFreeBuffers.front()]))
++      return false;
++    iFreeBuffers.pop();
++  }
++  return true;
++}
+--- /dev/null
++++ b/xbmc/linux/LinuxV4l2Sink.h
+@@ -0,0 +1,71 @@
++#pragma once
++
++#include <queue>
++#include <string>
++#include <poll.h>
++#include <linux/videodev2.h>
++
++#ifndef V4L2_BUF_FLAG_TIMESTAMP_COPY
++  #define V4L2_BUF_FLAG_TIMESTAMP_COPY 0x4000
++#endif
++
++#define V4L2_ERROR -1
++#define V4L2_BUSY  1
++#define V4L2_READY 2
++#define V4L2_OK    3
++
++#ifdef _DEBUG
++  #define debug_log(...) CLog::Log(__VA_ARGS__)
++#else
++  #define debug_log(...)
++#endif
++
++typedef struct V4l2Device
++{
++  int     device;
++  char    name[32];
++} V4l2Device;
++
++typedef struct V4l2SinkBuffer
++{
++  int     iIndex;
++  int     iBytesUsed[4];
++  void    *cPlane[4];
++  struct  timeval timeStamp;
++} V4l2SinkBuffer;
++
++class CLinuxV4l2Sink
++{
++public:
++  CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type);
++  ~CLinuxV4l2Sink();
++
++  bool Init(int buffersCount);
++  bool Init(CLinuxV4l2Sink *sink);
++  void SoftRestart();
++  bool GetFormat(v4l2_format *format);
++  bool SetFormat(v4l2_format *format);
++  bool GetCrop(v4l2_crop *crop);
++  bool SetCrop(v4l2_crop *crop);
++  bool GetBuffer(V4l2SinkBuffer* buffer);
++  bool DequeueBuffer(V4l2SinkBuffer* buffer);
++  bool PushBuffer(V4l2SinkBuffer* buffer);
++  bool StreamOn(int state);
++  bool QueueAll();
++  int Poll(int timeout);
++private:
++  V4l2Device *m_Device;
++  int m_NumPlanes;
++  int m_NumBuffers;
++  std::queue<int> iFreeBuffers;
++  enum v4l2_memory m_Memory;
++  enum v4l2_buf_type m_Type;
++  v4l2_buffer *m_Buffers;
++  v4l2_plane *m_Planes;
++  unsigned long *m_Addresses;
++  int RequestBuffers(int buffersCount);
++  bool QueryBuffers();
++  bool MmapBuffers();
++  bool QueueBuffer(v4l2_buffer *buffer);
++  bool DequeueBuffer(v4l2_buffer *buffer);
++};
+--- a/xbmc/linux/Makefile.in
++++ b/xbmc/linux/Makefile.in
+@@ -12,6 +12,7 @@ SRCS += XFileUtils.cpp
+ SRCS += XHandle.cpp
+ SRCS += XMemUtils.cpp
+ SRCS += XTimeUtils.cpp
++SRCS += LinuxV4l2Sink.cpp
+ 
+ SRCS += RBP.cpp
+ 
+--- a/xbmc/system_gl.h
++++ b/xbmc/system_gl.h
+@@ -42,6 +42,10 @@
+     #include <OpenGL/glext.h>
+   #endif
+ #elif HAS_GLES == 2
++  // always define GL_GLEXT_PROTOTYPES before include gl headers
++  #if !defined(GL_GLEXT_PROTOTYPES)
++    #define GL_GLEXT_PROTOTYPES
++  #endif
+   #if defined(TARGET_DARWIN)
+     #include <OpenGLES/ES2/gl.h>
+     #include <OpenGLES/ES2/glext.h>
+--- a/xbmc/utils/AMLUtils.cpp
++++ b/xbmc/utils/AMLUtils.cpp
+@@ -78,7 +78,7 @@ bool aml_wired_present()
+ }
+ 
+ bool aml_permissions()
+-{  
++{
+   if (!aml_present())
+     return false;
+ 
+@@ -237,7 +237,8 @@ AML_SUPPORT_H264_4K2K aml_support_h264_4
+ 
+ void aml_set_audio_passthrough(bool passthrough)
+ {
+-  SysfsUtils::SetInt("/sys/class/audiodsp/digital_raw", passthrough ? 2:0);
++  CLog::Log(LOGDEBUG, "AML: Setting passthrough %d", passthrough);
++  SysfsUtils::SetString("/sys/class/audiodsp/digital_raw", passthrough ? "2":"0");
+ }
+ 
+ void aml_probe_hdmi_audio()
+@@ -255,7 +256,7 @@ void aml_probe_hdmi_audio()
+   {
+     char valstr[1024] = {0};
+ 
+-    read(fd, valstr, sizeof(valstr) - 1);
++    int tmp = read(fd, valstr, sizeof(valstr) - 1);
+     valstr[strlen(valstr)] = '\0';
+     close(fd);
+ 
+@@ -390,6 +391,60 @@ bool aml_mode_to_resolution(const char *
+     res->fRefreshRate = 50;
+     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+   }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p23hz")) // fake
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 23.98;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p24hz")) // fake
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 24;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p25hz")) // fake
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 25;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p29hz")) // fake
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 29.97;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p30hz")) // fake
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 30;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "720p59hz")) // real
++  {
++    res->iWidth = 1280;
++    res->iHeight= 720;
++    res->iScreenWidth = 1280;
++    res->iScreenHeight= 720;
++    res->fRefreshRate = 59.94;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
+   else if (StringUtils::EqualsNoCase(fromMode, "720p") || StringUtils::EqualsNoCase(fromMode, "720p60hz"))
+   {
+     res->iWidth = 1280;
+@@ -435,6 +490,24 @@ bool aml_mode_to_resolution(const char *
+     res->fRefreshRate = 24;
+     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+   }
++  else if (StringUtils::EqualsNoCase(fromMode, "1080p25hz"))
++  {
++    res->iWidth = 1920;
++    res->iHeight= 1080;
++    res->iScreenWidth = 1920;
++    res->iScreenHeight= 1080;
++    res->fRefreshRate = 25;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "1080p29hz")) // fake
++  {
++    res->iWidth = 1920;
++    res->iHeight= 1080;
++    res->iScreenWidth = 1920;
++    res->iScreenHeight= 1080;
++    res->fRefreshRate = 29.97;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
+   else if (StringUtils::EqualsNoCase(fromMode, "1080p30hz"))
+   {
+     res->iWidth = 1920;
+@@ -543,7 +616,7 @@ bool aml_mode_to_resolution(const char *
+     res->fRefreshRate = 30;
+     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+   }
+-  else if (StringUtils::EqualsNoCase(fromMode, "2160p50hz420"))
++  else if (StringUtils::EqualsNoCase(fromMode, "2160p50hz"))
+   {
+     res->iWidth = 1920;
+     res->iHeight= 1080;
+@@ -552,7 +625,16 @@ bool aml_mode_to_resolution(const char *
+     res->fRefreshRate = 50;
+     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+   }
+-  else if (StringUtils::EqualsNoCase(fromMode, "2160p60hz420"))
++  else if (StringUtils::EqualsNoCase(fromMode, "4k2k59hz") || StringUtils::EqualsNoCase(fromMode, "2160p59hz"))
++  {
++    res->iWidth = 1920;
++    res->iHeight= 1080;
++    res->iScreenWidth = 3840;
++    res->iScreenHeight= 2160;
++    res->fRefreshRate = 59.940;
++    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  }
++  else if (StringUtils::EqualsNoCase(fromMode, "2160p60hz"))
+   {
+     res->iWidth = 1920;
+     res->iHeight= 1080;
+@@ -577,4 +659,3 @@ bool aml_mode_to_resolution(const char *
+ 
+   return res->iWidth > 0 && res->iHeight> 0;
+ }
+-
+--- a/xbmc/utils/CPUInfo.cpp
++++ b/xbmc/utils/CPUInfo.cpp
+@@ -120,7 +120,7 @@ CCPUInfo::CCPUInfo(void)
+ 
+   size_t len = 4;
+   std::string cpuVendor;
+-  
++
+   // The number of cores.
+   if (sysctlbyname("hw.activecpu", &m_cpuCount, &len, NULL, 0) == -1)
+       m_cpuCount = 1;
+@@ -141,7 +141,7 @@ CCPUInfo::CCPUInfo(void)
+   len = 512;
+   if (sysctlbyname("machdep.cpu.vendor", &buffer, &len, NULL, 0) == 0)
+     cpuVendor = buffer;
+-  
++
+ #endif
+   // Go through each core.
+   for (int i=0; i<m_cpuCount; i++)
+@@ -268,9 +268,9 @@ CCPUInfo::CCPUInfo(void)
+   if (m_fProcTemperature == NULL)
+     m_fProcTemperature = fopen("/proc/acpi/thermal_zone/TZ0/temperature", "r");
+   // read from the new location of the temperature data on new kernels, 2.6.39, 3.0 etc
+-  if (m_fProcTemperature == NULL)   
++  if (m_fProcTemperature == NULL)
+     m_fProcTemperature = fopen("/sys/class/hwmon/hwmon0/temp1_input", "r");
+-  if (m_fProcTemperature == NULL)   
++  if (m_fProcTemperature == NULL)
+     m_fProcTemperature = fopen("/sys/class/thermal/thermal_zone0/temp", "r");  // On Raspberry PIs
+ 
+   m_fCPUFreq = fopen ("/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq", "r");
+@@ -553,7 +553,7 @@ float CCPUInfo::getCPUFrequency()
+       return float(cnt.FirstValue);
+     }
+   }
+-  
++
+   if (!m_cores.empty())
+     return float(m_cores.begin()->second.m_fSpeed);
+   else
+@@ -599,7 +599,7 @@ bool CCPUInfo::getTemperature(CTemperatu
+ {
+   int         value = 0;
+   char        scale = 0;
+-  
++
+ #ifdef TARGET_POSIX
+ #if defined(TARGET_DARWIN_OSX)
+   value = SMCGetTemperature(SMC_KEY_CPU_TEMP);
+@@ -628,23 +628,24 @@ bool CCPUInfo::getTemperature(CTemperatu
+     // procfs is deprecated in the linux kernel, we should move away from
+     // using it for temperature data.  It doesn't seem that sysfs has a
+     // general enough interface to bother implementing ATM.
+-    
++
+     rewind(m_fProcTemperature);
+     fflush(m_fProcTemperature);
+     ret = fscanf(m_fProcTemperature, "temperature: %d %c", &value, &scale);
+-    
++
+     // read from the temperature file of the new kernels
+     if (!ret)
+     {
+       ret = fscanf(m_fProcTemperature, "%d", &value);
+-      value = value / 1000;
++      if ((int)value > 1000)
++        value = value / 1000;
+       scale = 'c';
+       ret++;
+     }
+   }
+ 
+   if (ret != 2)
+-    return false; 
++    return false;
+ #endif
+ #endif // TARGET_POSIX
+ 
+@@ -654,7 +655,7 @@ bool CCPUInfo::getTemperature(CTemperatu
+     temperature = CTemperature::CreateFromFahrenheit(value);
+   else
+     return false;
+-  
++
+   return true;
+ }
+ 
+@@ -709,7 +710,7 @@ bool CCPUInfo::readProcStat(unsigned lon
+         const LONGLONG deltaTotal = coreTotal - curCore.m_total,
+                        deltaIdle  = coreIdle - curCore.m_idle;
+         const double load = (double(deltaTotal - deltaIdle) * 100.0) / double(deltaTotal);
+-        
++
+         // win32 has some problems with calculation of load if load close to zero
+         curCore.m_fPct = (load < 0) ? 0 : load;
+         if (load >= 0 || deltaTotal > 5 * 10 * 1000 * 1000) // do not update (smooth) values for 5 seconds on negative loads
+--- a/xbmc/windowing/X11/WinSystemX11.cpp
++++ b/xbmc/windowing/X11/WinSystemX11.cpp
+@@ -203,7 +203,7 @@ bool CWinSystemX11::SetFullScreen(bool f
+     mode.hz  = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+     mode.id  = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP).strId;
+   }
+- 
++
+   XMode   currmode = g_xrandr.GetCurrentMode(out.name);
+   if (!currmode.name.empty())
+   {
+--- a/xbmc/windowing/egl/CMakeLists.txt
++++ b/xbmc/windowing/egl/CMakeLists.txt
+@@ -1,9 +1,11 @@
+ if(OPENGLES_FOUND OR AML_FOUND OR IMX_FOUND OR MMAL_FOUND)
+-  set(SOURCES EGLWrapper.cpp)
++  set(SOURCES EGLWrapper.cpp
++              EGLNativeTypeFbdev.cpp)
+ 
+   set(HEADERS EGLNativeType.h
+               EGLQuirks.h
+-              EGLWrapper.h)
++              EGLWrapper.h
++              EGLNativeTypeFbdev.h)
+ endif()
+ 
+ if(OPENGLES_FOUND)
+--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
++++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+@@ -23,13 +23,18 @@
+ #include "utils/AMLUtils.h"
+ #include "utils/StringUtils.h"
+ #include "utils/SysfsUtils.h"
++#include "utils/log.h"
+ 
+-#include <stdio.h>
+ #include <stdlib.h>
+ #include <linux/fb.h>
+ #include <sys/ioctl.h>
+ #include <EGL/egl.h>
+ 
++#ifdef CLASSNAME
++#undef CLASSNAME
++#endif
++#define CLASSNAME "CEGLNativeTypeAmlogic"
++
+ CEGLNativeTypeAmlogic::CEGLNativeTypeAmlogic()
+ {
+   const char *env_framebuffer = getenv("FRAMEBUFFER");
+@@ -63,28 +68,37 @@ bool CEGLNativeTypeAmlogic::CheckCompati
+ void CEGLNativeTypeAmlogic::Initialize()
+ {
+   aml_permissions();
+-  DisableFreeScale();
++  FreeScale(false);
+ }
++
+ void CEGLNativeTypeAmlogic::Destroy()
+ {
++  SetScreenScale(1, 1, false);
+   return;
+ }
+ 
+ bool CEGLNativeTypeAmlogic::CreateNativeDisplay()
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+   return true;
+ }
+ 
+ bool CEGLNativeTypeAmlogic::CreateNativeWindow()
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+ #if defined(_FBDEV_WINDOW_H_)
+   fbdev_window *nativeWindow = new fbdev_window;
+   if (!nativeWindow)
+     return false;
+ 
+-  nativeWindow->width = 1920;
+-  nativeWindow->height = 1080;
++  RESOLUTION_INFO res;
++  GetPreferredResolution(&res);
++
++  nativeWindow->width = res.iWidth;
++  nativeWindow->height = res.iHeight;
+   m_nativeWindow = nativeWindow;
+ 
+   SetFramebufferResolution(nativeWindow->width, nativeWindow->height);
+@@ -97,6 +111,8 @@ bool CEGLNativeTypeAmlogic::CreateNative
+ 
+ bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   if (!nativeDisplay)
+     return false;
+   *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+@@ -105,6 +121,8 @@ bool CEGLNativeTypeAmlogic::GetNativeDis
+ 
+ bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   if (!nativeWindow)
+     return false;
+   *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+@@ -113,11 +131,15 @@ bool CEGLNativeTypeAmlogic::GetNativeWin
+ 
+ bool CEGLNativeTypeAmlogic::DestroyNativeDisplay()
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   return true;
+ }
+ 
+ bool CEGLNativeTypeAmlogic::DestroyNativeWindow()
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+ #if defined(_FBDEV_WINDOW_H_)
+   delete (fbdev_window*)m_nativeWindow, m_nativeWindow = NULL;
+ #endif
+@@ -133,6 +155,8 @@ bool CEGLNativeTypeAmlogic::GetNativeRes
+ 
+ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
+ {
++  CLog::Log(LOGNOTICE, "%s::%s to %dx%d@%f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
++
+ #if defined(_FBDEV_WINDOW_H_)
+   if (m_nativeWindow)
+   {
+@@ -152,6 +176,8 @@ bool CEGLNativeTypeAmlogic::SetNativeRes
+ 
+ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   std::string valstr;
+   SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", valstr);
+   std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+@@ -164,11 +190,12 @@ bool CEGLNativeTypeAmlogic::ProbeResolut
+       resolutions.push_back(res);
+   }
+   return resolutions.size() > 0;
+-
+ }
+ 
+ bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   // check display/mode, it gets defaulted at boot
+   if (!GetNativeResolution(res))
+   {
+@@ -181,6 +208,8 @@ bool CEGLNativeTypeAmlogic::GetPreferred
+ 
+ bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
+ {
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
+   std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
+   SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
+   return true;
+@@ -188,6 +217,8 @@ bool CEGLNativeTypeAmlogic::ShowWindow(b
+ 
+ bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
+ {
++  CLog::Log(LOGNOTICE, "%s::%s to %s", CLASSNAME, __func__, resolution);
++
+   std::string mode = resolution;
+   // switch display resolution
+   SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
+@@ -195,36 +226,46 @@ bool CEGLNativeTypeAmlogic::SetDisplayRe
+   RESOLUTION_INFO res;
+   aml_mode_to_resolution(mode.c_str(), &res);
+   SetFramebufferResolution(res);
++  DealWithScale(res);
+ 
+   return true;
+ }
+ 
+-void CEGLNativeTypeAmlogic::SetupVideoScaling(const char *mode)
++void CEGLNativeTypeAmlogic::FreeScale(bool state)
+ {
+-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank",      1);
+-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
+-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
+-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler",          0);
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+ 
+-  if (strstr(mode, "1080"))
+-  {
+-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "8");
+-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale_axis",     "1280 720 1920 1080");
+-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale",          "0x10001");
+-  }
+-  else
+-  {
+-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "16 1280 720");
++  std::string freescale_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/free_scale";
++  SysfsUtils::SetInt(freescale_framebuffer.c_str(), state ? 1 : 0);
++}
++
++void CEGLNativeTypeAmlogic::DealWithScale(const RESOLUTION_INFO &res)
++{
++  CLog::Log(LOGDEBUG, "%s::%s Interface is %dx%d, screen size is %dx%d", CLASSNAME, __func__, res.iWidth, res.iHeight, res.iScreenWidth, res.iScreenHeight);
++
++  if (res.iScreenWidth > res.iWidth && res.iScreenHeight > res.iHeight) {
++    CLog::Log(LOGNOTICE, "%s::%s Scaling interfaces of size %dx%d to full screen", CLASSNAME, __func__, res.iWidth, res.iHeight);
++    SetScreenScale(res.iWidth, res.iHeight, true);
+   }
++}
+ 
+-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank", 0);
++void CEGLNativeTypeAmlogic::SetScreenScale(int width, int height, bool state)
++{
++  char setting[256] = {};
++  sprintf(setting, "0 0 %d %d", width - 1 , height - 1);
++  std::string framebuffer = "/sys/class/graphics/" + m_framebuffer_name;
++  SysfsUtils::SetString(framebuffer + "/scale_axis", setting);
++  SysfsUtils::SetString(framebuffer + "/scale", state ? "0x10001" : "0x0");
+ }
+ 
+-void CEGLNativeTypeAmlogic::DisableFreeScale()
++bool CEGLNativeTypeAmlogic::IsHdmiConnected() const
+ {
+-  // turn off frame buffer freescale
+-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
+-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
++  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
++
++  std::string hpd_state;
++  SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", hpd_state);
++  StringUtils::Trim(hpd_state);
++  return hpd_state == "1";
+ }
+ 
+ void CEGLNativeTypeAmlogic::SetFramebufferResolution(const RESOLUTION_INFO &res) const
+@@ -244,8 +285,8 @@ void CEGLNativeTypeAmlogic::SetFramebuff
+     {
+       vinfo.xres = width;
+       vinfo.yres = height;
+-      vinfo.xres_virtual = 1920;
+-      vinfo.yres_virtual = 2160;
++      vinfo.xres_virtual = width;
++      vinfo.yres_virtual = height * 2;
+       vinfo.bits_per_pixel = 32;
+       vinfo.activate = FB_ACTIVATE_ALL;
+       ioctl(fd0, FBIOPUT_VSCREENINFO, &vinfo);
+--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
++++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
+@@ -24,6 +24,19 @@
+ #include <vector>
+ 
+ #include "EGLNativeType.h"
++#include <linux/fb.h>
++
++#ifndef _FBDEV_WINDOW_H_
++// Define it right here, since some platforms doesn't has fbdev_window.h at all.
++// This will not make it fail on these platforms badly, since it will fail softly anyway on some other init steps.
++#define _FBDEV_WINDOW_H_
++typedef struct fbdev_window
++{
++  unsigned short width;
++  unsigned short height;
++} fbdev_window;
++#endif
++
+ class CEGLNativeTypeAmlogic : public CEGLNativeType
+ {
+ public:
+@@ -52,12 +65,14 @@ public:
+ 
+ protected:
+   bool SetDisplayResolution(const char *resolution);
+-  void SetupVideoScaling(const char *mode);
+-  void DisableFreeScale();
+ 
+ private:
+   void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
+   void SetFramebufferResolution(int width, int height) const;
++  void FreeScale(bool state);
++  void DealWithScale(const RESOLUTION_INFO &res);
++  void SetScreenScale(int width, int height, bool state);
++  bool IsHdmiConnected() const;
+ 
+   std::string m_framebuffer_name;
+ };
+--- /dev/null
++++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
+@@ -0,0 +1,183 @@
++/*
++ *      Copyright (C) 2011-2012 Team XBMC
++ *      http://www.xbmc.org
++ *
++ *  This Program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This Program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with XBMC; see the file COPYING.  If not, see
++ *  <http://www.gnu.org/licenses/>.
++ *
++ */
++#include <EGL/egl.h>
++#include "EGLNativeTypeFbdev.h"
++#include "utils/log.h"
++#include <stdlib.h>
++#include <linux/fb.h>
++#include <sys/ioctl.h>
++#include "utils/StringUtils.h"
++#include "guilib/gui3d.h"
++#include <linux/media.h>
++
++#include <unistd.h>
++
++#include "utils/StringUtils.h"
++
++#ifdef CLASSNAME
++#undef CLASSNAME
++#endif
++#define CLASSNAME "CEGLNativeTypeFbdev"
++
++CEGLNativeTypeFbdev::CEGLNativeTypeFbdev()
++{
++  m_iFBHandle = -1;
++  m_nativeWindow  = NULL;
++  m_nativeDisplay = NULL;
++}
++
++CEGLNativeTypeFbdev::~CEGLNativeTypeFbdev()
++{
++}
++
++bool CEGLNativeTypeFbdev::CheckCompatibility()
++{
++  m_iFBHandle = open("/dev/fb0", O_RDWR, 0);
++  if(m_iFBHandle < 0)
++    return false;
++
++  vinfo = new fb_var_screeninfo();
++  if(ioctl(m_iFBHandle, FBIOGET_VSCREENINFO, vinfo) == -1)
++    return false;
++
++  CLog::Log(LOGNOTICE, "%s::%s FBDev device: %d, info.xres %d info.yres %d info.upper_margin %d info.lower_margin %d info.pixclock %d",
++    CLASSNAME, __func__, m_iFBHandle, vinfo->xres, vinfo->yres, vinfo->upper_margin, vinfo->lower_margin, vinfo->pixclock);
++
++  finfo = new fb_fix_screeninfo();
++  if(ioctl(m_iFBHandle, FBIOGET_FSCREENINFO, finfo) == -1)
++    return false;
++
++  return true;
++}
++
++void CEGLNativeTypeFbdev::Initialize()
++{
++  return;
++}
++void CEGLNativeTypeFbdev::Destroy()
++{
++  return;
++}
++
++bool CEGLNativeTypeFbdev::CreateNativeDisplay()
++{
++  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::CreateNativeWindow()
++{
++  fbdev_window *nativeWindow = new fbdev_window;
++  if (!nativeWindow)
++    return false;
++
++  nativeWindow->width = vinfo->xres;
++  nativeWindow->height = vinfo->yres;
++  m_nativeWindow = nativeWindow;
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
++{
++  if (!nativeDisplay)
++    return false;
++  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::GetNativeWindow(XBNativeWindowType **nativeWindow) const
++{
++  if (!nativeWindow)
++    return false;
++  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::DestroyNativeDisplay()
++{
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::DestroyNativeWindow()
++{
++  free(m_nativeWindow);
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::GetNativeResolution(RESOLUTION_INFO *res) const
++{
++  res->iWidth = vinfo->xres;
++  res->iHeight = vinfo->yres;
++  res->fRefreshRate = 60;
++  res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
++  res->iScreen = 0;
++  res->bFullScreen = true;
++  res->iSubtitles = (int)(0.965 * res->iHeight);
++  res->fPixelRatio = 1.0f;
++  res->iScreenWidth = res->iWidth;
++  res->iScreenHeight = res->iHeight;
++  res->strMode = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate, res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
++
++  CLog::Log(LOGNOTICE, "Current resolution: %s", res->strMode.c_str());
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::SetNativeResolution(const RESOLUTION_INFO &res)
++{
++
++  vinfo->activate = FB_ACTIVATE_NOW;
++
++  if (ioctl(m_iFBHandle, FBIOPUT_VSCREENINFO, vinfo) == -1)
++  {
++    CLog::Log(LOGERROR, "%s::%s - FBIOPUT_VSCREENINFO error", CLASSNAME, __func__);
++    return false;
++  }
++  if (ioctl(m_iFBHandle, FBIOPAN_DISPLAY, vinfo) == -1)
++  {
++    CLog::Log(LOGERROR, "%s::%s - FBIOPAN_DISPLAY error", CLASSNAME, __func__);
++    return false;
++  }
++
++  CLog::Log(LOGNOTICE, "%s::%s width %d height %d refresh %f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
++
++  return true;
++}
++
++bool CEGLNativeTypeFbdev::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
++{
++  RESOLUTION_INFO res;
++  if (GetNativeResolution(&res) && res.iWidth > 1 && res.iHeight > 1)
++  {
++    resolutions.push_back(res);
++    return true;
++  }
++  return false;
++}
++
++bool CEGLNativeTypeFbdev::GetPreferredResolution(RESOLUTION_INFO *res) const
++{
++    GetNativeResolution(res);
++    return true;
++}
++
++bool CEGLNativeTypeFbdev::ShowWindow(bool show)
++{
++  return false;
++}
+--- /dev/null
++++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.h
+@@ -0,0 +1,68 @@
++#pragma once
++
++/*
++ *      Copyright (C) 2011-2012 Team XBMC
++ *      http://www.xbmc.org
++ *
++ *  This Program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This Program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with XBMC; see the file COPYING.  If not, see
++ *  <http://www.gnu.org/licenses/>.
++ *
++ */
++
++#include "EGLNativeType.h"
++#include <linux/fb.h>
++#include <list>
++
++#ifndef _FBDEV_WINDOW_H_
++// Define it right here, since some platforms doesn't has fbdev_window.h at all.
++// This will not make it fail on these platforms badly, since it will fail softly anyway on some other init steps.
++#define _FBDEV_WINDOW_H_
++typedef struct fbdev_window
++{
++  unsigned short width;
++  unsigned short height;
++} fbdev_window;
++#endif
++
++class CEGLNativeTypeFbdev : public CEGLNativeType
++{
++public:
++  CEGLNativeTypeFbdev();
++  virtual ~CEGLNativeTypeFbdev();
++  virtual std::string GetNativeName() const { return "FBDev"; };
++  virtual bool  CheckCompatibility();
++  virtual void  Initialize();
++  virtual void  Destroy();
++  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
++
++  virtual bool  CreateNativeDisplay();
++  virtual bool  CreateNativeWindow();
++  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
++  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
++
++  virtual bool  DestroyNativeWindow();
++  virtual bool  DestroyNativeDisplay();
++
++  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
++  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
++  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
++  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
++
++  virtual bool  ShowWindow(bool show);
++
++protected:
++  int m_iFBHandle;
++  fb_var_screeninfo *vinfo;
++  fb_fix_screeninfo *finfo;
++};
+--- /dev/null
++++ b/xbmc/windowing/egl/EGLNativeTypeHybris.cpp
+@@ -0,0 +1,279 @@
++/*
++ *      Copyright (C) 2011-2012 Team XBMC
++ *      http://www.xbmc.org
++ *
++ *  This Program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This Program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with XBMC; see the file COPYING.  If not, see
++ *  <http://www.gnu.org/licenses/>.
++ *
++ */
++#if defined(TARGET_HYBRIS)
++#include <hwcomposerwindow/hwcomposer_window.h>
++#include <hardware/hardware.h>
++#include <hardware/hwcomposer.h>
++#endif
++
++#include "system.h"
++#include <EGL/egl.h>
++#include "EGLNativeTypeHybris.h"
++#include "utils/log.h"
++#include "guilib/gui3d.h"
++
++#include "utils/StringUtils.h"
++
++HWComposer::HWComposer(unsigned int width,
++                      unsigned int height,
++                      unsigned int format,
++                      hwc_composer_device_1_t *device,
++                      hwc_display_contents_1_t **mList,
++                      hwc_layer_1_t *layer)
++                      : HWComposerNativeWindow(width, height, format)
++{
++    fblayer = layer;
++    hwcdevice = device;
++    mlist = mList;
++}
++
++void HWComposer::present(HWComposerNativeWindowBuffer *buffer)
++{
++    int oldretire = mlist[0]->retireFenceFd;
++    mlist[0]->retireFenceFd = -1;
++    fblayer->handle = buffer->handle;
++    fblayer->acquireFenceFd = getFenceBufferFd(buffer);
++    fblayer->releaseFenceFd = -1;
++    int err = hwcdevice->prepare(hwcdevice, HWC_NUM_DISPLAY_TYPES, mlist);
++    assert(err == 0);
++
++    err = hwcdevice->set(hwcdevice, HWC_NUM_DISPLAY_TYPES, mlist);
++    assert(err == 0);
++    setFenceBufferFd(buffer, fblayer->releaseFenceFd);
++
++    if (oldretire != -1)
++    {
++        sync_wait(oldretire, -1);
++        close(oldretire);
++    }
++}
++
++CEGLNativeTypeHybris::CEGLNativeTypeHybris()
++#if defined(TARGET_HYBRIS)
++ : m_hwcModule(NULL), m_bufferList(NULL), m_hwcDevicePtr(NULL)
++{
++  m_nativeWindow = NULL;
++  m_hwNativeWindow = NULL;
++  m_swNativeWindow = NULL;
++}
++#else
++{
++}
++#endif
++
++CEGLNativeTypeHybris::~CEGLNativeTypeHybris()
++{
++}
++
++bool CEGLNativeTypeHybris::CheckCompatibility()
++{
++#if defined(TARGET_HYBRIS)
++  if(hw_get_module(HWC_HARDWARE_MODULE_ID, (const hw_module_t **) &m_hwcModule))
++  {
++    return false;
++  }
++
++  if(hwc_open_1(m_hwcModule, &m_hwcDevicePtr))
++  {
++    return false;
++  }
++
++  m_hwcDevicePtr->blank(m_hwcDevicePtr, 0, 0);
++  return true;
++#else
++  return false;
++#endif
++}
++
++void CEGLNativeTypeHybris::Initialize()
++{
++}
++
++void CEGLNativeTypeHybris::Destroy()
++{
++  return;
++}
++
++bool CEGLNativeTypeHybris::CreateNativeDisplay()
++{
++  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
++  return true;
++}
++
++bool CEGLNativeTypeHybris::CreateNativeWindow()
++{
++#if defined(TARGET_HYBRIS)
++  RESOLUTION_INFO res;
++  if (!GetNativeResolution(&res))
++    return false;
++
++  size_t size = sizeof(hwc_display_contents_1_t) + 2 * sizeof(hwc_layer_1_t);
++  hwc_display_contents_1_t *list = (hwc_display_contents_1_t *) malloc(size);
++  m_bufferList = (hwc_display_contents_1_t **) malloc(HWC_NUM_DISPLAY_TYPES * sizeof(hwc_display_contents_1_t *));
++  const hwc_rect_t r = { 0, 0, res.iWidth, res.iHeight };
++
++  for (int counter = 0; counter < HWC_NUM_DISPLAY_TYPES; counter++)
++    m_bufferList[counter] = list;
++
++  hwc_layer_1_t *layer;
++
++  layer = &list->hwLayers[0];
++  memset(layer, 0, sizeof(hwc_layer_1_t));
++  layer->compositionType = HWC_FRAMEBUFFER;
++  layer->hints = 0;
++  layer->flags = 0;
++  layer->handle = 0;
++  layer->transform = 0;
++  layer->blending = HWC_BLENDING_NONE;
++  layer->sourceCrop = r;
++  layer->displayFrame = r;
++  layer->visibleRegionScreen.numRects = 1;
++  layer->visibleRegionScreen.rects = &layer->displayFrame;
++  layer->acquireFenceFd = -1;
++  layer->releaseFenceFd = -1;
++
++  layer = &list->hwLayers[1];
++  memset(layer, 0, sizeof(hwc_layer_1_t));
++  layer->compositionType = HWC_FRAMEBUFFER_TARGET;
++  layer->hints = 0;
++  layer->flags = 0;
++  layer->handle = 0;
++  layer->transform = 0;
++  layer->blending = HWC_BLENDING_NONE;
++  layer->sourceCrop = r;
++  layer->displayFrame = r;
++  layer->visibleRegionScreen.numRects = 1;
++  layer->visibleRegionScreen.rects = &layer->displayFrame;
++  layer->acquireFenceFd = -1;
++  layer->releaseFenceFd = -1;
++
++  list->retireFenceFd = -1;
++  list->flags = HWC_GEOMETRY_CHANGED;
++  list->numHwLayers = 2;
++
++  m_hwNativeWindow = new HWComposer(res.iWidth, res.iHeight, HAL_PIXEL_FORMAT_RGBA_8888, m_hwcDevicePtr, m_bufferList, &list->hwLayers[1]);
++  if (m_hwNativeWindow == NULL)
++  {
++    CLog::Log(LOGERROR, "HWComposer native window failed!");
++    return false;
++  }
++  m_swNativeWindow = (static_cast<ANativeWindow *> (m_hwNativeWindow));
++
++  return true;
++#else
++  return false;
++#endif
++}
++
++bool CEGLNativeTypeHybris::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
++{
++  if (!nativeDisplay)
++    return false;
++
++  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
++
++  return true;
++}
++
++bool CEGLNativeTypeHybris::GetNativeWindow(XBNativeWindowType **nativeWindow) const
++{
++  if (!nativeWindow)
++    return false;
++
++#if defined(TARGET_HYBRIS)
++  *nativeWindow = (XBNativeWindowType*) &m_swNativeWindow;
++  return (m_swNativeWindow != NULL);
++#else
++  return false;
++#endif
++}
++
++bool CEGLNativeTypeHybris::DestroyNativeDisplay()
++{
++  return true;
++}
++
++bool CEGLNativeTypeHybris::DestroyNativeWindow()
++{
++  m_nativeWindow = NULL;
++  return true;
++}
++
++bool CEGLNativeTypeHybris::GetNativeResolution(RESOLUTION_INFO *res) const
++{
++#if defined(TARGET_HYBRIS)
++  uint32_t configs[5];
++  size_t numConfigs = 5;
++
++  int err = m_hwcDevicePtr->getDisplayConfigs(m_hwcDevicePtr, 0, configs, &numConfigs);
++  if (err) {
++      CLog::Log(LOGERROR, "getDisplayConfigs failed!");
++      return false;
++  }
++  int32_t attr_values[3];
++  uint32_t attributes[] = { HWC_DISPLAY_WIDTH, HWC_DISPLAY_HEIGHT, HWC_DISPLAY_VSYNC_PERIOD, HWC_DISPLAY_NO_ATTRIBUTE };
++
++  m_hwcDevicePtr->getDisplayAttributes(m_hwcDevicePtr, 0, configs[0], attributes, attr_values);
++
++  res->iWidth        = attr_values[0];
++  res->iHeight       = attr_values[1];
++  res->fRefreshRate  = 1000000000 / attr_values[2];
++
++  res->dwFlags       = D3DPRESENTFLAG_PROGRESSIVE;
++  res->iScreen       = 0;
++  res->bFullScreen   = true;
++  res->iSubtitles    = (int)(0.965 * res->iHeight);
++  res->fPixelRatio   = 1.0f;
++  res->iScreenWidth  = res->iWidth;
++  res->iScreenHeight = res->iHeight;
++  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
++  res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
++  CLog::Log(LOGNOTICE,"Current resolution: %s\n",res->strMode.c_str());
++  return true;
++#endif
++}
++
++bool CEGLNativeTypeHybris::SetNativeResolution(const RESOLUTION_INFO &res)
++{
++  return false;
++}
++
++bool CEGLNativeTypeHybris::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
++{
++  RESOLUTION_INFO res;
++  if (GetNativeResolution(&res) && res.iWidth > 1 && res.iHeight > 1)
++  {
++    resolutions.push_back(res);
++    return true;
++  }
++  return false;
++}
++
++bool CEGLNativeTypeHybris::GetPreferredResolution(RESOLUTION_INFO *res) const
++{
++  if (GetNativeResolution(res))
++    return true;
++  return false;
++}
++
++bool CEGLNativeTypeHybris::ShowWindow(bool show)
++{
++  return true;
++}
+--- /dev/null
++++ b/xbmc/windowing/egl/EGLNativeTypeHybris.h
+@@ -0,0 +1,77 @@
++#pragma once
++
++/*
++ *      Copyright (C) 2011-2012 Team XBMC
++ *      http://www.xbmc.org
++ *
++ *  This Program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This Program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with XBMC; see the file COPYING.  If not, see
++ *  <http://www.gnu.org/licenses/>.
++ *
++ */
++
++#if defined(TARGET_HYBRIS)
++#include <hwcomposerwindow/hwcomposer_window.h>
++#include <hardware/hardware.h>
++#include <hardware/hwcomposer.h>
++#endif
++
++#include "EGLNativeType.h"
++#include "threads/Thread.h"
++
++class HWComposer : public HWComposerNativeWindow
++{
++  private:
++    hwc_layer_1_t *fblayer;
++    hwc_composer_device_1_t *hwcdevice;
++    hwc_display_contents_1_t **mlist;
++  protected:
++    void present(HWComposerNativeWindowBuffer *buffer);
++  public:
++    HWComposer(unsigned int width, unsigned int height, unsigned int format, hwc_composer_device_1_t *device, hwc_display_contents_1_t **mList, hwc_layer_1_t *layer);
++};
++
++class CEGLNativeTypeHybris : public CEGLNativeType
++{
++public:
++  CEGLNativeTypeHybris();
++  virtual ~CEGLNativeTypeHybris();
++  virtual std::string GetNativeName() const { return "hybris"; };
++  virtual bool  CheckCompatibility();
++  virtual void  Initialize();
++  virtual void  Destroy();
++  virtual int   GetQuirks() { return 0; };
++
++  virtual bool  CreateNativeDisplay();
++  virtual bool  CreateNativeWindow();
++  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
++  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
++
++  virtual bool  DestroyNativeWindow();
++  virtual bool  DestroyNativeDisplay();
++
++  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
++  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
++  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
++  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
++
++  virtual bool  ShowWindow(bool show);
++#if defined(TARGET_HYBRIS)
++private:
++  hw_module_t                *m_hwcModule;
++  hwc_display_contents_1_t   **m_bufferList;
++  hwc_composer_device_1_t    *m_hwcDevicePtr;
++  HWComposerNativeWindow     *m_hwNativeWindow;
++  ANativeWindow              *m_swNativeWindow;
++#endif
++};
+--- a/xbmc/windowing/egl/EGLWrapper.cpp
++++ b/xbmc/windowing/egl/EGLWrapper.cpp
+@@ -24,9 +24,9 @@
+ #include <assert.h>
+ #if defined(TARGET_ANDROID)
+   #include "EGLNativeTypeAndroid.h"
+-#if defined(HAS_LIBAMCODEC)
+-  #include "EGLNativeTypeAmlAndroid.h"
+-#endif
++  #if defined(HAS_LIBAMCODEC)
++    #include "EGLNativeTypeAmlAndroid.h"
++  #endif
+ #endif
+ #if defined(TARGET_RASPBERRY_PI)
+   #include "EGLNativeTypeRaspberryPI.h"
+@@ -35,8 +35,12 @@
+   #include "EGLNativeTypeIMX.h"
+ #endif
+ #if defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
+-#include "EGLNativeTypeAmlogic.h"
++  #include "EGLNativeTypeAmlogic.h"
++#endif
++#if defined(TARGET_LINUX) && defined(HAS_HYBRIS)
++  #include "EGLNativeTypeHybris.h"
+ #endif
++#include "EGLNativeTypeFbdev.h"
+ #include "EGLWrapper.h"
+ 
+ #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
+@@ -101,6 +105,10 @@ bool CEGLWrapper::Initialize(const std::
+       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
+ #elif defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
+       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation))
++#elif defined(TARGET_LINUX) && defined(HAS_HYBRIS)
++      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeHybris>(implementation))
++#else
++      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeFbdev>(implementation))
+ #endif
+       )
+   {
+@@ -422,4 +430,3 @@ bool CEGLWrapper::SurfaceAttrib(EGLDispl
+   return eglSurfaceAttrib(display, surface, attribute, value);
+ }
+ #endif
+-
+--- a/xbmc/windowing/egl/Makefile.in
++++ b/xbmc/windowing/egl/Makefile.in
+@@ -12,6 +12,10 @@ endif
+ ifeq (@USE_IMXVPU@,1)
+ SRCS+= EGLNativeTypeIMX.cpp
+ endif
++ifeq (@USE_HYBRIS@,1)
++SRCS+= EGLNativeTypeHybris.cpp
++endif
++SRCS+= EGLNativeTypeFbdev.cpp
+ SRCS+= EGLWrapper.cpp
+ 
+ LIB = windowing_egl.a
+--- a/project/cmake/CMakeLists.txt
++++ b/project/cmake/CMakeLists.txt
+@@ -203,6 +203,7 @@ if(NOT WIN32)
+     if(OPENGLES_FOUND)
+       core_optional_dep(X ENABLE_X11)
+       core_optional_dep(LibDRM ENABLE_X11)
++      core_optional_dep(XRandR ENABLE_X11)
+     endif()
+   endif()
+   if(NOT APPLE)
diff --git a/projects/Odroid_U2/patches/libcec/0001_libcec_add-exynos-cec-variable.patch b/projects/Odroid_U2/patches/libcec/0001_libcec_add-exynos-cec-variable.patch
new file mode 100644
index 0000000..4c453b7
--- /dev/null
+++ b/projects/Odroid_U2/patches/libcec/0001_libcec_add-exynos-cec-variable.patch
@@ -0,0 +1,30 @@
+---
+ src/libcec/adapter/Exynos/ExynosCECAdapterCommunication.cpp |   16 	7 +	9 -	0 !
+ 1 file changed, 7 insertions(+), 9 deletions(-)
+
+--- a/src/libcec/adapter/Exynos/ExynosCECAdapterCommunication.cpp
++++ b/src/libcec/adapter/Exynos/ExynosCECAdapterCommunication.cpp
+@@ -159,16 +159,14 @@ cec_vendor_id CExynosCECAdapterCommunica
+ 
+ uint16_t CExynosCECAdapterCommunication::GetPhysicalAddress(void)
+ {
+-  uint16_t phys_addr = CEC_DEFAULT_PADDR;
++  char* addr_string = getenv("CEC_HDMI_PORT");
++  if (addr_string == NULL)
++    return CEC_DEFAULT_PHYSICAL_ADDRESS;
++  int addr_int = atoi(addr_string);
++  if (addr_int == 0)
++    return CEC_DEFAULT_PHYSICAL_ADDRESS;
+ 
+-  FILE *f = fopen(CEC_PADDR_NAME, "r");
+-  if(f) {
+-    if(fscanf(f, "%hu", &phys_addr) != 1)
+-      phys_addr = CEC_DEFAULT_PADDR;
+-
+-    fclose(f);
+-  }
+-  return phys_addr;
++  return 0x1000 * addr_int;
+ }
+ 
+ 
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-002-compiler-gcc.h.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-002-compiler-gcc.h.patch
new file mode 100644
index 0000000..46b4c8e
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-002-compiler-gcc.h.patch
@@ -0,0 +1,327 @@
+diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
+index 24545cd..0c5d746 100644
+--- a/include/linux/compiler-gcc.h
++++ b/include/linux/compiler-gcc.h
+@@ -97,10 +97,122 @@
+ #define __maybe_unused			__attribute__((unused))
+ #define __always_unused			__attribute__((unused))
+ 
+-#define __gcc_header(x) #x
+-#define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)
+-#define gcc_header(x) _gcc_header(x)
+-#include gcc_header(__GNUC__)
++/* gcc version specific checks */
++
++#if GCC_VERSION < 30200
++# error Sorry, your compiler is too old - please upgrade it.
++#endif
++
++#if GCC_VERSION < 30300
++# define __used			__attribute__((__unused__))
++#else
++# define __used			__attribute__((__used__))
++#endif
++
++#ifdef CONFIG_GCOV_KERNEL
++# if GCC_VERSION < 30400
++#   error "GCOV profiling support for gcc versions below 3.4 not included"
++# endif /* __GNUC_MINOR__ */
++#endif /* CONFIG_GCOV_KERNEL */
++
++#if GCC_VERSION >= 30400
++#define __must_check		__attribute__((warn_unused_result))
++#endif
++
++#if GCC_VERSION >= 40000
++
++/* GCC 4.1.[01] miscompiles __weak */
++#ifdef __KERNEL__
++# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
++#  error Your version of gcc miscompiles the __weak directive
++# endif
++#endif
++
++#define __used			__attribute__((__used__))
++#define __compiler_offsetof(a, b)					\
++	__builtin_offsetof(a, b)
++
++#if GCC_VERSION >= 40100 && GCC_VERSION < 40600
++# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
++#endif
++
++#if GCC_VERSION >= 40300
++/* Mark functions as cold. gcc will assume any path leading to a call
++ * to them will be unlikely.  This means a lot of manual unlikely()s
++ * are unnecessary now for any paths leading to the usual suspects
++ * like BUG(), printk(), panic() etc. [but let's keep them for now for
++ * older compilers]
++ *
++ * Early snapshots of gcc 4.3 don't support this and we can't detect this
++ * in the preprocessor, but we can live with this because they're unreleased.
++ * Maketime probing would be overkill here.
++ *
++ * gcc also has a __attribute__((__hot__)) to move hot functions into
++ * a special section, but I don't see any sense in this right now in
++ * the kernel context
++ */
++#define __cold			__attribute__((__cold__))
++
++#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
++
++#ifndef __CHECKER__
++# define __compiletime_warning(message) __attribute__((warning(message)))
++# define __compiletime_error(message) __attribute__((error(message)))
++#endif /* __CHECKER__ */
++#endif /* GCC_VERSION >= 40300 */
++
++#if GCC_VERSION >= 40500
++/*
++ * Mark a position in code as unreachable.  This can be used to
++ * suppress control flow warnings after asm blocks that transfer
++ * control elsewhere.
++ *
++ * Early snapshots of gcc 4.5 don't support this and we can't detect
++ * this in the preprocessor, but we can live with this because they're
++ * unreleased.  Really, we need to have autoconf for the kernel.
++ */
++#define unreachable() __builtin_unreachable()
++
++/* Mark a function definition as prohibited from being cloned. */
++#define __noclone	__attribute__((__noclone__))
++
++#endif /* GCC_VERSION >= 40500 */
++
++#if GCC_VERSION >= 40600
++/*
++ * Tell the optimizer that something else uses this function or variable.
++ */
++#define __visible	__attribute__((externally_visible))
++#endif
++
++/*
++ * GCC 'asm goto' miscompiles certain code sequences:
++ *
++ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
++ *
++ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
++ *
++ * (asm goto is automatically volatile - the naming reflects this.)
++ */
++#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
++
++#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
++#if GCC_VERSION >= 40400
++#define __HAVE_BUILTIN_BSWAP32__
++#define __HAVE_BUILTIN_BSWAP64__
++#endif
++#if GCC_VERSION >= 40800 || (defined(__powerpc__) && GCC_VERSION >= 40600)
++#define __HAVE_BUILTIN_BSWAP16__
++#endif
++#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
++
++#if GCC_VERSION >= 50000
++#define KASAN_ABI_VERSION 4
++#elif GCC_VERSION >= 40902
++#define KASAN_ABI_VERSION 3
++#endif
++
++#endif	/* gcc version >= 40000 specific checks */
+ 
+ #if !defined(__noclone)
+ #define __noclone	/* not needed */
+diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
+deleted file mode 100644
+index 37d4124..0000000
+--- a/include/linux/compiler-gcc3.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#ifndef __LINUX_COMPILER_H
+-#error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
+-#endif
+-
+-#if __GNUC_MINOR__ < 2
+-# error Sorry, your compiler is too old - please upgrade it.
+-#endif
+-
+-#if __GNUC_MINOR__ >= 3
+-# define __used			__attribute__((__used__))
+-#else
+-# define __used			__attribute__((__unused__))
+-#endif
+-
+-#if __GNUC_MINOR__ >= 4
+-#define __must_check		__attribute__((warn_unused_result))
+-#endif
+-
+-#ifdef CONFIG_GCOV_KERNEL
+-# if __GNUC_MINOR__ < 4
+-#   error "GCOV profiling support for gcc versions below 3.4 not included"
+-# endif /* __GNUC_MINOR__ */
+-#endif /* CONFIG_GCOV_KERNEL */
+diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
+deleted file mode 100644
+index a11c184..0000000
+--- a/include/linux/compiler-gcc4.h
++++ /dev/null
+@@ -1,90 +0,0 @@
+-#ifndef __LINUX_COMPILER_H
+-#error "Please don't include <linux/compiler-gcc4.h> directly, include <linux/compiler.h> instead."
+-#endif
+-
+-/* GCC 4.1.[01] miscompiles __weak */
+-#ifdef __KERNEL__
+-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+-#  error Your version of gcc miscompiles the __weak directive
+-# endif
+-#endif
+-
+-#define __used			__attribute__((__used__))
+-#define __must_check 		__attribute__((warn_unused_result))
+-#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
+-
+-#if __GNUC_MINOR__ > 0
+-# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+-#endif
+-
+-#if __GNUC_MINOR__ >= 3
+-/* Mark functions as cold. gcc will assume any path leading to a call
+-   to them will be unlikely.  This means a lot of manual unlikely()s
+-   are unnecessary now for any paths leading to the usual suspects
+-   like BUG(), printk(), panic() etc. [but let's keep them for now for
+-   older compilers]
+-
+-   Early snapshots of gcc 4.3 don't support this and we can't detect this
+-   in the preprocessor, but we can live with this because they're unreleased.
+-   Maketime probing would be overkill here.
+-
+-   gcc also has a __attribute__((__hot__)) to move hot functions into
+-   a special section, but I don't see any sense in this right now in
+-   the kernel context */
+-#define __cold			__attribute__((__cold__))
+-
+-#define __linktime_error(message) __attribute__((__error__(message)))
+-
+-#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+-
+-#ifndef __CHECKER__
+-# define __compiletime_warning(message) __attribute__((warning(message)))
+-# define __compiletime_error(message) __attribute__((error(message)))
+-#endif /* __CHECKER__ */
+-#endif /* __GNUC_MINOR__ >= 3 */
+-
+-#if __GNUC_MINOR__ >= 5
+-/*
+- * Mark a position in code as unreachable.  This can be used to
+- * suppress control flow warnings after asm blocks that transfer
+- * control elsewhere.
+- *
+- * Early snapshots of gcc 4.5 don't support this and we can't detect
+- * this in the preprocessor, but we can live with this because they're
+- * unreleased.  Really, we need to have autoconf for the kernel.
+- */
+-#define unreachable() __builtin_unreachable()
+-
+-/* Mark a function definition as prohibited from being cloned. */
+-#define __noclone	__attribute__((__noclone__))
+-
+-#endif /* __GNUC_MINOR__ >= 5 */
+-
+-#if __GNUC_MINOR__ >= 6
+-/*
+- * Tell the optimizer that something else uses this function or variable.
+- */
+-#define __visible __attribute__((externally_visible))
+-#endif
+-
+-/*
+- * GCC 'asm goto' miscompiles certain code sequences:
+- *
+- *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+- *
+- * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+- * Fixed in GCC 4.8.2 and later versions.
+- *
+- * (asm goto is automatically volatile - the naming reflects this.)
+- */
+-#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+-
+-#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+-#if __GNUC_MINOR__ >= 4
+-#define __HAVE_BUILTIN_BSWAP32__
+-#define __HAVE_BUILTIN_BSWAP64__
+-#endif
+-#if __GNUC_MINOR__ >= 8 || (defined(__powerpc__) && __GNUC_MINOR__ >= 6)
+-#define __HAVE_BUILTIN_BSWAP16__
+-#endif
+-#endif
+diff --git a/include/linux/compiler-gcc5.h b/include/linux/compiler-gcc5.h
+deleted file mode 100644
+index c8c5659..0000000
+--- a/include/linux/compiler-gcc5.h
++++ /dev/null
+@@ -1,65 +0,0 @@
+-#ifndef __LINUX_COMPILER_H
+-#error "Please don't include <linux/compiler-gcc5.h> directly, include <linux/compiler.h> instead."
+-#endif
+-
+-#define __used				__attribute__((__used__))
+-#define __must_check			__attribute__((warn_unused_result))
+-#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+-
+-/* Mark functions as cold. gcc will assume any path leading to a call
+-   to them will be unlikely.  This means a lot of manual unlikely()s
+-   are unnecessary now for any paths leading to the usual suspects
+-   like BUG(), printk(), panic() etc. [but let's keep them for now for
+-   older compilers]
+-
+-   Early snapshots of gcc 4.3 don't support this and we can't detect this
+-   in the preprocessor, but we can live with this because they're unreleased.
+-   Maketime probing would be overkill here.
+-
+-   gcc also has a __attribute__((__hot__)) to move hot functions into
+-   a special section, but I don't see any sense in this right now in
+-   the kernel context */
+-#define __cold			__attribute__((__cold__))
+-
+-#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+-
+-#ifndef __CHECKER__
+-# define __compiletime_warning(message) __attribute__((warning(message)))
+-# define __compiletime_error(message) __attribute__((error(message)))
+-#endif /* __CHECKER__ */
+-
+-/*
+- * Mark a position in code as unreachable.  This can be used to
+- * suppress control flow warnings after asm blocks that transfer
+- * control elsewhere.
+- *
+- * Early snapshots of gcc 4.5 don't support this and we can't detect
+- * this in the preprocessor, but we can live with this because they're
+- * unreleased.  Really, we need to have autoconf for the kernel.
+- */
+-#define unreachable() __builtin_unreachable()
+-
+-/* Mark a function definition as prohibited from being cloned. */
+-#define __noclone	__attribute__((__noclone__))
+-
+-/*
+- * Tell the optimizer that something else uses this function or variable.
+- */
+-#define __visible __attribute__((externally_visible))
+-
+-/*
+- * GCC 'asm goto' miscompiles certain code sequences:
+- *
+- *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+- *
+- * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+- *
+- * (asm goto is automatically volatile - the naming reflects this.)
+- */
+-#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+-
+-#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+-#define __HAVE_BUILTIN_BSWAP32__
+-#define __HAVE_BUILTIN_BSWAP64__
+-#define __HAVE_BUILTIN_BSWAP16__
+-#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-003-no_dev_console.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-003-no_dev_console.patch
new file mode 100644
index 0000000..0ef8d8c
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-003-no_dev_console.patch
@@ -0,0 +1,19 @@
+--- linux-odroid-3.8.13.21/init/main.c.orig	2014-05-09 12:07:09.436583808 -0400
++++ linux-odroid-3.8.13.21/init/main.c	2014-05-09 12:24:13.830397853 -0400
+@@ -899,9 +899,14 @@
+ 	do_basic_setup();
+ 
+ 	/* Open the /dev/console on the rootfs, this should never fail */
+-	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
+-		printk(KERN_WARNING "Warning: unable to open an initial console.\n");
++	char *console = "/dev/console";
+ 
++	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0) {
++		sys_mknod(console, S_IFCHR|0600, (TTYAUX_MAJOR<<8)|1);
++		if (sys_open(console, O_RDWR, 0) < 0)
++			printk(KERN_WARNING "Warning: unable to open an initial console.\n");
++		sys_unlink(console);
++	}
+ 	(void) sys_dup(0);
+ 	(void) sys_dup(0);
+ 	/*
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-006_enable_utf8.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-006_enable_utf8.patch
new file mode 100644
index 0000000..bee1cf3
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-006_enable_utf8.patch
@@ -0,0 +1,25 @@
+diff -Naur linux-2.6.31-rc4.orig/fs/fat/inode.c linux-2.6.31-rc4/fs/fat/inode.c
+--- linux-2.6.31-rc4.orig/fs/fat/inode.c	2009-07-25 12:47:41.000000000 +0200
++++ linux-2.6.31-rc4/fs/fat/inode.c	2009-07-25 13:38:18.000000000 +0200
+@@ -979,7 +979,8 @@
+ 	}
+ 	opts->name_check = 'n';
+ 	opts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;
+-	opts->utf8 = opts->unicode_xlate = 0;
++	opts->utf8 = 1;
++	opts->unicode_xlate = 0;
+ 	opts->numtail = 1;
+ 	opts->usefree = opts->nocase = 0;
+ 	opts->tz_utc = 0;
+diff -Naur linux-2.6.31-rc4.orig/fs/isofs/inode.c linux-2.6.31-rc4/fs/isofs/inode.c
+--- linux-2.6.31-rc4.orig/fs/isofs/inode.c	2009-07-25 12:47:41.000000000 +0200
++++ linux-2.6.31-rc4/fs/isofs/inode.c	2009-07-25 13:38:49.000000000 +0200
+@@ -377,7 +377,7 @@
+ 	popt->gid = 0;
+ 	popt->uid = 0;
+ 	popt->iocharset = NULL;
+-	popt->utf8 = 0;
++	popt->utf8 = 1;
+ 	popt->overriderockperm = 0;
+ 	popt->session=-1;
+ 	popt->sbsector=-1;
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-010-perf_crosscompiling.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-010-perf_crosscompiling.patch
new file mode 100644
index 0000000..25601fc
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-010-perf_crosscompiling.patch
@@ -0,0 +1,14 @@
+diff --git a/tools/perf/Makefile b/tools/perf/Makefile
+index b0f164b..ecb1af6 100644
+--- a/tools/perf/Makefile
++++ b/tools/perf/Makefile
+@@ -637,8 +637,6 @@
+ 	ifneq ($(call try-cc,$(SOURCE_NEWT),$(FLAGS_NEWT),libnewt),y)
+ 		msg := $(warning newt not found, disables TUI support. Please install newt-devel or libnewt-dev);
+ 	else
+-		# Fedora has /usr/include/slang/slang.h, but ubuntu /usr/include/slang.h
+-		BASIC_CFLAGS += -I/usr/include/slang
+ 		BASIC_CFLAGS += -DNEWT_SUPPORT
+ 		EXTLIBS += -lnewt -lslang
+ 		LIB_OBJS += $(OUTPUT)ui/browser.o
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-055-add_Formosa_eHome_Infrared_Receiver.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-055-add_Formosa_eHome_Infrared_Receiver.patch
new file mode 100644
index 0000000..e2afb63
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-055-add_Formosa_eHome_Infrared_Receiver.patch
@@ -0,0 +1,11 @@
+--- linux-3.2.2.orig/drivers/media/rc/mceusb.c	2012-01-30 23:37:12.374473509 +0100
++++ linux-3.2.2/drivers/media/rc/mceusb.c	2012-01-30 23:40:57.989652931 +0100
+@@ -350,6 +350,8 @@
+ 	{ USB_DEVICE(VENDOR_FORMOSA, 0xe015) },
+ 	/* Formosa21 / eHome Infrared Receiver */
+ 	{ USB_DEVICE(VENDOR_FORMOSA, 0xe016) },
++	/* Formosa21 / eHome Infrared Receiver */
++	{ USB_DEVICE(VENDOR_FORMOSA, 0xe042) },
+ 	/* Formosa aim / Trust MCE Infrared Receiver */
+ 	{ USB_DEVICE(VENDOR_FORMOSA, 0xe017),
+ 	  .driver_info = MCE_GEN2_NO_TX },
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-056-add_Adaptec_eHome_Infrared_Receiver.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-056-add_Adaptec_eHome_Infrared_Receiver.patch
new file mode 100644
index 0000000..461a82e
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-056-add_Adaptec_eHome_Infrared_Receiver.patch
@@ -0,0 +1,20 @@
+diff -Naur linux-3.6.7/drivers/media/rc/mceusb.c linux-3.6.7.patch/drivers/media/rc/mceusb.c
+--- linux-3.6.7/drivers/media/rc/mceusb.c	2012-11-29 04:45:51.142129739 +0100
++++ linux-3.6.7.patch/drivers/media/rc/mceusb.c	2012-11-29 04:51:30.982828558 +0100
+@@ -200,6 +200,7 @@
+ #define VENDOR_TIVO		0x105a
+ #define VENDOR_CONEXANT		0x0572
+ #define VENDOR_TWISTEDMELON	0x2596
++#define VENDOR_ADAPTEC		0x03f3
+ 
+ enum mceusb_model_type {
+ 	MCE_GEN2 = 0,		/* Most boards */
+@@ -400,6 +401,8 @@
+ 	{ USB_DEVICE(VENDOR_TWISTEDMELON, 0x8016) },
+ 	/* Twisted Melon Inc. - Manta Transceiver */
+ 	{ USB_DEVICE(VENDOR_TWISTEDMELON, 0x8042) },
++	/* Adaptec / HP eHome Receiver */
++	{ USB_DEVICE(VENDOR_ADAPTEC, 0x0094) },
+ 	/* Terminating entry */
+ 	{ }
+ };
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-Removed-MCE-customer-code-restriction-in-rc6-decode.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-Removed-MCE-customer-code-restriction-in-rc6-decode.patch
new file mode 100644
index 0000000..9f84e66
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-Removed-MCE-customer-code-restriction-in-rc6-decode.patch
@@ -0,0 +1,22 @@
+--- linux/drivers/media/rc/ir-rc6-decoder.c	2012-11-25 22:08:13.148418669 -0800
++++ linux.patch/drivers/media/rc/ir-rc6-decoder.c	2012-11-25 22:07:48.864417975 -0800
+@@ -39,7 +39,6 @@
+ #define RC6_STARTBIT_MASK	0x08	/* for the header bits */
+ #define RC6_6A_MCE_TOGGLE_MASK	0x8000	/* for the body bits */
+ #define RC6_6A_LCC_MASK		0xffff0000 /* RC6-6A-32 long customer code mask */
+-#define RC6_6A_MCE_CC		0x800f0000 /* MCE customer code */
+ #ifndef CHAR_BIT
+ #define CHAR_BIT 8	/* Normally in <limits.h> */
+ #endif
+@@ -242,9 +241,8 @@ again:
+ 			}
+ 
+ 			scancode = data->body;
+-			if (data->count == RC6_6A_32_NBITS &&
+-					(scancode & RC6_6A_LCC_MASK) == RC6_6A_MCE_CC) {
+-				/* MCE RC */
++			if (data->count == RC6_6A_32_NBITS) {
++				/* MCE compatible RC */
+ 				toggle = (scancode & RC6_6A_MCE_TOGGLE_MASK) ? 1 : 0;
+ 				scancode &= ~RC6_6A_MCE_TOGGLE_MASK;
+ 			} else {
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-add_SMK_Manufacturing_Inc_Infrared_Receiver.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-add_SMK_Manufacturing_Inc_Infrared_Receiver.patch
new file mode 100644
index 0000000..67fc7a0
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-057-add_SMK_Manufacturing_Inc_Infrared_Receiver.patch
@@ -0,0 +1,13 @@
+diff -Naur linux-3.9.4/drivers/media/rc/mceusb.c linux-3.9.4.patch/drivers/media/rc/mceusb.c
+--- linux-3.9.4/drivers/media/rc/mceusb.c	2013-05-24 20:45:59.000000000 +0200
++++ linux-3.9.4.patch/drivers/media/rc/mceusb.c	2013-05-27 12:28:12.811230633 +0200
+@@ -309,6 +309,9 @@
+ 	/* SMK/I-O Data GV-MC7/RCKIT Receiver */
+ 	{ USB_DEVICE(VENDOR_SMK, 0x0353),
+ 	  .driver_info = MCE_GEN2_NO_TX },
++	/* SMK Manufacturing, Inc. Receiver */
++	{ USB_DEVICE(VENDOR_SMK, 0x0357),
++         .driver_info = MCE_GEN2_NO_TX },
+ 	/* Tatung eHome Infrared Transceiver */
+ 	{ USB_DEVICE(VENDOR_TATUNG, 0x9150) },
+ 	/* Shuttle eHome Infrared Transceiver */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.01-HID-Sony-upstream_patches.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.01-HID-Sony-upstream_patches.patch
new file mode 100644
index 0000000..82f2f33
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.01-HID-Sony-upstream_patches.patch
@@ -0,0 +1,615 @@
+diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
+index b545124..419b7ca 100644
+--- a/drivers/hid/Makefile
++++ b/drivers/hid/Makefile
+@@ -92,7 +92,6 @@ hid-picolcd-y			+= hid-picolcd_debugfs.o
+ endif
+ 
+ obj-$(CONFIG_HID_PRIMAX)	+= hid-primax.o
+-obj-$(CONFIG_HID_PS3REMOTE)	+= hid-ps3remote.o
+ obj-$(CONFIG_HID_ROCCAT)	+= hid-roccat.o hid-roccat-common.o \
+ 	hid-roccat-arvo.o hid-roccat-isku.o hid-roccat-kone.o \
+ 	hid-roccat-koneplus.o hid-roccat-konepure.o hid-roccat-kovaplus.o \
+diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
+index b885a28..37e35c0 100644
+--- a/drivers/hid/hid-core.c
++++ b/drivers/hid/hid-core.c
+@@ -1683,6 +1683,8 @@ static const struct hid_device_id hid_have_special_driver[] = {
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
++	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER) },
++	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER) },
+ 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },
+diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
+index 56b224e..c11cca1 100644
+--- a/drivers/hid/hid-ids.h
++++ b/drivers/hid/hid-ids.h
+@@ -737,6 +737,8 @@
+ #define USB_DEVICE_ID_SONY_PS3_BDREMOTE		0x0306
+ #define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
+ #define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
++#define USB_DEVICE_ID_SONY_BUZZ_CONTROLLER		0x0002
++#define USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER	0x1000
+ 
+ #define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
+ #define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
+diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c
+index 312098e..83f9629 100644
+--- a/drivers/hid/hid-sony.c
++++ b/drivers/hid/hid-sony.c
+@@ -1,11 +1,13 @@
+ /*
+- *  HID driver for some sony "special" devices
++ *  HID driver for Sony / PS2 / PS3 BD devices.
+  *
+  *  Copyright (c) 1999 Andreas Gal
+  *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
+  *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
+  *  Copyright (c) 2008 Jiri Slaby
+- *  Copyright (c) 2006-2008 Jiri Kosina
++ *  Copyright (c) 2012 David Dillow <dave@thedillows.org>
++ *  Copyright (c) 2006-2013 Jiri Kosina
++ *  Copyright (c) 2013 Colin Leitner <colin.leitner@gmail.com>
+  */
+ 
+ /*
+@@ -15,17 +17,28 @@
+  * any later version.
+  */
+ 
++/* NOTE: in order for the Sony PS3 BD Remote Control to be found by
++ * a Bluetooth host, the key combination Start+Enter has to be kept pressed
++ * for about 7 seconds with the Bluetooth Host Controller in discovering mode.
++ *
++ * There will be no PIN request from the device.
++ */
++
+ #include <linux/device.h>
+ #include <linux/hid.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/usb.h>
++#include "usbhid/usbhid.h"
++#include <linux/leds.h>
+ 
+ #include "hid-ids.h"
+ 
+ #define VAIO_RDESC_CONSTANT     (1 << 0)
+ #define SIXAXIS_CONTROLLER_USB  (1 << 1)
+ #define SIXAXIS_CONTROLLER_BT   (1 << 2)
++#define BUZZ_CONTROLLER         (1 << 3)
++#define PS3REMOTE		(1 << 4)
+ 
+ static const u8 sixaxis_rdesc_fixup[] = {
+ 	0x95, 0x13, 0x09, 0x01, 0x81, 0x02, 0x95, 0x0C,
+@@ -55,10 +68,214 @@ static const u8 sixaxis_rdesc_fixup2[] = {
+ 	0xb1, 0x02, 0xc0, 0xc0,
+ };
+ 
++static __u8 ps3remote_rdesc[] = {
++	0x05, 0x01,          /* GUsagePage Generic Desktop */
++	0x09, 0x05,          /* LUsage 0x05 [Game Pad] */
++	0xA1, 0x01,          /* MCollection Application (mouse, keyboard) */
++
++	 /* Use collection 1 for joypad buttons */
++	 0xA1, 0x02,         /* MCollection Logical (interrelated data) */
++
++	  /* Ignore the 1st byte, maybe it is used for a controller
++	   * number but it's not needed for correct operation */
++	  0x75, 0x08,        /* GReportSize 0x08 [8] */
++	  0x95, 0x01,        /* GReportCount 0x01 [1] */
++	  0x81, 0x01,        /* MInput 0x01 (Const[0] Arr[1] Abs[2]) */
++
++	  /* Bytes from 2nd to 4th are a bitmap for joypad buttons, for these
++	   * buttons multiple keypresses are allowed */
++	  0x05, 0x09,        /* GUsagePage Button */
++	  0x19, 0x01,        /* LUsageMinimum 0x01 [Button 1 (primary/trigger)] */
++	  0x29, 0x18,        /* LUsageMaximum 0x18 [Button 24] */
++	  0x14,              /* GLogicalMinimum [0] */
++	  0x25, 0x01,        /* GLogicalMaximum 0x01 [1] */
++	  0x75, 0x01,        /* GReportSize 0x01 [1] */
++	  0x95, 0x18,        /* GReportCount 0x18 [24] */
++	  0x81, 0x02,        /* MInput 0x02 (Data[0] Var[1] Abs[2]) */
++
++	  0xC0,              /* MEndCollection */
++
++	 /* Use collection 2 for remote control buttons */
++	 0xA1, 0x02,         /* MCollection Logical (interrelated data) */
++
++	  /* 5th byte is used for remote control buttons */
++	  0x05, 0x09,        /* GUsagePage Button */
++	  0x18,              /* LUsageMinimum [No button pressed] */
++	  0x29, 0xFE,        /* LUsageMaximum 0xFE [Button 254] */
++	  0x14,              /* GLogicalMinimum [0] */
++	  0x26, 0xFE, 0x00,  /* GLogicalMaximum 0x00FE [254] */
++	  0x75, 0x08,        /* GReportSize 0x08 [8] */
++	  0x95, 0x01,        /* GReportCount 0x01 [1] */
++	  0x80,              /* MInput  */
++
++	  /* Ignore bytes from 6th to 11th, 6th to 10th are always constant at
++	   * 0xff and 11th is for press indication */
++	  0x75, 0x08,        /* GReportSize 0x08 [8] */
++	  0x95, 0x06,        /* GReportCount 0x06 [6] */
++	  0x81, 0x01,        /* MInput 0x01 (Const[0] Arr[1] Abs[2]) */
++
++	  /* 12th byte is for battery strength */
++	  0x05, 0x06,        /* GUsagePage Generic Device Controls */
++	  0x09, 0x20,        /* LUsage 0x20 [Battery Strength] */
++	  0x14,              /* GLogicalMinimum [0] */
++	  0x25, 0x05,        /* GLogicalMaximum 0x05 [5] */
++	  0x75, 0x08,        /* GReportSize 0x08 [8] */
++	  0x95, 0x01,        /* GReportCount 0x01 [1] */
++	  0x81, 0x02,        /* MInput 0x02 (Data[0] Var[1] Abs[2]) */
++
++	  0xC0,              /* MEndCollection */
++
++	 0xC0                /* MEndCollection [Game Pad] */
++};
++
++static const unsigned int ps3remote_keymap_joypad_buttons[] = {
++	[0x01] = KEY_SELECT,
++	[0x02] = BTN_THUMBL,		/* L3 */
++	[0x03] = BTN_THUMBR,		/* R3 */
++	[0x04] = BTN_START,
++	[0x05] = KEY_UP,
++	[0x06] = KEY_RIGHT,
++	[0x07] = KEY_DOWN,
++	[0x08] = KEY_LEFT,
++	[0x09] = BTN_TL2,		/* L2 */
++	[0x0a] = BTN_TR2,		/* R2 */
++	[0x0b] = BTN_TL,		/* L1 */
++	[0x0c] = BTN_TR,		/* R1 */
++	[0x0d] = KEY_OPTION,		/* options/triangle */
++	[0x0e] = KEY_BACK,		/* back/circle */
++	[0x0f] = BTN_0,			/* cross */
++	[0x10] = KEY_SCREEN,		/* view/square */
++	[0x11] = KEY_HOMEPAGE,		/* PS button */
++	[0x14] = KEY_ENTER,
++};
++static const unsigned int ps3remote_keymap_remote_buttons[] = {
++	[0x00] = KEY_1,
++	[0x01] = KEY_2,
++	[0x02] = KEY_3,
++	[0x03] = KEY_4,
++	[0x04] = KEY_5,
++	[0x05] = KEY_6,
++	[0x06] = KEY_7,
++	[0x07] = KEY_8,
++	[0x08] = KEY_9,
++	[0x09] = KEY_0,
++	[0x0e] = KEY_ESC,		/* return */
++	[0x0f] = KEY_CLEAR,
++	[0x16] = KEY_EJECTCD,
++	[0x1a] = KEY_MENU,		/* top menu */
++	[0x28] = KEY_TIME,
++	[0x30] = KEY_PREVIOUS,
++	[0x31] = KEY_NEXT,
++	[0x32] = KEY_PLAY,
++	[0x33] = KEY_REWIND,		/* scan back */
++	[0x34] = KEY_FORWARD,		/* scan forward */
++	[0x38] = KEY_STOP,
++	[0x39] = KEY_PAUSE,
++	[0x40] = KEY_CONTEXT_MENU,	/* pop up/menu */
++	[0x60] = KEY_FRAMEBACK,		/* slow/step back */
++	[0x61] = KEY_FRAMEFORWARD,	/* slow/step forward */
++	[0x63] = KEY_SUBTITLE,
++	[0x64] = KEY_AUDIO,
++	[0x65] = KEY_ANGLE,
++	[0x70] = KEY_INFO,		/* display */
++	[0x80] = KEY_BLUE,
++	[0x81] = KEY_RED,
++	[0x82] = KEY_GREEN,
++	[0x83] = KEY_YELLOW,
++};
++
++static const unsigned int buzz_keymap[] = {
++	/* The controller has 4 remote buzzers, each with one LED and 5
++	 * buttons.
++	 * 
++	 * We use the mapping chosen by the controller, which is:
++	 *
++	 * Key          Offset
++	 * -------------------
++	 * Buzz              1
++	 * Blue              5
++	 * Orange            4
++	 * Green             3
++	 * Yellow            2
++	 *
++	 * So, for example, the orange button on the third buzzer is mapped to
++	 * BTN_TRIGGER_HAPPY14
++	 */
++	[ 1] = BTN_TRIGGER_HAPPY1,
++	[ 2] = BTN_TRIGGER_HAPPY2,
++	[ 3] = BTN_TRIGGER_HAPPY3,
++	[ 4] = BTN_TRIGGER_HAPPY4,
++	[ 5] = BTN_TRIGGER_HAPPY5,
++	[ 6] = BTN_TRIGGER_HAPPY6,
++	[ 7] = BTN_TRIGGER_HAPPY7,
++	[ 8] = BTN_TRIGGER_HAPPY8,
++	[ 9] = BTN_TRIGGER_HAPPY9,
++	[10] = BTN_TRIGGER_HAPPY10,
++	[11] = BTN_TRIGGER_HAPPY11,
++	[12] = BTN_TRIGGER_HAPPY12,
++	[13] = BTN_TRIGGER_HAPPY13,
++	[14] = BTN_TRIGGER_HAPPY14,
++	[15] = BTN_TRIGGER_HAPPY15,
++	[16] = BTN_TRIGGER_HAPPY16,
++	[17] = BTN_TRIGGER_HAPPY17,
++	[18] = BTN_TRIGGER_HAPPY18,
++	[19] = BTN_TRIGGER_HAPPY19,
++	[20] = BTN_TRIGGER_HAPPY20,
++};
++
+ struct sony_sc {
+ 	unsigned long quirks;
++
++	void *extra;
+ };
+ 
++struct buzz_extra {
++	int led_state;
++	struct led_classdev *leds[4];
++};
++
++static __u8 *ps3remote_fixup(struct hid_device *hdev, __u8 *rdesc,
++			     unsigned int *rsize)
++{
++	*rsize = sizeof(ps3remote_rdesc);
++	return ps3remote_rdesc;
++}
++
++static int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,
++			     struct hid_field *field, struct hid_usage *usage,
++			     unsigned long **bit, int *max)
++{
++	unsigned int key = usage->hid & HID_USAGE;
++
++	if ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)
++		return -1;
++
++	switch (usage->collection_index) {
++	case 1:
++		if (key >= ARRAY_SIZE(ps3remote_keymap_joypad_buttons))
++			return -1;
++
++		key = ps3remote_keymap_joypad_buttons[key];
++		if (!key)
++			return -1;
++		break;
++	case 2:
++		if (key >= ARRAY_SIZE(ps3remote_keymap_remote_buttons))
++			return -1;
++
++		key = ps3remote_keymap_remote_buttons[key];
++		if (!key)
++			return -1;
++		break;
++	default:
++		return -1;
++	}
++
++	hid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);
++	return 1;
++}
++
++
+ /* Sony Vaio VGX has wrongly mouse pointer declared as constant */
+ static __u8 *sony_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+ 		unsigned int *rsize)
+@@ -95,6 +312,10 @@ static __u8 *sony_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+ 		*rsize = sizeof(sixaxis_rdesc_fixup2);
+ 		memcpy(rdesc, &sixaxis_rdesc_fixup2, *rsize);
+ 	}
++
++	if (sc->quirks & PS3REMOTE)
++		return ps3remote_fixup(hdev, rdesc, rsize);
++
+ 	return rdesc;
+ }
+ 
+@@ -117,6 +338,41 @@ static int sony_raw_event(struct hid_device *hdev, struct hid_report *report,
+ 	return 0;
+ }
+ 
++static int sony_mapping(struct hid_device *hdev, struct hid_input *hi,
++			struct hid_field *field, struct hid_usage *usage,
++			unsigned long **bit, int *max)
++{
++	struct sony_sc *sc = hid_get_drvdata(hdev);
++
++	if (sc->quirks & BUZZ_CONTROLLER) {
++		unsigned int key = usage->hid & HID_USAGE;
++
++		if ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)
++			return -1;
++
++		switch (usage->collection_index) {
++		case 1:
++			if (key >= ARRAY_SIZE(buzz_keymap))
++				return -1;
++
++			key = buzz_keymap[key];
++			if (!key)
++				return -1;
++			break;
++		default:
++			return -1;
++		}
++
++		hid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);
++		return 1;
++	}
++
++	if (sc->quirks & PS3REMOTE)
++		return ps3remote_mapping(hdev, hi, field, usage, bit, max);
++
++	return -1;
++}
++
+ /*
+  * The Sony Sixaxis does not handle HID Output Reports on the Interrupt EP
+  * like it should according to usbhid/hid-core.c::usbhid_output_raw_report()
+@@ -192,11 +448,181 @@ static int sixaxis_set_operational_bt(struct hid_device *hdev)
+ 	return hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);
+ }
+ 
++static void buzz_set_leds(struct hid_device *hdev, int leds)
++{
++	struct list_head *report_list =
++		&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
++	struct hid_report *report = list_entry(report_list->next,
++		struct hid_report, list);
++	__s32 *value = report->field[0]->value;
++
++	value[0] = 0x00;
++	value[1] = (leds & 1) ? 0xff : 0x00;
++	value[2] = (leds & 2) ? 0xff : 0x00;
++	value[3] = (leds & 4) ? 0xff : 0x00;
++	value[4] = (leds & 8) ? 0xff : 0x00;
++	value[5] = 0x00;
++	value[6] = 0x00;
++	hid_hw_request(hdev, report, HID_REQ_SET_REPORT);
++}
++
++static void buzz_led_set_brightness(struct led_classdev *led,
++				    enum led_brightness value)
++{
++	struct device *dev = led->dev->parent;
++	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
++	struct sony_sc *drv_data;
++	struct buzz_extra *buzz;
++
++	int n;
++
++	drv_data = hid_get_drvdata(hdev);
++	if (!drv_data || !drv_data->extra) {
++		hid_err(hdev, "No device data\n");
++		return;
++	}
++	buzz = drv_data->extra;
++
++	for (n = 0; n < 4; n++) {
++		if (led == buzz->leds[n]) {
++			int on = !! (buzz->led_state & (1 << n));
++			if (value == LED_OFF && on) {
++				buzz->led_state &= ~(1 << n);
++				buzz_set_leds(hdev, buzz->led_state);
++			} else if (value != LED_OFF && !on) {
++				buzz->led_state |= (1 << n);
++				buzz_set_leds(hdev, buzz->led_state);
++			}
++			break;
++		}
++	}
++}
++
++static enum led_brightness buzz_led_get_brightness(struct led_classdev *led)
++{
++	struct device *dev = led->dev->parent;
++	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
++	struct sony_sc *drv_data;
++	struct buzz_extra *buzz;
++
++	int n;
++	int on = 0;
++
++	drv_data = hid_get_drvdata(hdev);
++	if (!drv_data || !drv_data->extra) {
++		hid_err(hdev, "No device data\n");
++		return LED_OFF;
++	}
++	buzz = drv_data->extra;
++
++	for (n = 0; n < 4; n++) {
++		if (led == buzz->leds[n]) {
++			on = !! (buzz->led_state & (1 << n));
++			break;
++		}
++	}
++
++	return on ? LED_FULL : LED_OFF;
++}
++
++static int buzz_init(struct hid_device *hdev)
++{
++	struct sony_sc *drv_data;
++	struct buzz_extra *buzz;
++	int n, ret = 0;
++	struct led_classdev *led;
++	size_t name_sz;
++	char *name;
++
++	drv_data = hid_get_drvdata(hdev);
++	BUG_ON(!(drv_data->quirks & BUZZ_CONTROLLER));
++
++	buzz = kzalloc(sizeof(*buzz), GFP_KERNEL);
++	if (!buzz) {
++		hid_err(hdev, "Insufficient memory, cannot allocate driver data\n");
++		return -ENOMEM;
++	}
++	drv_data->extra = buzz;
++
++	/* Clear LEDs as we have no way of reading their initial state. This is
++	 * only relevant if the driver is loaded after somebody actively set the
++	 * LEDs to on */
++	buzz_set_leds(hdev, 0x00);
++
++	name_sz = strlen(dev_name(&hdev->dev)) + strlen("::buzz#") + 1;
++
++	for (n = 0; n < 4; n++) {
++		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
++		if (!led) {
++			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
++			goto error_leds;
++		}
++
++		name = (void *)(&led[1]);
++		snprintf(name, name_sz, "%s::buzz%d", dev_name(&hdev->dev), n + 1);
++		led->name = name;
++		led->brightness = 0;
++		led->max_brightness = 1;
++		led->brightness_get = buzz_led_get_brightness;
++		led->brightness_set = buzz_led_set_brightness;
++
++		if (led_classdev_register(&hdev->dev, led)) {
++			hid_err(hdev, "Failed to register LED %d\n", n);
++			kfree(led);
++			goto error_leds;
++		}
++
++		buzz->leds[n] = led;
++	}
++
++	return ret;
++
++error_leds:
++	for (n = 0; n < 4; n++) {
++		led = buzz->leds[n];
++		buzz->leds[n] = NULL;
++		if (!led)
++			continue;
++		led_classdev_unregister(led);
++		kfree(led);
++	}
++
++	kfree(drv_data->extra);
++	drv_data->extra = NULL;
++	return ret;
++}
++
++static void buzz_remove(struct hid_device *hdev)
++{
++	struct sony_sc *drv_data;
++	struct buzz_extra *buzz;
++	struct led_classdev *led;
++	int n;
++
++	drv_data = hid_get_drvdata(hdev);
++	BUG_ON(!(drv_data->quirks & BUZZ_CONTROLLER));
++
++	buzz = drv_data->extra;
++
++	for (n = 0; n < 4; n++) {
++		led = buzz->leds[n];
++		buzz->leds[n] = NULL;
++		if (!led)
++			continue;
++		led_classdev_unregister(led);
++		kfree(led);
++	}
++
++	kfree(drv_data->extra);
++	drv_data->extra = NULL;
++}
++
+ static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
+ {
+ 	int ret;
+ 	unsigned long quirks = id->driver_data;
+ 	struct sony_sc *sc;
++	unsigned int connect_mask = HID_CONNECT_DEFAULT;
+ 
+ 	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+ 	if (sc == NULL) {
+@@ -213,8 +639,14 @@ static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
+ 		goto err_free;
+ 	}
+ 
+-	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT |
+-			HID_CONNECT_HIDDEV_FORCE);
++	if (sc->quirks & VAIO_RDESC_CONSTANT)
++		connect_mask |= HID_CONNECT_HIDDEV_FORCE;
++	else if (sc->quirks & SIXAXIS_CONTROLLER_USB)
++		connect_mask |= HID_CONNECT_HIDDEV_FORCE;
++	else if (sc->quirks & SIXAXIS_CONTROLLER_BT)
++		connect_mask |= HID_CONNECT_HIDDEV_FORCE;
++
++	ret = hid_hw_start(hdev, connect_mask);
+ 	if (ret) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto err_free;
+@@ -226,6 +658,8 @@ static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
+ 	}
+ 	else if (sc->quirks & SIXAXIS_CONTROLLER_BT)
+ 		ret = sixaxis_set_operational_bt(hdev);
++	else if (sc->quirks & BUZZ_CONTROLLER)
++		ret = buzz_init(hdev);
+ 	else
+ 		ret = 0;
+ 
+@@ -242,8 +676,13 @@ err_free:
+ 
+ static void sony_remove(struct hid_device *hdev)
+ {
++	struct sony_sc *sc = hid_get_drvdata(hdev);
++
++	if (sc->quirks & BUZZ_CONTROLLER)
++		buzz_remove(hdev);
++
+ 	hid_hw_stop(hdev);
+-	kfree(hid_get_drvdata(hdev));
++	kfree(sc);
+ }
+ 
+ static const struct hid_device_id sony_devices[] = {
+@@ -257,17 +696,30 @@ static const struct hid_device_id sony_devices[] = {
+ 		.driver_data = VAIO_RDESC_CONSTANT },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE),
+ 		.driver_data = VAIO_RDESC_CONSTANT },
++	/* Wired Buzz Controller. Reported as Sony Hub from its USB ID and as
++	 * Logitech joystick from the device descriptor. */
++	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER),
++		.driver_data = BUZZ_CONTROLLER },
++	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER),
++		.driver_data = BUZZ_CONTROLLER },
++	/* PS3 BD Remote Control */
++	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE),
++		.driver_data = PS3REMOTE },
++	/* Logitech Harmony Adapter for PS3 */
++	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3),
++		.driver_data = PS3REMOTE },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(hid, sony_devices);
+ 
+ static struct hid_driver sony_driver = {
+-	.name = "sony",
+-	.id_table = sony_devices,
+-	.probe = sony_probe,
+-	.remove = sony_remove,
+-	.report_fixup = sony_report_fixup,
+-	.raw_event = sony_raw_event
++	.name          = "sony",
++	.id_table      = sony_devices,
++	.input_mapping = sony_mapping,
++	.probe         = sony_probe,
++	.remove        = sony_remove,
++	.report_fixup  = sony_report_fixup,
++	.raw_event     = sony_raw_event
+ };
+ module_hid_driver(sony_driver);
+ 
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.05-hid_sony-add_autorepeat_for_PS3_remotes.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.05-hid_sony-add_autorepeat_for_PS3_remotes.patch
new file mode 100644
index 0000000..abdc74f
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.05-hid_sony-add_autorepeat_for_PS3_remotes.patch
@@ -0,0 +1,61 @@
+Betreff: [RFC] hid/sony: add autorepeat for PS3 remotes
+Von: David Dillow <dave@thedillows.org>
+Datum: 28.06.2013 04:28
+An: linux-input@vger.kernel.org
+Kopie (CC): Stephan Raue <stephan@openelec.tv>
+
+Some applications using the PS3 remote would like to have autorepeat
+from the device. Use the input subsystem's software emulation to provide
+this capability, and enable those that don't need it to turn it off.
+---
+I'm not sure this is the correct approach, or if it is even appropriate
+for a remote to do autorepeat. However, the media/rc subsystem does do
+it by default, and it's been requested by users, so there is at least
+some demand.
+
+This compiled against the hid-sony driver with the PS3 remote changes
+merged, but I have done no testing of it. If the approach seems
+reasonable, I'll try to test it when the MythTV is idle.
+
+ drivers/hid/hid-sony.c | 20 ++++++++++++++++++++
+ 1 file changed, 20 insertions(+)
+diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c
+index ecbc749..0bbcd07 100644
+--- a/drivers/hid/hid-sony.c
++++ b/drivers/hid/hid-sony.c
+@@ -274,6 +274,24 @@ static int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,
+ 	return 1;
+ }
+ 
++static int ps3remote_setup_repeat(struct hid_device *hdev)
++{
++	struct hid_input *hidinput = list_first_entry(&hdev->inputs,
++						      struct hid_input, list);
++	struct input_dev *input = hidinput->input;
++
++	/*
++	 * Set up autorepeat defaults per the remote control subsystem;
++	 * this must be done after hid_hw_start(), as having these non-zero
++	 * at the time of input_register_device() tells the input system that
++	 * the hardware does the autorepeat, and the PS3 remote does not.
++	 */
++	set_bit(EV_REP, input->evbit);
++	input->rep[REP_DELAY]  = 500;
++	input->rep[REP_PERIOD] = 125;
++
++	return 0;
++}
+ 
+ /* Sony Vaio VGX has wrongly mouse pointer declared as constant */
+ static __u8 *sony_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+@@ -659,6 +677,8 @@ static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
+ 		ret = sixaxis_set_operational_bt(hdev);
+ 	else if (sc->quirks & BUZZ_CONTROLLER)
+ 		ret = buzz_init(hdev);
++	else if (sc->quirks & PS3REMOTE)
++		ret = ps3remote_setup_repeat(hdev);
+ 	else
+ 		ret = 0;
+ 
+
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.06-hid_sony-add_SMK_link.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.06-hid_sony-add_SMK_link.patch
new file mode 100644
index 0000000..bc92ecf
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-058.06-hid_sony-add_SMK_link.patch
@@ -0,0 +1,47 @@
+commit 5a601d61d36236a667cc7d170b300d18dd6240c6
+Author: Juan J. Sierralta <sierralta@gmail.com>
+Date:   Sun Jul 28 09:26:04 2013 +0300
+
+    Add support for SMK-Link PS3 remote
+
+diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
+index 396d24d..9eb7129 100644
+--- a/drivers/hid/hid-core.c
++++ b/drivers/hid/hid-core.c
+@@ -1686,6 +1686,7 @@ static const struct hid_device_id hid_have_special_driver[] = {
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
++	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER) },
+ 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },
+diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
+index dd0511e..2801df1 100644
+--- a/drivers/hid/hid-ids.h
++++ b/drivers/hid/hid-ids.h
+@@ -734,6 +734,7 @@
+ #define USB_VENDOR_ID_SKYCABLE			0x1223
+ #define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
+ 
++#define USB_VENDOR_ID_SMK			0x0609
+ #define USB_VENDOR_ID_SONY			0x054c
+ #define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
+ #define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE	0x0374
+diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c
+index 8f425e2..614f057 100644
+--- a/drivers/hid/hid-sony.c
++++ b/drivers/hid/hid-sony.c
+@@ -728,8 +728,12 @@ static const struct hid_device_id sony_devices[] = {
+ 	/* Logitech Harmony Adapter for PS3 */
+ 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3),
+ 		.driver_data = PS3REMOTE },
++	/* SMK-Link Universal Remote Control VP3700 */
++	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SONY_PS3_BDREMOTE),
++		.driver_data = PS3REMOTE },
+ 	{ }
+ };
++
+ MODULE_DEVICE_TABLE(hid, sony_devices);
+ 
+ static struct hid_driver sony_driver = {
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-059-remove_some_xpad_pids-0.2.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-059-remove_some_xpad_pids-0.2.patch
new file mode 100644
index 0000000..4a6d1c7
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-059-remove_some_xpad_pids-0.2.patch
@@ -0,0 +1,11 @@
+diff -Naur linux-3.8.4/drivers/input/joystick/xpad.c linux-3.8.4.patch/drivers/input/joystick/xpad.c
+--- linux-3.8.4/drivers/input/joystick/xpad.c	2013-03-20 21:11:19.000000000 +0100
++++ linux-3.8.4.patch/drivers/input/joystick/xpad.c	2013-03-26 20:24:29.273978355 +0100
+@@ -174,7 +174,6 @@
+ 	{ 0x1bad, 0xf901, "Gamestop Xbox 360 Controller", 0, XTYPE_XBOX360 },
+ 	{ 0x1bad, 0xf903, "Tron Xbox 360 controller", 0, XTYPE_XBOX360 },
+ 	{ 0x24c6, 0x5300, "PowerA MINI PROEX Controller", 0, XTYPE_XBOX360 },
+-	{ 0xffff, 0xffff, "Chinese-made Xbox Controller", 0, XTYPE_XBOX },
+ 	{ 0x0000, 0x0000, "Generic X-Box pad", 0, XTYPE_UNKNOWN }
+ };
+ 
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-060-add_AUGUST_DVB-T205.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-060-add_AUGUST_DVB-T205.patch
new file mode 100644
index 0000000..2f003dd
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-060-add_AUGUST_DVB-T205.patch
@@ -0,0 +1,15 @@
+diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
+index 2cc8ec7..985fa11 100644
+--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
++++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
+@@ -1352,6 +1352,9 @@
+ 		&rtl2832u_props, "Dexatek DK mini DVB-T Dongle", NULL) },
+ 	{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x00d7,
+ 		&rtl2832u_props, "TerraTec Cinergy T Stick+", NULL) },
++	{ DVB_USB_DEVICE(USB_VID_GTEK, 0xa803,
++		&rtl2832u_props, "Realtek RTL2832U reference design", NULL) },
++
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(usb, rtl28xxu_id_table);
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-061-valve-xpad-rework.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-061-valve-xpad-rework.patch
new file mode 100644
index 0000000..c485a63
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-061-valve-xpad-rework.patch
@@ -0,0 +1,462 @@
+--- a/drivers/input/joystick/xpad.c	2016-11-02 11:32:23.105562200 +0100
++++ b/drivers/input/joystick/xpad.c	2016-11-02 11:33:00.065676100 +0100
+@@ -281,17 +281,21 @@ struct usb_xpad {
+ 	struct urb *irq_out;		/* urb for interrupt out report */
+ 	unsigned char *odata;		/* output data */
+ 	dma_addr_t odata_dma;
+-	struct mutex odata_mutex;
++	spinlock_t odata_lock;
+ #endif
+ 
+ #if defined(CONFIG_JOYSTICK_XPAD_LEDS)
+ 	struct xpad_led *led;
+ #endif
++	
++	int joydev_id;
+ 
+ 	char phys[64];			/* physical device path */
+ 
+ 	int mapping;			/* map d-pad to buttons or to axes */
+ 	int xtype;			/* type of xbox device */
++	
++	const char *name;
+ };
+ 
+ /*
+@@ -435,6 +439,109 @@ static void xpad360_process_packet(struc
+ 
+ 	input_sync(dev);
+ }
++static void xpad_send_led_command(struct usb_xpad *xpad, int command);
++static int xpad_open(struct input_dev *dev);
++static void xpad_close(struct input_dev *dev);
++static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs);
++static int xpad_init_ff(struct usb_xpad *xpad);
++static int xpad_find_joydev(struct device *dev, void *data)
++{
++	if (strstr(dev_name(dev), "js"))
++		return 1;
++	
++	return 0;
++}
++
++static struct workqueue_struct *my_wq;
++
++typedef struct {
++	struct work_struct my_work;
++	struct usb_xpad *xpad;
++} my_work_t;
++
++static void my_wq_function( struct work_struct *work)
++{
++	my_work_t *my_work = (my_work_t *)work;
++	
++	struct usb_xpad *xpad = my_work->xpad;
++	
++	if (xpad->pad_present) {
++		
++		struct input_dev *input_dev;
++		int i;
++		
++		input_dev = input_allocate_device();
++
++		xpad->dev = input_dev;
++		input_dev->name = xpad->name;
++		input_dev->phys = xpad->phys;
++		usb_to_input_id(xpad->udev, &input_dev->id);
++		input_dev->dev.parent = &xpad->intf->dev;
++		
++		input_set_drvdata(input_dev, xpad);
++		
++		input_dev->open = xpad_open;
++		input_dev->close = xpad_close;
++		
++		input_dev->evbit[0] = BIT_MASK(EV_KEY);
++		
++		if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
++			input_dev->evbit[0] |= BIT_MASK(EV_ABS);
++			/* set up axes */
++			for (i = 0; xpad_abs[i] >= 0; i++)
++				xpad_set_up_abs(input_dev, xpad_abs[i]);
++		}
++		
++		/* set up standard buttons */
++		for (i = 0; xpad_common_btn[i] >= 0; i++)
++			__set_bit(xpad_common_btn[i], input_dev->keybit);
++		
++		/* set up model-specific ones */
++		if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W) {
++			for (i = 0; xpad360_btn[i] >= 0; i++)
++				__set_bit(xpad360_btn[i], input_dev->keybit);
++		} else {
++			for (i = 0; xpad_btn[i] >= 0; i++)
++				__set_bit(xpad_btn[i], input_dev->keybit);
++		}
++		
++		if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
++			for (i = 0; xpad_btn_pad[i] >= 0; i++)
++				__set_bit(xpad_btn_pad[i], input_dev->keybit);
++		} else {
++			for (i = 0; xpad_abs_pad[i] >= 0; i++)
++				xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
++		}
++		
++		if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
++			for (i = 0; xpad_btn_triggers[i] >= 0; i++)
++				__set_bit(xpad_btn_triggers[i], input_dev->keybit);
++		} else {
++			for (i = 0; xpad_abs_triggers[i] >= 0; i++)
++				xpad_set_up_abs(input_dev, xpad_abs_triggers[i]);
++		}
++		
++		input_register_device(xpad->dev);
++		
++		{
++			struct device* joydev_dev = device_find_child(&xpad->dev->dev, NULL, xpad_find_joydev);
++			
++			if (joydev_dev) {
++// 				printk("found joydev child with minor %i\n", MINOR(joydev_dev->devt));
++				xpad->joydev_id = MINOR(joydev_dev->devt);
++				xpad_send_led_command(xpad, (xpad->joydev_id % 4) + 2);
++			}
++		}
++		
++		xpad_init_ff(xpad);
++	} else {
++		input_unregister_device(xpad->dev);
++	}
++	
++	kfree( (void *)work );
++	
++	return;
++}
+ 
+ /*
+  * xpad360w_process_packet
+@@ -456,11 +563,35 @@ static void xpad360w_process_packet(stru
+ 	/* Presence change */
+ 	if (data[0] & 0x08) {
+ 		if (data[1] & 0x80) {
+-			xpad->pad_present = 1;
+-			usb_submit_urb(xpad->bulk_out, GFP_ATOMIC);
+-		} else
+-			xpad->pad_present = 0;
++			
++			if (!xpad->pad_present)
++			{
++				my_work_t * work;
++				xpad->pad_present = 1;
++				usb_submit_urb(xpad->bulk_out, GFP_ATOMIC);
++				
++				work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);
++				INIT_WORK( (struct work_struct *)work, my_wq_function );
++				work->xpad = xpad;
++				queue_work( my_wq, (struct work_struct *)work );
++			}
++			
++		} else {
++			if (xpad->pad_present)
++			{
++				my_work_t * work;
++				xpad->pad_present = 0;
++
++				work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);
++				INIT_WORK( (struct work_struct *)work, my_wq_function );
++				work->xpad = xpad;
++				queue_work( my_wq, (struct work_struct *)work );
++			}
++// 			printk("got kill packet for id %i\n", xpad->joydev_id);
++		}
+ 	}
++	
++// 	printk("xpad packet %hhX %hhX %hhX %hhX %hhX %hhX\n", data[0], data[1], data[2], data[3], data[4], data[5]);
+ 
+ 	/* Valid pad data */
+ 	if (!(data[1] & 0x1))
+@@ -476,6 +607,8 @@ static void xpad_irq_in(struct urb *urb)
+ 	int retval, status;
+ 
+ 	status = urb->status;
++	
++// 	printk("xpad_irq_in %i\n", status);
+ 
+ 	switch (status) {
+ 	case 0:
+@@ -584,8 +717,6 @@ static int xpad_init_output(struct usb_i
+ 		goto fail1;
+ 	}
+ 
+-	mutex_init(&xpad->odata_mutex);
+-
+ 	xpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);
+ 	if (!xpad->irq_out) {
+ 		error = -ENOMEM;
+@@ -714,15 +845,38 @@ struct xpad_led {
+ 
+ static void xpad_send_led_command(struct usb_xpad *xpad, int command)
+ {
+-	if (command >= 0 && command < 14) {
+-		mutex_lock(&xpad->odata_mutex);
+-		xpad->odata[0] = 0x01;
+-		xpad->odata[1] = 0x03;
+-		xpad->odata[2] = command;
+-		xpad->irq_out->transfer_buffer_length = 3;
+-		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
+-		mutex_unlock(&xpad->odata_mutex);
++	if ((unsigned)command > 15)
++		return;
++
++	spin_lock(&xpad->odata_lock);
++
++	switch (xpad->xtype) {
++		
++		case XTYPE_XBOX360:
++			xpad->odata[0] = 0x01;
++			xpad->odata[1] = 0x03;
++			xpad->odata[2] = command;
++			xpad->irq_out->transfer_buffer_length = 3;
++			break;
++		case XTYPE_XBOX360W:
++			xpad->odata[0] = 0x00;
++			xpad->odata[1] = 0x00;
++			xpad->odata[2] = 0x08;
++			xpad->odata[3] = 0x40 + (command % 0x0e);
++			xpad->odata[4] = 0x00;
++			xpad->odata[5] = 0x00;
++			xpad->odata[6] = 0x00;
++			xpad->odata[7] = 0x00;
++			xpad->odata[8] = 0x00;
++			xpad->odata[9] = 0x00;
++			xpad->odata[10] = 0x00;
++			xpad->odata[11] = 0x00;
++			xpad->irq_out->transfer_buffer_length = 12;
++			break;
+ 	}
++
++	usb_submit_urb(xpad->irq_out, GFP_KERNEL);
++	spin_unlock(&xpad->odata_lock);
+ }
+ 
+ static void xpad_led_set(struct led_classdev *led_cdev,
+@@ -741,8 +895,10 @@ static int xpad_led_probe(struct usb_xpa
+ 	struct xpad_led *led;
+ 	struct led_classdev *led_cdev;
+ 	int error;
++	
++// 	printk("xpad_led_probe\n");
+ 
+-	if (xpad->xtype != XTYPE_XBOX360)
++	if (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX360W)
+ 		return 0;
+ 
+ 	xpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);
+@@ -765,11 +921,6 @@ static int xpad_led_probe(struct usb_xpa
+ 		return error;
+ 	}
+ 
+-	/*
+-	 * Light up the segment corresponding to controller number
+-	 */
+-	xpad_send_led_command(xpad, (led_no % 4) + 2);
+-
+ 	return 0;
+ }
+ 
+@@ -791,6 +942,7 @@ static void xpad_led_disconnect(struct u
+ static int xpad_open(struct input_dev *dev)
+ {
+ 	struct usb_xpad *xpad = input_get_drvdata(dev);
++// 	printk("xpad open driver data %x\n", (unsigned int)xpad);
+ 
+ 	/* URB was submitted in probe */
+ 	if (xpad->xtype == XTYPE_XBOX360W)
+@@ -846,19 +998,20 @@ static int xpad_probe(struct usb_interfa
+ 	if (intf->cur_altsetting->desc.bNumEndpoints != 2)
+ 		return -ENODEV;
+ 
++	if (!my_wq) {
++		my_wq = create_workqueue("xpad_queue");
++	}
++
+ 	for (i = 0; xpad_device[i].idVendor; i++) {
+ 		if ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&
+ 		    (le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))
+ 			break;
+ 	}
+
+ 	xpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);
+-	input_dev = input_allocate_device();
+-	if (!xpad || !input_dev) {
+-		error = -ENOMEM;
+-		goto fail1;
+-	}
+ 
++	xpad->name = xpad_device[i].name;
++	
+ 	xpad->idata = usb_alloc_coherent(udev, XPAD_PKT_LEN,
+ 					 GFP_KERNEL, &xpad->idata_dma);
+ 	if (!xpad->idata) {
+@@ -894,65 +1047,12 @@ static int xpad_probe(struct usb_interfa
+ 			xpad->mapping |= MAP_STICKS_TO_NULL;
+ 	}
+ 
+-	xpad->dev = input_dev;
+-	usb_make_path(udev, xpad->phys, sizeof(xpad->phys));
+-	strlcat(xpad->phys, "/input0", sizeof(xpad->phys));
+-
+-	input_dev->name = xpad_device[i].name;
+-	input_dev->phys = xpad->phys;
+-	usb_to_input_id(udev, &input_dev->id);
+-	input_dev->dev.parent = &intf->dev;
+-
+-	input_set_drvdata(input_dev, xpad);
+-
+-	input_dev->open = xpad_open;
+-	input_dev->close = xpad_close;
+-
+-	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+-
+-	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
+-		input_dev->evbit[0] |= BIT_MASK(EV_ABS);
+-		/* set up axes */
+-		for (i = 0; xpad_abs[i] >= 0; i++)
+-			xpad_set_up_abs(input_dev, xpad_abs[i]);
+-	}
+-
+-	/* set up standard buttons */
+-	for (i = 0; xpad_common_btn[i] >= 0; i++)
+-		__set_bit(xpad_common_btn[i], input_dev->keybit);
+-
+-	/* set up model-specific ones */
+-	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W) {
+-		for (i = 0; xpad360_btn[i] >= 0; i++)
+-			__set_bit(xpad360_btn[i], input_dev->keybit);
+-	} else {
+-		for (i = 0; xpad_btn[i] >= 0; i++)
+-			__set_bit(xpad_btn[i], input_dev->keybit);
+-	}
+-
+-	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
+-		for (i = 0; xpad_btn_pad[i] >= 0; i++)
+-			__set_bit(xpad_btn_pad[i], input_dev->keybit);
+-	} else {
+-		for (i = 0; xpad_abs_pad[i] >= 0; i++)
+-		    xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
+-	}
+-
+-	if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
+-		for (i = 0; xpad_btn_triggers[i] >= 0; i++)
+-			__set_bit(xpad_btn_triggers[i], input_dev->keybit);
+-	} else {
+-		for (i = 0; xpad_abs_triggers[i] >= 0; i++)
+-			xpad_set_up_abs(input_dev, xpad_abs_triggers[i]);
+-	}
+-
+ 	error = xpad_init_output(intf, xpad);
+ 	if (error)
+ 		goto fail3;
+ 
+-	error = xpad_init_ff(xpad);
+-	if (error)
+-		goto fail4;
++	usb_make_path(xpad->udev, xpad->phys, sizeof(xpad->phys));
++	strlcat(xpad->phys, "/input0", sizeof(xpad->phys));
+ 
+ 	error = xpad_led_probe(xpad);
+ 	if (error)
+@@ -966,10 +1066,6 @@ static int xpad_probe(struct usb_interfa
+ 	xpad->irq_in->transfer_dma = xpad->idata_dma;
+ 	xpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+ 
+-	error = input_register_device(xpad->dev);
+-	if (error)
+-		goto fail6;
+-
+ 	usb_set_intfdata(intf, xpad);
+ 
+ 	if (xpad->xtype == XTYPE_XBOX360W) {
+@@ -977,6 +1073,7 @@ static int xpad_probe(struct usb_interfa
+ 		 * Setup the message to set the LEDs on the
+ 		 * controller when it shows up
+ 		 */
++		spin_lock(&xpad->odata_lock);
+ 		xpad->bulk_out = usb_alloc_urb(0, GFP_KERNEL);
+ 		if (!xpad->bulk_out) {
+ 			error = -ENOMEM;
+@@ -1028,23 +1125,55 @@ static int xpad_probe(struct usb_interfa
+ 		 */
+ 		xpad->irq_in->dev = xpad->udev;
+ 		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
++		
++		spin_unlock(&xpad->odata_lock);
+ 		if (error)
+ 			goto fail9;
++		
++		// I don't know how to check controller state on driver load so just slam them
++		// off so that people have to turn them on, triggering a state update
++		
++		// got the power off packet from an OSX reverse-engineered driver:
++		// http://tattiebogle.net/index.php/ProjectRoot/Xbox360Controller/OsxDriver#toc1
++		spin_lock(&xpad->odata_lock);
++		xpad->odata[0] = 0x00;
++		xpad->odata[1] = 0x00;
++		xpad->odata[2] = 0x08;
++		xpad->odata[3] = 0xC0;
++		xpad->odata[4] = 0x00;
++		xpad->odata[5] = 0x00;
++		xpad->odata[6] = 0x00;
++		xpad->odata[7] = 0x00;
++		xpad->odata[8] = 0x00;
++		xpad->odata[9] = 0x00;
++		xpad->odata[10] = 0x00;
++		xpad->odata[11] = 0x00;
++		xpad->irq_out->transfer_buffer_length = 12;
++		usb_submit_urb(xpad->irq_out, GFP_KERNEL);
++		spin_unlock(&xpad->odata_lock);
++	} else {
++		my_work_t *work;
++		xpad->pad_present = 1;
++		
++		work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);
++		INIT_WORK( (struct work_struct *)work, my_wq_function );
++		work->xpad = xpad;
++		queue_work( my_wq, (struct work_struct *)work );
+ 	}
+ 
+ 	return 0;
+ 
+  fail9:	kfree(xpad->bdata);
+  fail8:	usb_free_urb(xpad->bulk_out);
+- fail7:	input_unregister_device(input_dev);
+-	input_dev = NULL;
++ fail7:	//input_unregister_device(input_dev);
++	//input_dev = NULL;
+  fail6:	xpad_led_disconnect(xpad);
+- fail5:	if (input_dev)
+-		input_ff_destroy(input_dev);
++ fail5:	//if (input_dev)
++		//input_ff_destroy(input_dev);
+  fail4:	xpad_deinit_output(xpad);
+  fail3:	usb_free_urb(xpad->irq_in);
+  fail2:	usb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
+- fail1:	input_free_device(input_dev);
++ fail1:	//input_free_device(input_dev);
+ 	kfree(xpad);
+ 	return error;
+ 
+@@ -1054,8 +1183,14 @@ static void xpad_disconnect(struct usb_i
+ {
+ 	struct usb_xpad *xpad = usb_get_intfdata (intf);
+ 
++// 	printk("xpad_disconnect\n");
+ 	xpad_led_disconnect(xpad);
+-	input_unregister_device(xpad->dev);
++	
++	if (xpad->pad_present)
++	{
++		xpad->pad_present = 0;
++		input_unregister_device(xpad->dev);
++	}
+ 	xpad_deinit_output(xpad);
+ 
+ 	if (xpad->xtype == XTYPE_XBOX360W) {
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-203-stb0899_enable_low_symbol_rate.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-203-stb0899_enable_low_symbol_rate.patch
new file mode 100644
index 0000000..f302b6c
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-203-stb0899_enable_low_symbol_rate.patch
@@ -0,0 +1,12 @@
+diff -Naur linux-3.7.2/drivers/media/dvb-frontends/stb0899_drv.c linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_drv.c
+--- linux-3.7.2/drivers/media/dvb-frontends/stb0899_drv.c	2013-01-11 18:19:28.000000000 +0100
++++ linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_drv.c	2013-01-16 10:25:43.479645317 +0100
+@@ -1581,7 +1581,7 @@
+ 		.frequency_max 		= 2150000,
+ 		.frequency_stepsize	= 0,
+ 		.frequency_tolerance	= 0,
+-		.symbol_rate_min 	=  5000000,
++		.symbol_rate_min 	=  1000000,
+ 		.symbol_rate_max 	= 45000000,
+ 
+ 		.caps 			= FE_CAN_INVERSION_AUTO	|
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-212-mantis_stb0899_faster_lock.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-212-mantis_stb0899_faster_lock.patch
new file mode 100644
index 0000000..eef4e1e
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-212-mantis_stb0899_faster_lock.patch
@@ -0,0 +1,138 @@
+diff -Naur linux-3.7.2/drivers/media/dvb-frontends/stb0899_algo.c linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_algo.c
+--- linux-3.7.2/drivers/media/dvb-frontends/stb0899_algo.c	2013-01-11 18:19:28.000000000 +0100
++++ linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_algo.c	2013-01-16 10:28:33.633409961 +0100
+@@ -206,7 +206,6 @@
+ static enum stb0899_status stb0899_search_tmg(struct stb0899_state *state)
+ {
+ 	struct stb0899_internal *internal = &state->internal;
+-	struct stb0899_params *params = &state->params;
+ 
+ 	short int derot_step, derot_freq = 0, derot_limit, next_loop = 3;
+ 	int index = 0;
+@@ -216,10 +215,9 @@
+ 
+ 	/* timing loop computation & symbol rate optimisation	*/
+ 	derot_limit = (internal->sub_range / 2L) / internal->mclk;
+-	derot_step = (params->srate / 2L) / internal->mclk;
++	derot_step = internal->derot_step * 4;				/* dertot_step = decreasing delta */
+ 
+ 	while ((stb0899_check_tmg(state) != TIMINGOK) && next_loop) {
+-		index++;
+ 		derot_freq += index * internal->direction * derot_step;	/* next derot zig zag position	*/
+ 
+ 		if (abs(derot_freq) > derot_limit)
+@@ -230,6 +228,7 @@
+ 			STB0899_SETFIELD_VAL(CFRL, cfr[1], LSB(state->config->inversion * derot_freq));
+ 			stb0899_write_regs(state, STB0899_CFRM, cfr, 2); /* derotator frequency		*/
+ 		}
++		index++;
+ 		internal->direction = -internal->direction;	/* Change zigzag direction		*/
+ 	}
+ 
+@@ -278,14 +277,18 @@
+ {
+ 	struct stb0899_internal *internal = &state->internal;
+ 
+-	short int derot_freq = 0, last_derot_freq = 0, derot_limit, next_loop = 3;
++	short int derot_freq = 0, last_derot_freq = 0, derot_limit, derot_step, next_loop = 3;
+ 	int index = 0;
++	int base_freq;
+ 	u8 cfr[2];
+ 	u8 reg;
+ 
+ 	internal->status = NOCARRIER;
+ 	derot_limit = (internal->sub_range / 2L) / internal->mclk;
+ 	derot_freq = internal->derot_freq;
++	derot_step = internal->derot_step * 2;
++	last_derot_freq = internal->derot_freq;
++	base_freq = internal->derot_freq;
+ 
+ 	reg = stb0899_read_reg(state, STB0899_CFD);
+ 	STB0899_SETFIELD_VAL(CFD_ON, reg, 1);
+@@ -294,11 +297,10 @@
+ 	do {
+ 		dprintk(state->verbose, FE_DEBUG, 1, "Derot Freq=%d, mclk=%d", derot_freq, internal->mclk);
+ 		if (stb0899_check_carrier(state) == NOCARRIER) {
+-			index++;
+ 			last_derot_freq = derot_freq;
+-			derot_freq += index * internal->direction * internal->derot_step; /* next zig zag derotator position */
++			derot_freq += index * internal->direction * derot_step; /* next zig zag derotator position	*/
+ 
+-			if(abs(derot_freq) > derot_limit)
++			if (derot_freq > base_freq + derot_limit || derot_freq < base_freq - derot_limit)
+ 				next_loop--;
+ 
+ 			if (next_loop) {
+@@ -310,9 +312,10 @@
+ 				STB0899_SETFIELD_VAL(CFRL, cfr[1], LSB(state->config->inversion * derot_freq));
+ 				stb0899_write_regs(state, STB0899_CFRM, cfr, 2); /* derotator frequency	*/
+ 			}
++			index++;
++			internal->direction = -internal->direction; /* Change zigzag direction */
+ 		}
+ 
+-		internal->direction = -internal->direction; /* Change zigzag direction */
+ 	} while ((internal->status != CARRIEROK) && next_loop);
+ 
+ 	if (internal->status == CARRIEROK) {
+@@ -338,6 +341,7 @@
+ 	int lock = 0, index = 0, dataTime = 500, loop;
+ 	u8 reg;
+ 
++	msleep(1);
+ 	internal->status = NODATA;
+ 
+ 	/* RESET FEC	*/
+@@ -348,6 +352,7 @@
+ 	reg = stb0899_read_reg(state, STB0899_TSTRES);
+ 	STB0899_SETFIELD_VAL(FRESACS, reg, 0);
+ 	stb0899_write_reg(state, STB0899_TSTRES, reg);
++	msleep(1);
+ 
+ 	if (params->srate <= 2000000)
+ 		dataTime = 2000;
+@@ -363,6 +368,7 @@
+ 
+ 	stb0899_write_reg(state, STB0899_DSTATUS2, 0x00); /* force search loop	*/
+ 	while (1) {
++		msleep(1); 		// Alex: added 1 mSec
+ 		/* WARNING! VIT LOCKED has to be tested before VIT_END_LOOOP	*/
+ 		reg = stb0899_read_reg(state, STB0899_VSTATUS);
+ 		lock = STB0899_GETFIELD(VSTATUS_LOCKEDVIT, reg);
+@@ -390,20 +396,21 @@
+ 	short int derot_freq, derot_step, derot_limit, next_loop = 3;
+ 	u8 cfr[2];
+ 	u8 reg;
+-	int index = 1;
++	int index = 0;
++	int base_freq;
+ 
+ 	struct stb0899_internal *internal = &state->internal;
+-	struct stb0899_params *params = &state->params;
+ 
+-	derot_step = (params->srate / 4L) / internal->mclk;
++	derot_step = internal->derot_step;
+ 	derot_limit = (internal->sub_range / 2L) / internal->mclk;
+ 	derot_freq = internal->derot_freq;
++	base_freq = internal->derot_freq;
+ 
+ 	do {
+ 		if ((internal->status != CARRIEROK) || (stb0899_check_data(state) != DATAOK)) {
+ 
+ 			derot_freq += index * internal->direction * derot_step;	/* next zig zag derotator position */
+-			if (abs(derot_freq) > derot_limit)
++			if (derot_freq > base_freq + derot_limit || derot_freq < base_freq - derot_limit)
+ 				next_loop--;
+ 
+ 			if (next_loop) {
+@@ -417,9 +424,9 @@
+ 				stb0899_write_regs(state, STB0899_CFRM, cfr, 2); /* derotator frequency	*/
+ 
+ 				stb0899_check_carrier(state);
+-				index++;
+ 			}
+ 		}
++		index++;
+ 		internal->direction = -internal->direction; /* change zig zag direction */
+ 	} while ((internal->status != DATAOK) && next_loop);
+ 
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-221-ngene-octopus.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-221-ngene-octopus.patch
new file mode 100644
index 0000000..2028503
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-221-ngene-octopus.patch
@@ -0,0 +1,12552 @@
+From c5891c83d5777a2e691c2a452a7f57a6b6a13344 Mon Sep 17 00:00:00 2001
+From: Stefan Saraev <stefan@saraev.ca>
+Date: Sun, 12 May 2013 23:47:07 +0300
+Subject: [PATCH] dvb: ngene/octopus
+
+---
+ drivers/media/dvb-frontends/Kconfig          |   26 +
+ drivers/media/dvb-frontends/Makefile         |    2 +
+ drivers/media/dvb-frontends/stv0367dd.c      | 2269 +++++++++++++++++
+ drivers/media/dvb-frontends/stv0367dd.h      |   17 +
+ drivers/media/dvb-frontends/stv0367dd_regs.h | 3431 ++++++++++++++++++++++++++
+ drivers/media/dvb-frontends/tda18212dd.c     |  906 +++++++
+ drivers/media/dvb-frontends/tda18212dd.h     |    5 +
+ drivers/media/pci/ddbridge/Kconfig           |   14 +-
+ drivers/media/pci/ddbridge/ddbridge-core.c   | 1947 ++++++++++++----
+ drivers/media/pci/ddbridge/ddbridge-regs.h   |   56 +-
+ drivers/media/pci/ddbridge/ddbridge.h        |   97 +-
+ drivers/media/pci/ngene/Kconfig              |   17 +-
+ drivers/media/pci/ngene/Makefile             |    3 +-
+ drivers/media/pci/ngene/ngene-av.c           |  348 +++
+ drivers/media/pci/ngene/ngene-cards.c        |  778 +++++--
+ drivers/media/pci/ngene/ngene-core.c         |  378 +++-
+ drivers/media/pci/ngene/ngene-dvb.c          |  372 +++
+ drivers/media/pci/ngene/ngene-eeprom.c       |  284 +++
+ drivers/media/pci/ngene/ngene-i2c.c          |  113 +
+ drivers/media/pci/ngene/ngene.h              |   40 +
+ drivers/staging/media/cxd2099/TODO           |   12 -
+ drivers/staging/media/cxd2099/cxd2099.c      |   47 +-
+ drivers/staging/media/cxd2099/cxd2099.h      |    2 +-
+ 23 files changed, 10416 insertions(+), 748 deletions(-)
+ create mode 100644 drivers/media/dvb-frontends/stv0367dd.c
+ create mode 100644 drivers/media/dvb-frontends/stv0367dd.h
+ create mode 100644 drivers/media/dvb-frontends/stv0367dd_regs.h
+ create mode 100644 drivers/media/dvb-frontends/tda18212dd.c
+ create mode 100644 drivers/media/dvb-frontends/tda18212dd.h
+ create mode 100644 drivers/media/pci/ngene/ngene-av.c
+ create mode 100644 drivers/media/pci/ngene/ngene-eeprom.c
+ delete mode 100644 drivers/staging/media/cxd2099/TODO
+
+diff --git a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
+index 05cf66f..1e0275f 100644
+--- a/drivers/media/dvb-frontends/Kconfig
++++ b/drivers/media/dvb-frontends/Kconfig
+@@ -19,6 +19,14 @@ config DVB_STB0899
+ 	  A DVB-S/S2/DSS Multistandard demodulator. Say Y when you want
+ 	  to support this demodulator based frontends
+ 
++config DVB_CXD2099
++	tristate "CXD2099AR Common Interface driver"
++	depends on DVB_CORE && PCI && I2C
++	---help---
++	  Support for the CI module found on cards based on
++	  - Micronas ngene PCIe bridge: cineS2 etc.
++	  - Digital Devices PCIe bridge: Octopus series
++
+ config DVB_STB6100
+ 	tristate "STB6100 based tuners"
+ 	depends on DVB_CORE && I2C
+@@ -63,6 +71,24 @@ config DVB_TDA18271C2DD
+ 
+ 	  Say Y when you want to support this tuner.
+ 
++config DVB_STV0367DD
++	tristate "STV 0367 (DD)"
++	depends on DVB_CORE && I2C
++	default m if DVB_FE_CUSTOMISE
++	help
++	  STV 0367 DVB-C/T demodulator (Digital Devices driver).
++
++	  Say Y when you want to support this frontend.
++
++config DVB_TDA18212DD
++	tristate "NXP TDA18212 silicon tuner (DD)"
++	depends on DVB_CORE && I2C
++	default m if DVB_FE_CUSTOMISE
++	help
++	  NXP TDA18212 silicon tuner (Digital Devices driver).
++
++	  Say Y when you want to support this tuner.
++
+ comment "DVB-S (satellite) frontends"
+ 	depends on DVB_CORE
+ 
+diff --git a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
+index 75440de..25ab5f8 100644
+--- a/drivers/media/dvb-frontends/Makefile
++++ b/drivers/media/dvb-frontends/Makefile
+@@ -100,6 +100,8 @@ obj-$(CONFIG_DVB_STV0367) += stv0367.o
+ obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
+ obj-$(CONFIG_DVB_DRXK) += drxk.o
+ obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
++obj-$(CONFIG_DVB_STV0367DD) += stv0367dd.o
++obj-$(CONFIG_DVB_TDA18212DD) += tda18212dd.o
+ obj-$(CONFIG_DVB_IT913X_FE) += it913x-fe.o
+ obj-$(CONFIG_DVB_A8293) += a8293.o
+ obj-$(CONFIG_DVB_TDA10071) += tda10071.o
+diff --git a/drivers/media/dvb-frontends/stv0367dd.c b/drivers/media/dvb-frontends/stv0367dd.c
+new file mode 100644
+index 0000000..34a38cf
+--- /dev/null
++++ b/drivers/media/dvb-frontends/stv0367dd.c
+@@ -0,0 +1,2269 @@
++/*
++ * stv0367dd: STV0367 DVB-C/T demodulator driver
++ *
++ * Copyright (C) 2011 Digital Devices GmbH
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 only, as published by the Free Software Foundation.
++ *
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301, USA
++ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/firmware.h>
++#include <linux/i2c.h>
++#include <linux/version.h>
++#include <asm/div64.h>
++
++#include "dvb_frontend.h"
++#include "stv0367dd.h"
++#include "stv0367dd_regs.h"
++
++enum omode { OM_NONE, OM_DVBT, OM_DVBC, OM_QAM_ITU_C };
++enum {  QAM_MOD_QAM4 = 0,
++	QAM_MOD_QAM16,
++	QAM_MOD_QAM32,
++	QAM_MOD_QAM64,
++	QAM_MOD_QAM128,
++	QAM_MOD_QAM256,
++	QAM_MOD_QAM512,
++	QAM_MOD_QAM1024
++};
++
++enum {QAM_SPECT_NORMAL, QAM_SPECT_INVERTED };
++
++enum {
++	QAM_FEC_A = 1,					/* J83 Annex A */
++	QAM_FEC_B = (1<<1),				/* J83 Annex B */
++	QAM_FEC_C = (1<<2)				/* J83 Annex C */
++};
++
++enum EDemodState { Off, QAMSet, OFDMSet, QAMStarted, OFDMStarted };
++
++struct stv_state {
++#ifdef USE_API3
++	struct dvb_frontend c_frontend;
++	struct dvb_frontend t_frontend;
++#else
++	struct dvb_frontend frontend;
++#endif
++	fe_modulation_t modulation;
++	u32 symbol_rate;
++	u32 bandwidth;
++	struct device *dev;
++
++	struct i2c_adapter *i2c;
++	u8     adr;
++	void  *priv;
++
++	struct mutex mutex;
++	struct mutex ctlock;
++
++	u32 master_clock;
++	u32 adc_clock;
++	u8 ID;
++	u8 I2CRPT;
++	u32 omode;
++	u8  qam_inversion;
++
++	s32 IF;
++
++	s32    m_FECTimeOut;
++	s32    m_DemodTimeOut;
++	s32    m_SignalTimeOut;
++	s32    m_DemodLockTime;
++	s32    m_FFTTimeOut;
++	s32    m_TSTimeOut;
++
++	bool    m_bFirstTimeLock;
++
++	u8    m_Save_QAM_AGC_CTL;
++
++	enum EDemodState demod_state;
++
++	u8    m_OFDM_FFTMode;          // 0 = 2k, 1 = 8k, 2 = 4k
++	u8    m_OFDM_Modulation;   //
++	u8    m_OFDM_FEC;          //
++	u8    m_OFDM_Guard;
++
++	u32   ucblocks;
++};
++
++struct init_table {
++	u16  adr;
++	u8   data;
++};
++
++struct init_table base_init[] = {
++	{ R367_IOCFG0,     0x80 },
++	{ R367_DAC0R,      0x00 },
++	{ R367_IOCFG1,     0x00 },
++	{ R367_DAC1R,      0x00 },
++	{ R367_IOCFG2,     0x00 },
++	{ R367_SDFR,       0x00 },
++	{ R367_AUX_CLK,    0x00 },
++	{ R367_FREESYS1,   0x00 },
++	{ R367_FREESYS2,   0x00 },
++	{ R367_FREESYS3,   0x00 },
++	{ R367_GPIO_CFG,   0x55 },
++	{ R367_GPIO_CMD,   0x01 },
++	{ R367_TSTRES,     0x00 },
++	{ R367_ANACTRL,    0x00 },
++	{ R367_TSTBUS,     0x00 },
++	{ R367_RF_AGC2,    0x20 },
++	{ R367_ANADIGCTRL, 0x0b },
++	{ R367_PLLMDIV,    0x01 },
++	{ R367_PLLNDIV,    0x08 },
++	{ R367_PLLSETUP,   0x18 },
++	{ R367_DUAL_AD12,  0x04 },
++	{ R367_TSTBIST,    0x00 },
++	{ 0x0000,          0x00 }
++};
++
++struct init_table qam_init[] = {
++	{ R367_QAM_CTRL_1,                  0x06 },// Orginal 0x04
++	{ R367_QAM_CTRL_2,                  0x03 },
++	{ R367_QAM_IT_STATUS1,              0x2b },
++	{ R367_QAM_IT_STATUS2,              0x08 },
++	{ R367_QAM_IT_EN1,                  0x00 },
++	{ R367_QAM_IT_EN2,                  0x00 },
++	{ R367_QAM_CTRL_STATUS,             0x04 },
++	{ R367_QAM_TEST_CTL,                0x00 },
++	{ R367_QAM_AGC_CTL,                 0x73 },
++	{ R367_QAM_AGC_IF_CFG,              0x50 },
++	{ R367_QAM_AGC_RF_CFG,              0x02 },// RF Freeze
++	{ R367_QAM_AGC_PWM_CFG,             0x03 },
++	{ R367_QAM_AGC_PWR_REF_L,           0x5a },
++	{ R367_QAM_AGC_PWR_REF_H,           0x00 },
++	{ R367_QAM_AGC_RF_TH_L,             0xff },
++	{ R367_QAM_AGC_RF_TH_H,             0x07 },
++	{ R367_QAM_AGC_IF_LTH_L,            0x00 },
++	{ R367_QAM_AGC_IF_LTH_H,            0x08 },
++	{ R367_QAM_AGC_IF_HTH_L,            0xff },
++	{ R367_QAM_AGC_IF_HTH_H,            0x07 },
++	{ R367_QAM_AGC_PWR_RD_L,            0xa0 },
++	{ R367_QAM_AGC_PWR_RD_M,            0xe9 },
++	{ R367_QAM_AGC_PWR_RD_H,            0x03 },
++	{ R367_QAM_AGC_PWM_IFCMD_L,         0xe4 },
++	{ R367_QAM_AGC_PWM_IFCMD_H,         0x00 },
++	{ R367_QAM_AGC_PWM_RFCMD_L,         0xff },
++	{ R367_QAM_AGC_PWM_RFCMD_H,         0x07 },
++	{ R367_QAM_IQDEM_CFG,               0x01 },
++	{ R367_QAM_MIX_NCO_LL,              0x22 },
++	{ R367_QAM_MIX_NCO_HL,              0x96 },
++	{ R367_QAM_MIX_NCO_HH,              0x55 },
++	{ R367_QAM_SRC_NCO_LL,              0xff },
++	{ R367_QAM_SRC_NCO_LH,              0x0c },
++	{ R367_QAM_SRC_NCO_HL,              0xf5 },
++	{ R367_QAM_SRC_NCO_HH,              0x20 },
++	{ R367_QAM_IQDEM_GAIN_SRC_L,        0x06 },
++	{ R367_QAM_IQDEM_GAIN_SRC_H,        0x01 },
++	{ R367_QAM_IQDEM_DCRM_CFG_LL,       0xfe },
++	{ R367_QAM_IQDEM_DCRM_CFG_LH,       0xff },
++	{ R367_QAM_IQDEM_DCRM_CFG_HL,       0x0f },
++	{ R367_QAM_IQDEM_DCRM_CFG_HH,       0x00 },
++	{ R367_QAM_IQDEM_ADJ_COEFF0,        0x34 },
++	{ R367_QAM_IQDEM_ADJ_COEFF1,        0xae },
++	{ R367_QAM_IQDEM_ADJ_COEFF2,        0x46 },
++	{ R367_QAM_IQDEM_ADJ_COEFF3,        0x77 },
++	{ R367_QAM_IQDEM_ADJ_COEFF4,        0x96 },
++	{ R367_QAM_IQDEM_ADJ_COEFF5,        0x69 },
++	{ R367_QAM_IQDEM_ADJ_COEFF6,        0xc7 },
++	{ R367_QAM_IQDEM_ADJ_COEFF7,        0x01 },
++	{ R367_QAM_IQDEM_ADJ_EN,            0x04 },
++	{ R367_QAM_IQDEM_ADJ_AGC_REF,       0x94 },
++	{ R367_QAM_ALLPASSFILT1,            0xc9 },
++	{ R367_QAM_ALLPASSFILT2,            0x2d },
++	{ R367_QAM_ALLPASSFILT3,            0xa3 },
++	{ R367_QAM_ALLPASSFILT4,            0xfb },
++	{ R367_QAM_ALLPASSFILT5,            0xf6 },
++	{ R367_QAM_ALLPASSFILT6,            0x45 },
++	{ R367_QAM_ALLPASSFILT7,            0x6f },
++	{ R367_QAM_ALLPASSFILT8,            0x7e },
++	{ R367_QAM_ALLPASSFILT9,            0x05 },
++	{ R367_QAM_ALLPASSFILT10,           0x0a },
++	{ R367_QAM_ALLPASSFILT11,           0x51 },
++	{ R367_QAM_TRL_AGC_CFG,             0x20 },
++	{ R367_QAM_TRL_LPF_CFG,             0x28 },
++	{ R367_QAM_TRL_LPF_ACQ_GAIN,        0x44 },
++	{ R367_QAM_TRL_LPF_TRK_GAIN,        0x22 },
++	{ R367_QAM_TRL_LPF_OUT_GAIN,        0x03 },
++	{ R367_QAM_TRL_LOCKDET_LTH,         0x04 },
++	{ R367_QAM_TRL_LOCKDET_HTH,         0x11 },
++	{ R367_QAM_TRL_LOCKDET_TRGVAL,      0x20 },
++	{ R367_QAM_IQ_QAM,			0x01 },
++	{ R367_QAM_FSM_STATE,               0xa0 },
++	{ R367_QAM_FSM_CTL,                 0x08 },
++	{ R367_QAM_FSM_STS,                 0x0c },
++	{ R367_QAM_FSM_SNR0_HTH,            0x00 },
++	{ R367_QAM_FSM_SNR1_HTH,            0x00 },
++	{ R367_QAM_FSM_SNR2_HTH,            0x00 },
++	{ R367_QAM_FSM_SNR0_LTH,            0x00 },
++	{ R367_QAM_FSM_SNR1_LTH,            0x00 },
++	{ R367_QAM_FSM_EQA1_HTH,            0x00 },
++	{ R367_QAM_FSM_TEMPO,               0x32 },
++	{ R367_QAM_FSM_CONFIG,              0x03 },
++	{ R367_QAM_EQU_I_TESTTAP_L,         0x11 },
++	{ R367_QAM_EQU_I_TESTTAP_M,         0x00 },
++	{ R367_QAM_EQU_I_TESTTAP_H,         0x00 },
++	{ R367_QAM_EQU_TESTAP_CFG,          0x00 },
++	{ R367_QAM_EQU_Q_TESTTAP_L,         0xff },
++	{ R367_QAM_EQU_Q_TESTTAP_M,         0x00 },
++	{ R367_QAM_EQU_Q_TESTTAP_H,         0x00 },
++	{ R367_QAM_EQU_TAP_CTRL,            0x00 },
++	{ R367_QAM_EQU_CTR_CRL_CONTROL_L,   0x11 },
++	{ R367_QAM_EQU_CTR_CRL_CONTROL_H,   0x05 },
++	{ R367_QAM_EQU_CTR_HIPOW_L,         0x00 },
++	{ R367_QAM_EQU_CTR_HIPOW_H,         0x00 },
++	{ R367_QAM_EQU_I_EQU_LO,            0xef },
++	{ R367_QAM_EQU_I_EQU_HI,            0x00 },
++	{ R367_QAM_EQU_Q_EQU_LO,            0xee },
++	{ R367_QAM_EQU_Q_EQU_HI,            0x00 },
++	{ R367_QAM_EQU_MAPPER,              0xc5 },
++	{ R367_QAM_EQU_SWEEP_RATE,          0x80 },
++	{ R367_QAM_EQU_SNR_LO,              0x64 },
++	{ R367_QAM_EQU_SNR_HI,              0x03 },
++	{ R367_QAM_EQU_GAMMA_LO,            0x00 },
++	{ R367_QAM_EQU_GAMMA_HI,            0x00 },
++	{ R367_QAM_EQU_ERR_GAIN,            0x36 },
++	{ R367_QAM_EQU_RADIUS,              0xaa },
++	{ R367_QAM_EQU_FFE_MAINTAP,         0x00 },
++	{ R367_QAM_EQU_FFE_LEAKAGE,         0x63 },
++	{ R367_QAM_EQU_FFE_MAINTAP_POS,     0xdf },
++	{ R367_QAM_EQU_GAIN_WIDE,           0x88 },
++	{ R367_QAM_EQU_GAIN_NARROW,         0x41 },
++	{ R367_QAM_EQU_CTR_LPF_GAIN,        0xd1 },
++	{ R367_QAM_EQU_CRL_LPF_GAIN,        0xa7 },
++	{ R367_QAM_EQU_GLOBAL_GAIN,         0x06 },
++	{ R367_QAM_EQU_CRL_LD_SEN,          0x85 },
++	{ R367_QAM_EQU_CRL_LD_VAL,          0xe2 },
++	{ R367_QAM_EQU_CRL_TFR,             0x20 },
++	{ R367_QAM_EQU_CRL_BISTH_LO,        0x00 },
++	{ R367_QAM_EQU_CRL_BISTH_HI,        0x00 },
++	{ R367_QAM_EQU_SWEEP_RANGE_LO,      0x00 },
++	{ R367_QAM_EQU_SWEEP_RANGE_HI,      0x00 },
++	{ R367_QAM_EQU_CRL_LIMITER,         0x40 },
++	{ R367_QAM_EQU_MODULUS_MAP,         0x90 },
++	{ R367_QAM_EQU_PNT_GAIN,            0xa7 },
++	{ R367_QAM_FEC_AC_CTR_0,            0x16 },
++	{ R367_QAM_FEC_AC_CTR_1,            0x0b },
++	{ R367_QAM_FEC_AC_CTR_2,            0x88 },
++	{ R367_QAM_FEC_AC_CTR_3,            0x02 },
++	{ R367_QAM_FEC_STATUS,              0x12 },
++	{ R367_QAM_RS_COUNTER_0,            0x7d },
++	{ R367_QAM_RS_COUNTER_1,            0xd0 },
++	{ R367_QAM_RS_COUNTER_2,            0x19 },
++	{ R367_QAM_RS_COUNTER_3,            0x0b },
++	{ R367_QAM_RS_COUNTER_4,            0xa3 },
++	{ R367_QAM_RS_COUNTER_5,            0x00 },
++	{ R367_QAM_BERT_0,                  0x01 },
++	{ R367_QAM_BERT_1,                  0x25 },
++	{ R367_QAM_BERT_2,                  0x41 },
++	{ R367_QAM_BERT_3,                  0x39 },
++	{ R367_QAM_OUTFORMAT_0,             0xc2 },
++	{ R367_QAM_OUTFORMAT_1,             0x22 },
++	{ R367_QAM_SMOOTHER_2,              0x28 },
++	{ R367_QAM_TSMF_CTRL_0,             0x01 },
++	{ R367_QAM_TSMF_CTRL_1,             0xc6 },
++	{ R367_QAM_TSMF_CTRL_3,             0x43 },
++	{ R367_QAM_TS_ON_ID_0,              0x00 },
++	{ R367_QAM_TS_ON_ID_1,              0x00 },
++	{ R367_QAM_TS_ON_ID_2,              0x00 },
++	{ R367_QAM_TS_ON_ID_3,              0x00 },
++	{ R367_QAM_RE_STATUS_0,             0x00 },
++	{ R367_QAM_RE_STATUS_1,             0x00 },
++	{ R367_QAM_RE_STATUS_2,             0x00 },
++	{ R367_QAM_RE_STATUS_3,             0x00 },
++	{ R367_QAM_TS_STATUS_0,             0x00 },
++	{ R367_QAM_TS_STATUS_1,             0x00 },
++	{ R367_QAM_TS_STATUS_2,             0xa0 },
++	{ R367_QAM_TS_STATUS_3,             0x00 },
++	{ R367_QAM_T_O_ID_0,                0x00 },
++	{ R367_QAM_T_O_ID_1,                0x00 },
++	{ R367_QAM_T_O_ID_2,                0x00 },
++	{ R367_QAM_T_O_ID_3,                0x00 },
++	{ 0x0000, 0x00 } // EOT
++};
++
++struct init_table ofdm_init[] = {
++	//{R367_OFDM_ID                   ,0x60},
++	//{R367_OFDM_I2CRPT 				,0x22},
++	//{R367_OFDM_TOPCTRL				,0x02},
++	//{R367_OFDM_IOCFG0				,0x40},
++	//{R367_OFDM_DAC0R				,0x00},
++	//{R367_OFDM_IOCFG1				,0x00},
++	//{R367_OFDM_DAC1R				,0x00},
++	//{R367_OFDM_IOCFG2				,0x62},
++	//{R367_OFDM_SDFR 				,0x00},
++	//{R367_OFDM_STATUS				,0xf8},
++	//{R367_OFDM_AUX_CLK				,0x0a},
++	//{R367_OFDM_FREESYS1			,0x00},
++	//{R367_OFDM_FREESYS2			,0x00},
++	//{R367_OFDM_FREESYS3			,0x00},
++	//{R367_OFDM_GPIO_CFG			,0x55},
++	//{R367_OFDM_GPIO_CMD			,0x00},
++	{R367_OFDM_AGC2MAX				,0xff},
++	{R367_OFDM_AGC2MIN				,0x00},
++	{R367_OFDM_AGC1MAX				,0xff},
++	{R367_OFDM_AGC1MIN				,0x00},
++	{R367_OFDM_AGCR					,0xbc},
++	{R367_OFDM_AGC2TH				,0x00},
++	//{R367_OFDM_AGC12C				,0x01}, //Note: This defines AGC pins, also needed for QAM
++	{R367_OFDM_AGCCTRL1			,0x85},
++	{R367_OFDM_AGCCTRL2			,0x1f},
++	{R367_OFDM_AGC1VAL1			,0x00},
++	{R367_OFDM_AGC1VAL2			,0x00},
++	{R367_OFDM_AGC2VAL1			,0x6f},
++	{R367_OFDM_AGC2VAL2			,0x05},
++	{R367_OFDM_AGC2PGA				,0x00},
++	{R367_OFDM_OVF_RATE1			,0x00},
++	{R367_OFDM_OVF_RATE2			,0x00},
++	{R367_OFDM_GAIN_SRC1			,0x2b},
++	{R367_OFDM_GAIN_SRC2			,0x04},
++	{R367_OFDM_INC_DEROT1			,0x55},
++	{R367_OFDM_INC_DEROT2			,0x55},
++	{R367_OFDM_PPM_CPAMP_DIR		,0x2c},
++	{R367_OFDM_PPM_CPAMP_INV		,0x00},
++	{R367_OFDM_FREESTFE_1			,0x00},
++	{R367_OFDM_FREESTFE_2			,0x1c},
++	{R367_OFDM_DCOFFSET			,0x00},
++	{R367_OFDM_EN_PROCESS			,0x05},
++	{R367_OFDM_SDI_SMOOTHER		,0x80},
++	{R367_OFDM_FE_LOOP_OPEN		,0x1c},
++	{R367_OFDM_FREQOFF1			,0x00},
++	{R367_OFDM_FREQOFF2			,0x00},
++	{R367_OFDM_FREQOFF3			,0x00},
++	{R367_OFDM_TIMOFF1				,0x00},
++	{R367_OFDM_TIMOFF2				,0x00},
++	{R367_OFDM_EPQ					,0x02},
++	{R367_OFDM_EPQAUTO				,0x01},
++	{R367_OFDM_SYR_UPDATE			,0xf5},
++	{R367_OFDM_CHPFREE						,0x00},
++	{R367_OFDM_PPM_STATE_MAC		      ,0x23},
++	{R367_OFDM_INR_THRESHOLD		      ,0xff},
++	{R367_OFDM_EPQ_TPS_ID_CELL	      ,0xf9},
++	{R367_OFDM_EPQ_CFG				      ,0x00},
++	{R367_OFDM_EPQ_STATUS			      ,0x01},
++	{R367_OFDM_AUTORELOCK			      ,0x81},
++	{R367_OFDM_BER_THR_VMSB		      ,0x00},
++	{R367_OFDM_BER_THR_MSB		      ,0x00},
++	{R367_OFDM_BER_THR_LSB		      ,0x00},
++	{R367_OFDM_CCD					      ,0x83},
++	{R367_OFDM_SPECTR_CFG			      ,0x00},
++	{R367_OFDM_CHC_DUMMY			      ,0x18},
++	{R367_OFDM_INC_CTL				      ,0x88},
++	{R367_OFDM_INCTHRES_COR1		      ,0xb4},
++	{R367_OFDM_INCTHRES_COR2		      ,0x96},
++	{R367_OFDM_INCTHRES_DET1		      ,0x0e},
++	{R367_OFDM_INCTHRES_DET2		      ,0x11},
++	{R367_OFDM_IIR_CELLNB				   ,0x8d},
++	{R367_OFDM_IIRCX_COEFF1_MSB	      ,0x00},
++	{R367_OFDM_IIRCX_COEFF1_LSB	      ,0x00},
++	{R367_OFDM_IIRCX_COEFF2_MSB	      ,0x09},
++	{R367_OFDM_IIRCX_COEFF2_LSB	      ,0x18},
++	{R367_OFDM_IIRCX_COEFF3_MSB	      ,0x14},
++	{R367_OFDM_IIRCX_COEFF3_LSB	      ,0x9c},
++	{R367_OFDM_IIRCX_COEFF4_MSB	      ,0x00},
++	{R367_OFDM_IIRCX_COEFF4_LSB	      ,0x00},
++	{R367_OFDM_IIRCX_COEFF5_MSB	      ,0x36},
++	{R367_OFDM_IIRCX_COEFF5_LSB			,0x42},
++	{R367_OFDM_FEPATH_CFG			      ,0x00},
++	{R367_OFDM_PMC1_FUNC			      ,0x65},
++	{R367_OFDM_PMC1_FOR			      ,0x00},
++	{R367_OFDM_PMC2_FUNC			      ,0x00},
++	{R367_OFDM_STATUS_ERR_DA		      ,0xe0},
++	{R367_OFDM_DIG_AGC_R			      ,0xfe},
++	{R367_OFDM_COMAGC_TARMSB		      ,0x0b},
++	{R367_OFDM_COM_AGC_TAR_ENMODE     ,0x41},
++	{R367_OFDM_COM_AGC_CFG			   ,0x3e},
++	{R367_OFDM_COM_AGC_GAIN1				,0x39},
++	{R367_OFDM_AUT_AGC_TARGETMSB	   ,0x0b},
++	{R367_OFDM_LOCK_DET_MSB			   ,0x01},
++	{R367_OFDM_AGCTAR_LOCK_LSBS		   ,0x40},
++	{R367_OFDM_AUT_GAIN_EN		      ,0xf4},
++	{R367_OFDM_AUT_CFG				      ,0xf0},
++	{R367_OFDM_LOCKN				      ,0x23},
++	{R367_OFDM_INT_X_3				      ,0x00},
++	{R367_OFDM_INT_X_2				      ,0x03},
++	{R367_OFDM_INT_X_1				      ,0x8d},
++	{R367_OFDM_INT_X_0				      ,0xa0},
++	{R367_OFDM_MIN_ERRX_MSB		      ,0x00},
++	{R367_OFDM_COR_CTL				      ,0x00},
++	{R367_OFDM_COR_STAT			      ,0xf6},
++	{R367_OFDM_COR_INTEN			      ,0x00},
++	{R367_OFDM_COR_INTSTAT		      ,0x3f},
++	{R367_OFDM_COR_MODEGUARD		      ,0x03},
++	{R367_OFDM_AGC_CTL				      ,0x08},
++	{R367_OFDM_AGC_MANUAL1		      ,0x00},
++	{R367_OFDM_AGC_MANUAL2		      ,0x00},
++	{R367_OFDM_AGC_TARG			      ,0x16},
++	{R367_OFDM_AGC_GAIN1			      ,0x53},
++	{R367_OFDM_AGC_GAIN2			      ,0x1d},
++	{R367_OFDM_RESERVED_1			      ,0x00},
++	{R367_OFDM_RESERVED_2			      ,0x00},
++	{R367_OFDM_RESERVED_3			      ,0x00},
++	{R367_OFDM_CAS_CTL				      ,0x44},
++	{R367_OFDM_CAS_FREQ			      ,0xb3},
++	{R367_OFDM_CAS_DAGCGAIN		      ,0x12},
++	{R367_OFDM_SYR_CTL				      ,0x04},
++	{R367_OFDM_SYR_STAT			      ,0x10},
++	{R367_OFDM_SYR_NCO1			      ,0x00},
++	{R367_OFDM_SYR_NCO2			      ,0x00},
++	{R367_OFDM_SYR_OFFSET1		      ,0x00},
++	{R367_OFDM_SYR_OFFSET2		      ,0x00},
++	{R367_OFDM_FFT_CTL				      ,0x00},
++	{R367_OFDM_SCR_CTL				      ,0x70},
++	{R367_OFDM_PPM_CTL1			      ,0xf8},
++	{R367_OFDM_TRL_CTL				      ,0xac},
++	{R367_OFDM_TRL_NOMRATE1		      ,0x1e},
++	{R367_OFDM_TRL_NOMRATE2		      ,0x58},
++	{R367_OFDM_TRL_TIME1			      ,0x1d},
++	{R367_OFDM_TRL_TIME2			      ,0xfc},
++	{R367_OFDM_CRL_CTL				      ,0x24},
++	{R367_OFDM_CRL_FREQ1			      ,0xad},
++	{R367_OFDM_CRL_FREQ2			      ,0x9d},
++	{R367_OFDM_CRL_FREQ3			      ,0xff},
++	{R367_OFDM_CHC_CTL		       ,0x01},
++	{R367_OFDM_CHC_SNR				      ,0xf0},
++	{R367_OFDM_BDI_CTL				      ,0x00},
++	{R367_OFDM_DMP_CTL				      ,0x00},
++	{R367_OFDM_TPS_RCVD1			      ,0x30},
++	{R367_OFDM_TPS_RCVD2			      ,0x02},
++	{R367_OFDM_TPS_RCVD3			      ,0x01},
++	{R367_OFDM_TPS_RCVD4			      ,0x00},
++	{R367_OFDM_TPS_ID_CELL1		      ,0x00},
++	{R367_OFDM_TPS_ID_CELL2		      ,0x00},
++	{R367_OFDM_TPS_RCVD5_SET1	      ,0x02},
++	{R367_OFDM_TPS_SET2			      ,0x02},
++	{R367_OFDM_TPS_SET3			      ,0x01},
++	{R367_OFDM_TPS_CTL				      ,0x00},
++	{R367_OFDM_CTL_FFTOSNUM		      ,0x34},
++	{R367_OFDM_TESTSELECT			      ,0x09},
++	{R367_OFDM_MSC_REV 			      ,0x0a},
++	{R367_OFDM_PIR_CTL 			      ,0x00},
++	{R367_OFDM_SNR_CARRIER1 		      ,0xa1},
++	{R367_OFDM_SNR_CARRIER2		      ,0x9a},
++	{R367_OFDM_PPM_CPAMP			      ,0x2c},
++	{R367_OFDM_TSM_AP0				      ,0x00},
++	{R367_OFDM_TSM_AP1				      ,0x00},
++	{R367_OFDM_TSM_AP2 			      ,0x00},
++	{R367_OFDM_TSM_AP3				      ,0x00},
++	{R367_OFDM_TSM_AP4				      ,0x00},
++	{R367_OFDM_TSM_AP5				      ,0x00},
++	{R367_OFDM_TSM_AP6				      ,0x00},
++	{R367_OFDM_TSM_AP7				      ,0x00},
++	//{R367_OFDM_TSTRES				 ,0x00},
++	//{R367_OFDM_ANACTRL				 ,0x0D},/*caution PLL stopped, to be restarted at init!!!*/
++	//{R367_OFDM_TSTBUS				      ,0x00},
++	//{R367_OFDM_TSTRATE				      ,0x00},
++	{R367_OFDM_CONSTMODE			      ,0x01},
++	{R367_OFDM_CONSTCARR1			      ,0x00},
++	{R367_OFDM_CONSTCARR2			      ,0x00},
++	{R367_OFDM_ICONSTEL			      ,0x0a},
++	{R367_OFDM_QCONSTEL			      ,0x15},
++	{R367_OFDM_TSTBISTRES0		      ,0x00},
++	{R367_OFDM_TSTBISTRES1		      ,0x00},
++	{R367_OFDM_TSTBISTRES2		      ,0x28},
++	{R367_OFDM_TSTBISTRES3		      ,0x00},
++	//{R367_OFDM_RF_AGC1				      ,0xff},
++	//{R367_OFDM_RF_AGC2				      ,0x83},
++	//{R367_OFDM_ANADIGCTRL			      ,0x19},
++	//{R367_OFDM_PLLMDIV				      ,0x0c},
++	//{R367_OFDM_PLLNDIV				      ,0x55},
++	//{R367_OFDM_PLLSETUP			      ,0x18},
++	//{R367_OFDM_DUAL_AD12			      ,0x00},
++	//{R367_OFDM_TSTBIST				      ,0x00},
++	//{R367_OFDM_PAD_COMP_CTRL		      ,0x00},
++	//{R367_OFDM_PAD_COMP_WR		      ,0x00},
++	//{R367_OFDM_PAD_COMP_RD		      ,0xe0},
++	{R367_OFDM_SYR_TARGET_FFTADJT_MSB	,0x00},
++	{R367_OFDM_SYR_TARGET_FFTADJT_LSB ,0x00},
++	{R367_OFDM_SYR_TARGET_CHCADJT_MSB ,0x00},
++	{R367_OFDM_SYR_TARGET_CHCADJT_LSB ,0x00},
++	{R367_OFDM_SYR_FLAG			 ,0x00},
++	{R367_OFDM_CRL_TARGET1		 ,0x00},
++	{R367_OFDM_CRL_TARGET2		 ,0x00},
++	{R367_OFDM_CRL_TARGET3		 ,0x00},
++	{R367_OFDM_CRL_TARGET4		 ,0x00},
++	{R367_OFDM_CRL_FLAG			 ,0x00},
++	{R367_OFDM_TRL_TARGET1		 ,0x00},
++	{R367_OFDM_TRL_TARGET2		 ,0x00},
++	{R367_OFDM_TRL_CHC				 ,0x00},
++	{R367_OFDM_CHC_SNR_TARG		 ,0x00},
++	{R367_OFDM_TOP_TRACK			      ,0x00},
++	{R367_OFDM_TRACKER_FREE1		 ,0x00},
++	{R367_OFDM_ERROR_CRL1			 ,0x00},
++	{R367_OFDM_ERROR_CRL2			 ,0x00},
++	{R367_OFDM_ERROR_CRL3			 ,0x00},
++	{R367_OFDM_ERROR_CRL4			 ,0x00},
++	{R367_OFDM_DEC_NCO1			 ,0x2c},
++	{R367_OFDM_DEC_NCO2			 ,0x0f},
++	{R367_OFDM_DEC_NCO3			 ,0x20},
++	{R367_OFDM_SNR					 ,0xf1},
++	{R367_OFDM_SYR_FFTADJ1		      ,0x00},
++	{R367_OFDM_SYR_FFTADJ2		 ,0x00},
++	{R367_OFDM_SYR_CHCADJ1		 ,0x00},
++	{R367_OFDM_SYR_CHCADJ2		 ,0x00},
++	{R367_OFDM_SYR_OFF				 ,0x00},
++	{R367_OFDM_PPM_OFFSET1		      ,0x00},
++	{R367_OFDM_PPM_OFFSET2		 ,0x03},
++	{R367_OFDM_TRACKER_FREE2		 ,0x00},
++	{R367_OFDM_DEBG_LT10			 ,0x00},
++	{R367_OFDM_DEBG_LT11			 ,0x00},
++	{R367_OFDM_DEBG_LT12			      ,0x00},
++	{R367_OFDM_DEBG_LT13			 ,0x00},
++	{R367_OFDM_DEBG_LT14			 ,0x00},
++	{R367_OFDM_DEBG_LT15			 ,0x00},
++	{R367_OFDM_DEBG_LT16			 ,0x00},
++	{R367_OFDM_DEBG_LT17			 ,0x00},
++	{R367_OFDM_DEBG_LT18			 ,0x00},
++	{R367_OFDM_DEBG_LT19			 ,0x00},
++	{R367_OFDM_DEBG_LT1A			 ,0x00},
++	{R367_OFDM_DEBG_LT1B			 ,0x00},
++	{R367_OFDM_DEBG_LT1C 			 ,0x00},
++	{R367_OFDM_DEBG_LT1D 			 ,0x00},
++	{R367_OFDM_DEBG_LT1E			 ,0x00},
++	{R367_OFDM_DEBG_LT1F			 ,0x00},
++	{R367_OFDM_RCCFGH				 ,0x00},
++	{R367_OFDM_RCCFGM						,0x00},
++	{R367_OFDM_RCCFGL						,0x00},
++	{R367_OFDM_RCINSDELH					,0x00},
++	{R367_OFDM_RCINSDELM			 ,0x00},
++	{R367_OFDM_RCINSDELL			 ,0x00},
++	{R367_OFDM_RCSTATUS			 ,0x00},
++	{R367_OFDM_RCSPEED 			 ,0x6f},
++	{R367_OFDM_RCDEBUGM			 ,0xe7},
++	{R367_OFDM_RCDEBUGL			 ,0x9b},
++	{R367_OFDM_RCOBSCFG			 ,0x00},
++	{R367_OFDM_RCOBSM 				 ,0x00},
++	{R367_OFDM_RCOBSL 				 ,0x00},
++	{R367_OFDM_RCFECSPY			 ,0x00},
++	{R367_OFDM_RCFSPYCFG 			 ,0x00},
++	{R367_OFDM_RCFSPYDATA			 ,0x00},
++	{R367_OFDM_RCFSPYOUT 			 ,0x00},
++	{R367_OFDM_RCFSTATUS 			 ,0x00},
++	{R367_OFDM_RCFGOODPACK		 ,0x00},
++	{R367_OFDM_RCFPACKCNT 		 ,0x00},
++	{R367_OFDM_RCFSPYMISC 		 ,0x00},
++	{R367_OFDM_RCFBERCPT4 		 ,0x00},
++	{R367_OFDM_RCFBERCPT3 		 ,0x00},
++	{R367_OFDM_RCFBERCPT2 		 ,0x00},
++	{R367_OFDM_RCFBERCPT1 		 ,0x00},
++	{R367_OFDM_RCFBERCPT0 		 ,0x00},
++	{R367_OFDM_RCFBERERR2 		 ,0x00},
++	{R367_OFDM_RCFBERERR1 		 ,0x00},
++	{R367_OFDM_RCFBERERR0 		 ,0x00},
++	{R367_OFDM_RCFSTATESM 		 ,0x00},
++	{R367_OFDM_RCFSTATESL 		 ,0x00},
++	{R367_OFDM_RCFSPYBER  		 ,0x00},
++	{R367_OFDM_RCFSPYDISTM		 ,0x00},
++	{R367_OFDM_RCFSPYDISTL		 ,0x00},
++	{R367_OFDM_RCFSPYOBS7 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS6 		      ,0x00},
++	{R367_OFDM_RCFSPYOBS5 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS4 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS3 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS2 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS1 		 ,0x00},
++	{R367_OFDM_RCFSPYOBS0			 ,0x00},
++	//{R367_OFDM_TSGENERAL 			 ,0x00},
++	//{R367_OFDM_RC1SPEED  			 ,0x6f},
++	//{R367_OFDM_TSGSTATUS			 ,0x18},
++	{R367_OFDM_FECM					 ,0x01},
++	{R367_OFDM_VTH12				 ,0xff},
++	{R367_OFDM_VTH23				 ,0xa1},
++	{R367_OFDM_VTH34				 ,0x64},
++	{R367_OFDM_VTH56				 ,0x40},
++	{R367_OFDM_VTH67				 ,0x00},
++	{R367_OFDM_VTH78				 ,0x2c},
++	{R367_OFDM_VITCURPUN			 ,0x12},
++	{R367_OFDM_VERROR				 ,0x01},
++	{R367_OFDM_PRVIT				 ,0x3f},
++	{R367_OFDM_VAVSRVIT			 ,0x00},
++	{R367_OFDM_VSTATUSVIT			 ,0xbd},
++	{R367_OFDM_VTHINUSE 			 ,0xa1},
++	{R367_OFDM_KDIV12				 ,0x20},
++	{R367_OFDM_KDIV23				 ,0x40},
++	{R367_OFDM_KDIV34				 ,0x20},
++	{R367_OFDM_KDIV56				 ,0x30},
++	{R367_OFDM_KDIV67				 ,0x00},
++	{R367_OFDM_KDIV78				 ,0x30},
++	{R367_OFDM_SIGPOWER 			 ,0x54},
++	{R367_OFDM_DEMAPVIT 			 ,0x40},
++	{R367_OFDM_VITSCALE 			 ,0x00},
++	{R367_OFDM_FFEC1PRG 			 ,0x00},
++	{R367_OFDM_FVITCURPUN 		 ,0x12},
++	{R367_OFDM_FVERROR 			 ,0x01},
++	{R367_OFDM_FVSTATUSVIT		 ,0xbd},
++	{R367_OFDM_DEBUG_LT1			 ,0x00},
++	{R367_OFDM_DEBUG_LT2			 ,0x00},
++	{R367_OFDM_DEBUG_LT3			 ,0x00},
++	{R367_OFDM_TSTSFMET  			 ,0x00},
++	{R367_OFDM_SELOUT				 ,0x00},
++	{R367_OFDM_TSYNC				 ,0x00},
++	{R367_OFDM_TSTERR				 ,0x00},
++	{R367_OFDM_TSFSYNC   			 ,0x00},
++	{R367_OFDM_TSTSFERR  			 ,0x00},
++	{R367_OFDM_TSTTSSF1  			 ,0x01},
++	{R367_OFDM_TSTTSSF2  			 ,0x1f},
++	{R367_OFDM_TSTTSSF3  			 ,0x00},
++	{R367_OFDM_TSTTS1   			 ,0x00},
++	{R367_OFDM_TSTTS2   			      ,0x1f},
++	{R367_OFDM_TSTTS3   			 ,0x01},
++	{R367_OFDM_TSTTS4   			 ,0x00},
++	{R367_OFDM_TSTTSRC  			 ,0x00},
++	{R367_OFDM_TSTTSRS  			 ,0x00},
++	{R367_OFDM_TSSTATEM			 ,0xb0},
++	{R367_OFDM_TSSTATEL			 ,0x40},
++	{R367_OFDM_TSCFGH  			 ,0x80},
++	{R367_OFDM_TSCFGM  			 ,0x00},
++	{R367_OFDM_TSCFGL  			 ,0x20},
++	{R367_OFDM_TSSYNC  			 ,0x00},
++	{R367_OFDM_TSINSDELH			 ,0x00},
++	{R367_OFDM_TSINSDELM 			 ,0x00},
++	{R367_OFDM_TSINSDELL			 ,0x00},
++	{R367_OFDM_TSDIVN				 ,0x03},
++	{R367_OFDM_TSDIVPM				 ,0x00},
++	{R367_OFDM_TSDIVPL				 ,0x00},
++	{R367_OFDM_TSDIVQM 			 ,0x00},
++	{R367_OFDM_TSDIVQL				 ,0x00},
++	{R367_OFDM_TSDILSTKM			 ,0x00},
++	{R367_OFDM_TSDILSTKL			 ,0x00},
++	{R367_OFDM_TSSPEED				 ,0x6f},
++	{R367_OFDM_TSSTATUS			 ,0x81},
++	{R367_OFDM_TSSTATUS2			 ,0x6a},
++	{R367_OFDM_TSBITRATEM			 ,0x0f},
++	{R367_OFDM_TSBITRATEL			 ,0xc6},
++	{R367_OFDM_TSPACKLENM			 ,0x00},
++	{R367_OFDM_TSPACKLENL			 ,0xfc},
++	{R367_OFDM_TSBLOCLENM			 ,0x0a},
++	{R367_OFDM_TSBLOCLENL			 ,0x80},
++	{R367_OFDM_TSDLYH 				 ,0x90},
++	{R367_OFDM_TSDLYM				 ,0x68},
++	{R367_OFDM_TSDLYL				 ,0x01},
++	{R367_OFDM_TSNPDAV				 ,0x00},
++	{R367_OFDM_TSBUFSTATH 		 ,0x00},
++	{R367_OFDM_TSBUFSTATM 		 ,0x00},
++	{R367_OFDM_TSBUFSTATL			 ,0x00},
++	{R367_OFDM_TSDEBUGM			 ,0xcf},
++	{R367_OFDM_TSDEBUGL			 ,0x1e},
++	{R367_OFDM_TSDLYSETH 			 ,0x00},
++	{R367_OFDM_TSDLYSETM			 ,0x68},
++	{R367_OFDM_TSDLYSETL			 ,0x00},
++	{R367_OFDM_TSOBSCFG			 ,0x00},
++	{R367_OFDM_TSOBSM 				 ,0x47},
++	{R367_OFDM_TSOBSL				 ,0x1f},
++	{R367_OFDM_ERRCTRL1			 ,0x95},
++	{R367_OFDM_ERRCNT1H 			 ,0x80},
++	{R367_OFDM_ERRCNT1M 			 ,0x00},
++	{R367_OFDM_ERRCNT1L 			 ,0x00},
++	{R367_OFDM_ERRCTRL2			 ,0x95},
++	{R367_OFDM_ERRCNT2H			 ,0x00},
++	{R367_OFDM_ERRCNT2M			 ,0x00},
++	{R367_OFDM_ERRCNT2L			 ,0x00},
++	{R367_OFDM_FECSPY 				 ,0x88},
++	{R367_OFDM_FSPYCFG				 ,0x2c},
++	{R367_OFDM_FSPYDATA			 ,0x3a},
++	{R367_OFDM_FSPYOUT				 ,0x06},
++	{R367_OFDM_FSTATUS				 ,0x61},
++	{R367_OFDM_FGOODPACK			 ,0xff},
++	{R367_OFDM_FPACKCNT			 ,0xff},
++	{R367_OFDM_FSPYMISC 			 ,0x66},
++	{R367_OFDM_FBERCPT4 			 ,0x00},
++	{R367_OFDM_FBERCPT3			 ,0x00},
++	{R367_OFDM_FBERCPT2			 ,0x36},
++	{R367_OFDM_FBERCPT1			 ,0x36},
++	{R367_OFDM_FBERCPT0 			 ,0x14},
++	{R367_OFDM_FBERERR2			 ,0x00},
++	{R367_OFDM_FBERERR1			 ,0x03},
++	{R367_OFDM_FBERERR0			 ,0x28},
++	{R367_OFDM_FSTATESM			 ,0x00},
++	{R367_OFDM_FSTATESL			 ,0x02},
++	{R367_OFDM_FSPYBER 			 ,0x00},
++	{R367_OFDM_FSPYDISTM			 ,0x01},
++	{R367_OFDM_FSPYDISTL			 ,0x9f},
++	{R367_OFDM_FSPYOBS7 			 ,0xc9},
++	{R367_OFDM_FSPYOBS6 			 ,0x99},
++	{R367_OFDM_FSPYOBS5			 ,0x08},
++	{R367_OFDM_FSPYOBS4			 ,0xec},
++	{R367_OFDM_FSPYOBS3			 ,0x01},
++	{R367_OFDM_FSPYOBS2			 ,0x0f},
++	{R367_OFDM_FSPYOBS1			 ,0xf5},
++	{R367_OFDM_FSPYOBS0			 ,0x08},
++	{R367_OFDM_SFDEMAP 			 ,0x40},
++	{R367_OFDM_SFERROR 			 ,0x00},
++	{R367_OFDM_SFAVSR  			 ,0x30},
++	{R367_OFDM_SFECSTATUS			 ,0xcc},
++	{R367_OFDM_SFKDIV12			 ,0x20},
++	{R367_OFDM_SFKDIV23			 ,0x40},
++	{R367_OFDM_SFKDIV34			 ,0x20},
++	{R367_OFDM_SFKDIV56			 ,0x20},
++	{R367_OFDM_SFKDIV67			 ,0x00},
++	{R367_OFDM_SFKDIV78			 ,0x20},
++	{R367_OFDM_SFDILSTKM			 ,0x00},
++	{R367_OFDM_SFDILSTKL 			 ,0x00},
++	{R367_OFDM_SFSTATUS			 ,0xb5},
++	{R367_OFDM_SFDLYH				 ,0x90},
++	{R367_OFDM_SFDLYM				 ,0x60},
++	{R367_OFDM_SFDLYL				 ,0x01},
++	{R367_OFDM_SFDLYSETH			 ,0xc0},
++	{R367_OFDM_SFDLYSETM			 ,0x60},
++	{R367_OFDM_SFDLYSETL			 ,0x00},
++	{R367_OFDM_SFOBSCFG 			 ,0x00},
++	{R367_OFDM_SFOBSM 				 ,0x47},
++	{R367_OFDM_SFOBSL				 ,0x05},
++	{R367_OFDM_SFECINFO 			 ,0x40},
++	{R367_OFDM_SFERRCTRL 			 ,0x74},
++	{R367_OFDM_SFERRCNTH			 ,0x80},
++	{R367_OFDM_SFERRCNTM 			 ,0x00},
++	{R367_OFDM_SFERRCNTL			 ,0x00},
++	{R367_OFDM_SYMBRATEM			 ,0x2f},
++	{R367_OFDM_SYMBRATEL			      ,0x50},
++	{R367_OFDM_SYMBSTATUS			 ,0x7f},
++	{R367_OFDM_SYMBCFG 			 ,0x00},
++	{R367_OFDM_SYMBFIFOM 			 ,0xf4},
++	{R367_OFDM_SYMBFIFOL 			 ,0x0d},
++	{R367_OFDM_SYMBOFFSM 			 ,0xf0},
++	{R367_OFDM_SYMBOFFSL 			 ,0x2d},
++	//{R367_OFDM_DEBUG_LT4			 ,0x00},
++	//{R367_OFDM_DEBUG_LT5			 ,0x00},
++	//{R367_OFDM_DEBUG_LT6			 ,0x00},
++	//{R367_OFDM_DEBUG_LT7			 ,0x00},
++	//{R367_OFDM_DEBUG_LT8			 ,0x00},
++	//{R367_OFDM_DEBUG_LT9			 ,0x00},
++	{ 0x0000, 0x00 } // EOT
++};
++
++inline u32 MulDiv32(u32 a, u32 b, u32 c)
++{
++	u64 tmp64;
++
++	tmp64 = (u64)a * (u64)b;
++	do_div(tmp64, c);
++
++	return (u32) tmp64;
++}
++
++static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
++{
++	struct i2c_msg msg =
++		{.addr = adr, .flags = 0, .buf = data, .len = len};
++
++	if (i2c_transfer(adap, &msg, 1) != 1) {
++		printk("stv0367: i2c_write error\n");
++		return -1;
++	}
++	return 0;
++}
++
++#if 0
++static int i2c_read(struct i2c_adapter *adap,
++		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
++{
++	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
++				     .buf = msg, .len = len},
++				   { .addr = adr, .flags = I2C_M_RD,
++				     .buf = answ, .len = alen } };
++	if (i2c_transfer(adap, msgs, 2) != 2) {
++		printk("stv0367: i2c_read error\n");
++		return -1;
++	}
++	return 0;
++}
++#endif
++
++static int writereg(struct stv_state *state, u16 reg, u8 dat)
++{
++	u8 mm[3] = { (reg >> 8), reg & 0xff, dat };
++
++	return i2c_write(state->i2c, state->adr, mm, 3);
++}
++
++static int readreg(struct stv_state *state, u16 reg, u8 *val)
++{
++	u8 msg[2] = {reg >> 8, reg & 0xff};
++	struct i2c_msg msgs[2] = {{.addr = state->adr, .flags = 0,
++				   .buf  = msg, .len   = 2},
++				  {.addr = state->adr, .flags = I2C_M_RD,
++				   .buf  = val, .len   = 1}};
++	return (i2c_transfer(state->i2c, msgs, 2) == 2) ? 0 : -1;
++}
++
++static int readregs(struct stv_state *state, u16 reg, u8 *val, int count)
++{
++	u8 msg[2] = {reg >> 8, reg & 0xff};
++	struct i2c_msg msgs[2] = {{.addr = state->adr, .flags = 0,
++				   .buf  = msg, .len   = 2},
++				  {.addr = state->adr, .flags = I2C_M_RD,
++				   .buf  = val, .len   = count}};
++	return (i2c_transfer(state->i2c, msgs, 2) == 2) ? 0 : -1;
++}
++
++static int write_init_table(struct stv_state *state, struct init_table *tab)
++{
++	while (1) {
++		if (!tab->adr)
++			break;
++		if (writereg(state, tab->adr, tab->data) < 0)
++			return -1;
++		tab++;
++	}
++	return 0;
++}
++
++static int qam_set_modulation(struct stv_state *state)
++{
++	int stat = 0;
++
++	switch(state->modulation) {
++	case QAM_16:
++		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM16 );
++		writereg(state, R367_QAM_AGC_PWR_REF_L,0x64);       /* Set analog AGC reference */
++		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);   /* Set digital AGC reference */
++		writereg(state, R367_QAM_FSM_STATE,0x90);
++		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
++		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x95);
++		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
++		writereg(state, R367_QAM_EQU_PNT_GAIN,0x8a);
++		break;
++	case QAM_32:
++		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM32 );
++		writereg(state, R367_QAM_AGC_PWR_REF_L,0x6e);       /* Set analog AGC reference */
++		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);   /* Set digital AGC reference */
++		writereg(state, R367_QAM_FSM_STATE,0xb0);
++		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xb7);
++		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x9d);
++		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x7f);
++		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
++		break;
++	case QAM_64:
++		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM64 );
++		writereg(state, R367_QAM_AGC_PWR_REF_L,0x5a);       /* Set analog AGC reference */
++		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x82);   /* Set digital AGC reference */
++		if(state->symbol_rate>4500000)
++		{
++			writereg(state, R367_QAM_FSM_STATE,0xb0);
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa5);
++		}
++		else if(state->symbol_rate>2500000) // 25000000
++		{
++			writereg(state, R367_QAM_FSM_STATE,0xa0);
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa6);
++		}
++		else
++		{
++			writereg(state, R367_QAM_FSM_STATE,0xa0);
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xd1);
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
++		}
++		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x95);
++		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
++		writereg(state, R367_QAM_EQU_PNT_GAIN,0x99);
++		break;
++	case QAM_128:
++		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM128 );
++		writereg(state, R367_QAM_AGC_PWR_REF_L,0x76);       /* Set analog AGC reference */
++		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);	/* Set digital AGC reference */
++		writereg(state, R367_QAM_FSM_STATE,0x90);
++		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xb1);
++		if(state->symbol_rate>4500000) // 45000000
++		{
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
++		}
++		else if(state->symbol_rate>2500000) // 25000000
++		{
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa6);
++		}
++		else
++		{
++			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0x97);
++		}
++		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x8e);
++		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x7f);
++		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
++		break;
++	case QAM_256:
++		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM256 );
++		writereg(state, R367_QAM_AGC_PWR_REF_L,0x5a);     /* Set analog AGC reference */
++		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x94); /* Set digital AGC reference */
++		writereg(state, R367_QAM_FSM_STATE,0xa0);
++		if(state->symbol_rate>4500000) // 45000000
++		{
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++		}
++		else if(state->symbol_rate>2500000) // 25000000
++		{
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
++		}
++		else
++		{
++			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xd1);
++		}
++		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
++		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x85);
++		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
++		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
++		break;
++	default:
++		stat = -EINVAL;
++		break;
++	}
++	return stat;
++}
++
++
++static int QAM_SetSymbolRate(struct stv_state *state)
++{
++	int status = 0;
++	u32 sr = state->symbol_rate;
++	u32 Corr = 0;
++	u32 Temp, Temp1, AdpClk;
++
++	switch(state->modulation) {
++	default:
++	case QAM_16:   Corr = 1032; break;
++	case QAM_32:   Corr =  954; break;
++	case QAM_64:   Corr =  983; break;
++	case QAM_128:  Corr =  957; break;
++	case QAM_256:  Corr =  948; break;
++	}
++
++	// Transfer ration
++	Temp = (256*sr) / state->adc_clock;
++	writereg(state, R367_QAM_EQU_CRL_TFR,(Temp));
++
++	/* Symbol rate and SRC gain calculation */
++	AdpClk = (state->master_clock)/2000; /* TRL works at half the system clock */
++
++	Temp = state->symbol_rate;
++	Temp1 = sr;
++
++	if(sr < 2097152)				/* 2097152 = 2^21 */
++	{
++		Temp  = ((((sr * 2048) / AdpClk) * 16384 ) / 125 ) * 8;
++		Temp1 = (((((sr * 2048) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 10000000;
++	}
++	else if(sr < 4194304)			/* 4194304 = 2**22 */
++	{
++		Temp  = ((((sr * 1024) / AdpClk) * 16384 ) / 125 ) * 16;
++		Temp1 = (((((sr * 1024) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 5000000;
++	}
++	else if(sr < 8388608)			/* 8388608 = 2**23 */
++	{
++		Temp  = ((((sr * 512) / AdpClk) * 16384 ) / 125 ) * 32;
++		Temp1 = (((((sr * 512) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 2500000;
++	}
++	else
++	{
++		Temp  = ((((sr * 256) / AdpClk) * 16384 ) / 125 ) * 64;
++		Temp1 = (((((sr * 256) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 1250000;
++	}
++
++	///* Filters' coefficients are calculated and written into registers only if the filters are enabled */
++	//if (ChipGetField(hChip,F367qam_ADJ_EN)) // Is disabled from init!
++	//{
++	//    FE_367qam_SetIirAdjacentcoefficient(hChip, MasterClk_Hz, SymbolRate);
++	//}
++	///* AllPass filter is never used on this IC */
++	//ChipSetField(hChip,F367qam_ALLPASSFILT_EN,0); // should be disabled from init!
++
++	writereg(state, R367_QAM_SRC_NCO_LL,(Temp));
++	writereg(state, R367_QAM_SRC_NCO_LH,(Temp>>8));
++	writereg(state, R367_QAM_SRC_NCO_HL,(Temp>>16));
++	writereg(state, R367_QAM_SRC_NCO_HH,(Temp>>24));
++
++	writereg(state, R367_QAM_IQDEM_GAIN_SRC_L,(Temp1));
++	writereg(state, R367_QAM_IQDEM_GAIN_SRC_H,(Temp1>>8));
++	return status;
++}
++
++
++static int QAM_SetDerotFrequency(struct stv_state *state, u32 DerotFrequency)
++{
++	int status = 0;
++	u32 Sampled_IF;
++
++	do {
++		//if (DerotFrequency < 1000000)
++		//    DerotFrequency = state->adc_clock/4; /* ZIF operation */
++		if (DerotFrequency > state->adc_clock)
++			DerotFrequency = DerotFrequency - state->adc_clock;	// User Alias
++
++		Sampled_IF = ((32768 * (DerotFrequency/1000)) / (state->adc_clock/1000)) * 256;
++		if(Sampled_IF > 8388607)
++			Sampled_IF = 8388607;
++
++		writereg(state, R367_QAM_MIX_NCO_LL, (Sampled_IF));
++		writereg(state, R367_QAM_MIX_NCO_HL, (Sampled_IF>>8));
++		writereg(state, R367_QAM_MIX_NCO_HH, (Sampled_IF>>16));
++	} while(0);
++
++	return status;
++}
++
++
++
++static int QAM_Start(struct stv_state *state, s32 offsetFreq,s32 IntermediateFrequency)
++{
++	int status = 0;
++	u32 AGCTimeOut = 25;
++	u32 TRLTimeOut = 100000000 / state->symbol_rate;
++	u32 CRLSymbols = 0;
++	u32 EQLTimeOut = 100;
++	u32 SearchRange = state->symbol_rate / 25;
++	u32 CRLTimeOut;
++	u8 Temp;
++
++	if( state->demod_state != QAMSet ) {
++		writereg(state, R367_DEBUG_LT4,0x00);
++		writereg(state, R367_DEBUG_LT5,0x01);
++		writereg(state, R367_DEBUG_LT6,0x06);// R367_QAM_CTRL_1
++		writereg(state, R367_DEBUG_LT7,0x03);// R367_QAM_CTRL_2
++		writereg(state, R367_DEBUG_LT8,0x00);
++		writereg(state, R367_DEBUG_LT9,0x00);
++
++		// Tuner Setup
++		writereg(state, R367_ANADIGCTRL,0x8B); /* Buffer Q disabled, I Enabled, signed ADC */
++		writereg(state, R367_DUAL_AD12,0x04); /* ADCQ disabled */
++
++		// Clock setup
++		writereg(state, R367_ANACTRL,0x0D); /* PLL bypassed and disabled */
++		writereg(state, R367_TOPCTRL,0x10); // Set QAM
++
++		writereg(state, R367_PLLMDIV,27); /* IC runs at 58 MHz with a 27 MHz crystal */
++		writereg(state, R367_PLLNDIV,232);
++		writereg(state, R367_PLLSETUP,0x18);  /* ADC clock is equal to system clock */
++
++		msleep(50);
++		writereg(state, R367_ANACTRL,0x00); /* PLL enabled and used */
++
++		state->master_clock = 58000000;
++		state->adc_clock = 58000000;
++
++		state->demod_state = QAMSet;
++	}
++
++	state->m_bFirstTimeLock = true;
++	state->m_DemodLockTime  = -1;
++
++	qam_set_modulation(state);
++	QAM_SetSymbolRate(state);
++
++	// Will make problems on low symbol rates ( < 2500000 )
++
++	switch(state->modulation) {
++	default:
++	case QAM_16:   CRLSymbols = 150000; break;
++	case QAM_32:   CRLSymbols = 250000; break;
++	case QAM_64:   CRLSymbols = 200000; break;
++	case QAM_128:  CRLSymbols = 250000; break;
++	case QAM_256:  CRLSymbols = 250000; break;
++	}
++
++	CRLTimeOut = (25 * CRLSymbols * (SearchRange/1000)) / (state->symbol_rate/1000);
++	CRLTimeOut = (1000 * CRLTimeOut) / state->symbol_rate;
++	if( CRLTimeOut < 50 ) CRLTimeOut = 50;
++
++	state->m_FECTimeOut = 20;
++	state->m_DemodTimeOut = AGCTimeOut + TRLTimeOut + CRLTimeOut + EQLTimeOut;
++	state->m_SignalTimeOut = AGCTimeOut + TRLTimeOut;
++
++	// QAM_AGC_ACCUMRSTSEL = 0;
++	readreg(state, R367_QAM_AGC_CTL,&state->m_Save_QAM_AGC_CTL);
++	writereg(state, R367_QAM_AGC_CTL,state->m_Save_QAM_AGC_CTL & ~0x0F);
++
++	// QAM_MODULUSMAP_EN = 0
++	readreg(state, R367_QAM_EQU_PNT_GAIN,&Temp);
++	writereg(state, R367_QAM_EQU_PNT_GAIN,Temp & ~0x40);
++
++	// QAM_SWEEP_EN = 0
++	readreg(state, R367_QAM_EQU_CTR_LPF_GAIN,&Temp);
++	writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,Temp & ~0x08);
++
++	QAM_SetDerotFrequency(state, IntermediateFrequency);
++
++	// Release TRL
++	writereg(state, R367_QAM_CTRL_1,0x00);
++
++	state->IF = IntermediateFrequency;
++	state->demod_state = QAMStarted;
++
++	return status;
++}
++
++static int OFDM_Start(struct stv_state *state, s32 offsetFreq,s32 IntermediateFrequency)
++{
++	int status = 0;
++	u8 GAIN_SRC1;
++	u32 Derot;
++	u8 SYR_CTL;
++	u8 tmp1;
++	u8 tmp2;
++
++	if ( state->demod_state != OFDMSet ) {
++		// QAM Disable
++		writereg(state, R367_DEBUG_LT4, 0x00);
++		writereg(state, R367_DEBUG_LT5, 0x00);
++		writereg(state, R367_DEBUG_LT6, 0x00);// R367_QAM_CTRL_1
++		writereg(state, R367_DEBUG_LT7, 0x00);// R367_QAM_CTRL_2
++		writereg(state, R367_DEBUG_LT8, 0x00);
++		writereg(state, R367_DEBUG_LT9, 0x00);
++
++		// Tuner Setup
++		writereg(state, R367_ANADIGCTRL, 0x89); /* Buffer Q disabled, I Enabled, unsigned ADC */
++		writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
++
++		// Clock setup
++		writereg(state, R367_ANACTRL, 0x0D); /* PLL bypassed and disabled */
++		writereg(state, R367_TOPCTRL, 0x00); // Set OFDM
++
++		writereg(state, R367_PLLMDIV, 1); /* IC runs at 54 MHz with a 27 MHz crystal */
++		writereg(state, R367_PLLNDIV, 8);
++		writereg(state, R367_PLLSETUP, 0x18);  /* ADC clock is equal to system clock */
++
++		msleep(50);
++		writereg(state, R367_ANACTRL, 0x00); /* PLL enabled and used */
++
++		state->master_clock = 54000000;
++		state->adc_clock    = 54000000;
++
++		state->demod_state = OFDMSet;
++	}
++
++	state->m_bFirstTimeLock = true;
++	state->m_DemodLockTime  = -1;
++
++	// Set inversion in GAIN_SRC1 (fixed from init)
++	//  is in GAIN_SRC1, see below
++
++	GAIN_SRC1 = 0xA0;
++	// Bandwidth
++
++	// Fixed values for 54 MHz
++	switch(state->bandwidth) {
++	case 0:
++	case 8000000:
++		// Normrate = 44384;
++		writereg(state, R367_OFDM_TRL_CTL,0x14);
++		writereg(state, R367_OFDM_TRL_NOMRATE1,0xB0);
++		writereg(state, R367_OFDM_TRL_NOMRATE2,0x56);
++		// Gain SRC = 2774
++		writereg(state, R367_OFDM_GAIN_SRC1,0x0A | GAIN_SRC1);
++		writereg(state, R367_OFDM_GAIN_SRC2,0xD6);
++		break;
++	case 7000000:
++		// Normrate = 38836;
++		writereg(state, R367_OFDM_TRL_CTL,0x14);
++		writereg(state, R367_OFDM_TRL_NOMRATE1,0xDA);
++		writereg(state, R367_OFDM_TRL_NOMRATE2,0x4B);
++		// Gain SRC = 2427
++		writereg(state, R367_OFDM_GAIN_SRC1,0x09 | GAIN_SRC1);
++		writereg(state, R367_OFDM_GAIN_SRC2,0x7B);
++		break;
++	case 6000000:
++		// Normrate = 33288;
++		writereg(state, R367_OFDM_TRL_CTL,0x14);
++		writereg(state, R367_OFDM_TRL_NOMRATE1,0x04);
++		writereg(state, R367_OFDM_TRL_NOMRATE2,0x41);
++		// Gain SRC = 2080
++		writereg(state, R367_OFDM_GAIN_SRC1,0x08 | GAIN_SRC1);
++		writereg(state, R367_OFDM_GAIN_SRC2,0x20);
++		break;
++	default:
++		return -EINVAL;
++		break;
++	}
++
++	Derot = ((IntermediateFrequency/1000) * 65536) / (state->master_clock / 1000);
++
++	writereg(state, R367_OFDM_INC_DEROT1,(Derot>>8));
++	writereg(state, R367_OFDM_INC_DEROT2,(Derot));
++
++	readreg(state, R367_OFDM_SYR_CTL,&SYR_CTL);
++	SYR_CTL  &= ~0x78;
++	writereg(state, R367_OFDM_SYR_CTL,SYR_CTL);    // EchoPos = 0
++
++
++	writereg(state, R367_OFDM_COR_MODEGUARD,0x03); // Force = 0, Mode = 0, Guard = 3
++	SYR_CTL &= 0x01;
++	writereg(state, R367_OFDM_SYR_CTL,SYR_CTL);    // SYR_TR_DIS = 0
++
++	msleep(5);
++
++	writereg(state, R367_OFDM_COR_CTL,0x20);    // Start core
++
++	// -- Begin M.V.
++	// Reset FEC and Read Solomon
++	readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
++	readreg(state, R367_TSGENERAL,&tmp2);
++	writereg(state, R367_OFDM_SFDLYSETH,tmp1 | 0x08);
++	writereg(state, R367_TSGENERAL,tmp2 | 0x01);
++	// -- End M.V.
++
++	state->m_SignalTimeOut = 200;
++	state->IF = IntermediateFrequency;
++	state->demod_state = OFDMStarted;
++	state->m_DemodTimeOut = 0;
++	state->m_FECTimeOut = 0;
++	state->m_TSTimeOut = 0;
++
++	return status;
++}
++
++#if 0
++static int Stop(struct stv_state *state)
++{
++	int status = 0;
++
++	switch(state->demod_state)
++	{
++	case QAMStarted:
++		status = writereg(state, R367_QAM_CTRL_1,0x06);
++		state->demod_state = QAMSet;
++		break;
++	case OFDMStarted:
++		status = writereg(state, R367_OFDM_COR_CTL,0x00);
++		state->demod_state = OFDMSet;
++		break;
++	default:
++		break;
++	}
++	return status;
++}
++#endif
++
++static s32 Log10x100(u32 x)
++{
++	static u32 LookupTable[100] = {
++		101157945, 103514217, 105925373, 108392691, 110917482,
++		113501082, 116144861, 118850223, 121618600, 124451461, // 800.5 - 809.5
++		127350308, 130316678, 133352143, 136458314, 139636836,
++		142889396, 146217717, 149623566, 153108746, 156675107, // 810.5 - 819.5
++		160324539, 164058977, 167880402, 171790839, 175792361,
++		179887092, 184077200, 188364909, 192752491, 197242274, // 820.5 - 829.5
++		201836636, 206538016, 211348904, 216271852, 221309471,
++		226464431, 231739465, 237137371, 242661010, 248313311, // 830.5 - 839.5
++		254097271, 260015956, 266072506, 272270131, 278612117,
++		285101827, 291742701, 298538262, 305492111, 312607937, // 840.5 - 849.5
++		319889511, 327340695, 334965439, 342767787, 350751874,
++		358921935, 367282300, 375837404, 384591782, 393550075, // 850.5 - 859.5
++		402717034, 412097519, 421696503, 431519077, 441570447,
++		451855944, 462381021, 473151259, 484172368, 495450191, // 860.5 - 869.5
++		506990708, 518800039, 530884444, 543250331, 555904257,
++		568852931, 582103218, 595662144, 609536897, 623734835, // 870.5 - 879.5
++		638263486, 653130553, 668343918, 683911647, 699841996,
++		716143410, 732824533, 749894209, 767361489, 785235635, // 880.5 - 889.5
++		803526122, 822242650, 841395142, 860993752, 881048873,
++		901571138, 922571427, 944060876, 966050879, 988553095, // 890.5 - 899.5
++	};
++	s32 y;
++	int i;
++
++	if (x == 0)
++		return 0;
++	y = 800;
++	if (x >= 1000000000) {
++		x /= 10;
++		y += 100;
++	}
++
++	while (x < 100000000) {
++		x *= 10;
++		y -= 100;
++	}
++	i = 0;
++	while (i < 100 && x > LookupTable[i])
++		i += 1;
++	y += i;
++	return y;
++}
++
++static int QAM_GetSignalToNoise(struct stv_state *state, s32 *pSignalToNoise)
++{
++	u32 RegValAvg = 0;
++	u8 RegVal[2];
++	int status = 0, i;
++
++	*pSignalToNoise = 0;
++	for (i = 0; i < 10; i += 1 ) {
++		readregs(state, R367_QAM_EQU_SNR_LO, RegVal, 2);
++		RegValAvg += RegVal[0] + 256 * RegVal[1];
++	}
++	if (RegValAvg != 0) {
++		s32 Power = 1;
++		switch(state->modulation) {
++		case QAM_16:
++			Power = 20480;
++			break;
++		case QAM_32:
++			Power = 23040;
++			break;
++		case QAM_64:
++			Power = 21504;
++			break;
++		case QAM_128:
++			Power = 23616; break;
++		case QAM_256:
++			Power = 21760; break;
++		default:
++			break;
++		}
++		*pSignalToNoise = Log10x100((Power * 320) / RegValAvg);
++	} else {
++		*pSignalToNoise = 380;
++	}
++	return status;
++}
++
++static int OFDM_GetSignalToNoise(struct stv_state *state, s32 *pSignalToNoise)
++{
++	u8 CHC_SNR = 0;
++
++	int status = readreg(state, R367_OFDM_CHC_SNR, &CHC_SNR);
++	if (status >= 0) {
++		// Note: very unclear documentation on this.
++		//   Datasheet states snr = CHC_SNR/4 dB  -> way to high values!
++		//   Software  snr = ( 1000 * CHC_SNR ) / 8 / 32 / 10; -> to low values
++		//   Comment in SW states this should be ( 1000 * CHC_SNR ) / 4 / 32 / 10; for the 367
++		//   361/362 Datasheet: snr = CHC_SNR/8 dB -> this looks best
++		*pSignalToNoise = ( (s32)CHC_SNR * 10) / 8;
++	}
++	//printk("SNR %d\n", *pSignalToNoise);
++	return status;
++}
++
++#if 0
++static int DVBC_GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
++{
++	*pQuality = 100;
++	return 0;
++};
++
++static int DVBT_GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
++{
++	static s32 QE_SN[] = {
++		51, // QPSK 1/2
++		69, // QPSK 2/3
++		79, // QPSK 3/4
++		89, // QPSK 5/6
++		97, // QPSK 7/8
++		108, // 16-QAM 1/2
++		131, // 16-QAM 2/3
++		146, // 16-QAM 3/4
++		156, // 16-QAM 5/6
++		160, // 16-QAM 7/8
++		165, // 64-QAM 1/2
++		187, // 64-QAM 2/3
++		202, // 64-QAM 3/4
++		216, // 64-QAM 5/6
++		225, // 64-QAM 7/8
++	};
++	u8 TPS_Received[2];
++	int Constellation;
++	int CodeRate;
++	s32 SignalToNoiseRel, BERQuality;
++
++	*pQuality = 0;
++	readregs(state, R367_OFDM_TPS_RCVD2, TPS_Received, sizeof(TPS_Received));
++	Constellation = TPS_Received[0] & 0x03;
++	CodeRate = TPS_Received[1] & 0x07;
++
++	if( Constellation > 2 || CodeRate > 5 )
++		return -1;
++	SignalToNoiseRel = SignalToNoise - QE_SN[Constellation * 5 + CodeRate];
++	BERQuality = 100;
++
++	if( SignalToNoiseRel < -70 )
++		*pQuality = 0;
++	else if( SignalToNoiseRel < 30 ) {
++		*pQuality = ((SignalToNoiseRel + 70) * BERQuality)/100;
++	} else
++		*pQuality = BERQuality;
++	return 0;
++};
++
++static s32 DVBCQuality(struct stv_state *state, s32 SignalToNoise)
++{
++	s32 SignalToNoiseRel = 0;
++	s32 Quality = 0;
++	s32 BERQuality = 100;
++
++	switch(state->modulation) {
++	case QAM_16:  SignalToNoiseRel = SignalToNoise - 200 ; break;
++	case QAM_32:  SignalToNoiseRel = SignalToNoise - 230 ; break; // Not in NorDig
++	case QAM_64:  SignalToNoiseRel = SignalToNoise - 260 ; break;
++	case QAM_128: SignalToNoiseRel = SignalToNoise - 290 ; break;
++	case QAM_256: SignalToNoiseRel = SignalToNoise - 320 ; break;
++	}
++
++	if( SignalToNoiseRel < -70 ) Quality = 0;
++	else if( SignalToNoiseRel < 30 )
++	{
++		Quality = ((SignalToNoiseRel + 70) * BERQuality)/100;
++	}
++	else
++	Quality = BERQuality;
++
++	return Quality;
++}
++
++static int GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
++{
++	*pQuality = 0;
++	switch(state->demod_state)
++	{
++	case QAMStarted:
++		*pQuality = DVBCQuality(state, SignalToNoise);
++		break;
++	case OFDMStarted:
++		return DVBT_GetQuality(state, SignalToNoise, pQuality);
++	}
++	return 0;
++};
++#endif
++
++static int attach_init(struct stv_state *state)
++{
++	int stat = 0;
++
++	stat = readreg(state, R367_ID, &state->ID);
++	if ( stat < 0 || state->ID != 0x60 )
++		return -ENODEV;
++	printk("stv0367 found\n");
++
++	writereg(state, R367_TOPCTRL, 0x10);
++	write_init_table(state, base_init);
++	write_init_table(state, qam_init);
++
++	writereg(state, R367_TOPCTRL, 0x00);
++	write_init_table(state, ofdm_init);
++
++	writereg(state, R367_OFDM_GAIN_SRC1, 0x2A);
++	writereg(state, R367_OFDM_GAIN_SRC2, 0xD6);
++	writereg(state, R367_OFDM_INC_DEROT1, 0x55);
++	writereg(state, R367_OFDM_INC_DEROT2, 0x55);
++	writereg(state, R367_OFDM_TRL_CTL, 0x14);
++	writereg(state, R367_OFDM_TRL_NOMRATE1, 0xAE);
++	writereg(state, R367_OFDM_TRL_NOMRATE2, 0x56);
++	writereg(state, R367_OFDM_FEPATH_CFG, 0x0);
++
++	// OFDM TS Setup
++
++	writereg(state, R367_OFDM_TSCFGH, 0x70);
++	writereg(state, R367_OFDM_TSCFGM, 0xC0);
++	writereg(state, R367_OFDM_TSCFGL, 0x20);
++	writereg(state, R367_OFDM_TSSPEED, 0x40);        // Fixed at 54 MHz
++	//writereg(state, R367_TSTBUS, 0x80);      // Invert CLK
++
++	writereg(state, R367_OFDM_TSCFGH, 0x71);
++	writereg(state, R367_OFDM_TSCFGH, 0x70);
++
++	writereg(state, R367_TOPCTRL, 0x10);
++
++	// Also needed for QAM
++	writereg(state, R367_OFDM_AGC12C, 0x01); // AGC Pin setup
++
++	writereg(state, R367_OFDM_AGCCTRL1, 0x8A); //
++
++	// QAM TS setup, note exact format also depends on descrambler settings
++	writereg(state, R367_QAM_OUTFORMAT_0, 0x85); // Inverted Clock, Swap, serial
++	// writereg(state, R367_QAM_OUTFORMAT_1, 0x00); //
++
++	// Clock setup
++	writereg(state, R367_ANACTRL, 0x0D); /* PLL bypassed and disabled */
++
++	if( state->master_clock == 58000000 ) {
++		writereg(state, R367_PLLMDIV,27); /* IC runs at 58 MHz with a 27 MHz crystal */
++		writereg(state, R367_PLLNDIV,232);
++	} else {
++		writereg(state, R367_PLLMDIV,1); /* IC runs at 54 MHz with a 27 MHz crystal */
++		writereg(state, R367_PLLNDIV,8);
++	}
++	writereg(state, R367_PLLSETUP, 0x18);  /* ADC clock is equal to system clock */
++
++	// Tuner setup
++	writereg(state, R367_ANADIGCTRL, 0x8b); /* Buffer Q disabled, I Enabled, signed ADC */
++	writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
++
++	writereg(state, R367_QAM_FSM_SNR2_HTH, 0x23); /* Improves the C/N lock limit */
++	writereg(state, R367_QAM_IQ_QAM, 0x01); /* ZIF/IF Automatic mode */
++	writereg(state, R367_QAM_EQU_FFE_LEAKAGE, 0x83); /* Improving burst noise performances */
++	writereg(state, R367_QAM_IQDEM_ADJ_EN, 0x05); /* Improving ACI performances */
++
++	writereg(state, R367_ANACTRL, 0x00); /* PLL enabled and used */
++
++	writereg(state, R367_I2CRPT, state->I2CRPT);
++	state->demod_state    = QAMSet;
++	return stat;
++}
++
++#ifdef USE_API3
++static void c_release(struct dvb_frontend* fe)
++#else
++static void release(struct dvb_frontend* fe)
++#endif
++{
++	struct stv_state *state=fe->demodulator_priv;
++	printk("%s\n", __FUNCTION__);
++	kfree(state);
++}
++
++#ifdef USE_API3
++static int c_init (struct dvb_frontend *fe)
++{
++	struct stv_state *state=fe->demodulator_priv;
++
++	if (mutex_trylock(&state->ctlock)==0)
++		return -EBUSY;
++	state->omode = OM_DVBC;
++	return 0;
++}
++
++static int c_sleep(struct dvb_frontend* fe)
++{
++	struct stv_state *state=fe->demodulator_priv;
++
++	mutex_unlock(&state->ctlock);
++	return 0;
++}
++#endif
++
++static int gate_ctrl(struct dvb_frontend* fe, int enable)
++{
++	struct stv_state *state = fe->demodulator_priv;
++	u8 i2crpt = state->I2CRPT & ~0x80;
++
++	if (enable)
++		i2crpt |= 0x80;
++	if (writereg(state, R367_I2CRPT, i2crpt) < 0)
++		return -1;
++	state->I2CRPT = i2crpt;
++	return 0;
++}
++
++#if 0
++static int c_track(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
++{
++	return DVBFE_ALGO_SEARCH_AGAIN;
++}
++#endif
++
++#if 0
++int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
++int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
++#endif
++
++static int ofdm_lock(struct stv_state *state)
++{
++	int status = 0;
++	u8 OFDM_Status;
++	s32 DemodTimeOut = 10;
++	s32 FECTimeOut = 0;
++	s32 TSTimeOut = 0;
++	u8 CPAMPMin = 255;
++	u8 CPAMPValue;
++	u8 SYR_STAT;
++	u8 FFTMode;
++	u8 TSStatus;
++
++	msleep(state->m_SignalTimeOut);
++	readreg(state, R367_OFDM_STATUS,&OFDM_Status);
++
++	if (!(OFDM_Status & 0x40))
++		return -1;
++	//printk("lock 1\n");
++
++	readreg(state, R367_OFDM_SYR_STAT,&SYR_STAT);
++	FFTMode = (SYR_STAT & 0x0C) >> 2;
++
++	switch(FFTMode)
++	{
++	    case 0: // 2K
++		DemodTimeOut = 10;
++		FECTimeOut = 150;
++		TSTimeOut = 125;
++		CPAMPMin = 20;
++		break;
++	    case 1: // 8K
++		DemodTimeOut = 55;
++		FECTimeOut = 600;
++		TSTimeOut = 500;
++		CPAMPMin = 80;
++		break;
++	    case 2: // 4K
++		DemodTimeOut = 40;
++		FECTimeOut = 300;
++		TSTimeOut = 250;
++		CPAMPMin = 30;
++		break;
++	}
++	state->m_OFDM_FFTMode = FFTMode;
++	readreg(state, R367_OFDM_PPM_CPAMP_DIR,&CPAMPValue);
++	msleep(DemodTimeOut);
++	{
++	    // Release FEC and Read Solomon Reset
++	    u8 tmp1;
++	    u8 tmp2;
++	    readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
++	    readreg(state, R367_TSGENERAL,&tmp2);
++	    writereg(state, R367_OFDM_SFDLYSETH,tmp1 & ~0x08);
++	    writereg(state, R367_TSGENERAL,tmp2 & ~0x01);
++	}
++	msleep(FECTimeOut);
++	if( (OFDM_Status & 0x98) != 0x98 )
++		;//return -1;
++	//printk("lock 2\n");
++
++	{
++	    u8 Guard = (SYR_STAT & 0x03);
++	    if(Guard < 2)
++	    {
++		u8 tmp;
++		readreg(state, R367_OFDM_SYR_CTL,&tmp);
++		writereg(state, R367_OFDM_SYR_CTL,tmp & ~0x04); // Clear AUTO_LE_EN
++		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
++		writereg(state, R367_OFDM_SYR_UPDATE,tmp & ~0x10); // Clear SYR_FILTER
++	    } else {
++		u8 tmp;
++		readreg(state, R367_OFDM_SYR_CTL,&tmp);
++		writereg(state, R367_OFDM_SYR_CTL,tmp | 0x04); // Set AUTO_LE_EN
++		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
++		writereg(state, R367_OFDM_SYR_UPDATE,tmp | 0x10); // Set SYR_FILTER
++	    }
++
++	    // apply Sfec workaround if 8K 64QAM CR!=1/2
++	    if( FFTMode == 1)
++	    {
++		u8 tmp[2];
++		readregs(state, R367_OFDM_TPS_RCVD2, tmp, 2);
++		if( ((tmp[0] & 0x03) == 0x02) && (( tmp[1] & 0x07 ) != 0) )
++		{
++		    writereg(state, R367_OFDM_SFDLYSETH,0xc0);
++		    writereg(state, R367_OFDM_SFDLYSETM,0x60);
++		    writereg(state, R367_OFDM_SFDLYSETL,0x00);
++		}
++		else
++		{
++		    writereg(state, R367_OFDM_SFDLYSETH,0x00);
++		}
++	    }
++	}
++	msleep(TSTimeOut);
++	readreg(state, R367_OFDM_TSSTATUS,&TSStatus);
++	if( (TSStatus & 0x80) != 0x80 )
++		return -1;
++	//printk("lock 3\n");
++	return status;
++}
++
++
++
++#ifdef USE_API3
++static int set_parameters(struct dvb_frontend *fe,
++			  struct dvb_frontend_parameters *p)
++{
++	int stat;
++	struct stv_state *state = fe->demodulator_priv;
++	u32 OF = 0;
++	u32 IF;
++
++	if (fe->ops.tuner_ops.set_params)
++		fe->ops.tuner_ops.set_params(fe, p);
++
++	switch (state->omode) {
++	case OM_DVBC:
++	case OM_QAM_ITU_C:
++		state->modulation = p->u.qam.modulation;
++		state->symbol_rate = p->u.qam.symbol_rate;
++		break;
++	case OM_DVBT:
++		switch (p->u.ofdm.bandwidth) {
++		case BANDWIDTH_AUTO:
++		case BANDWIDTH_8_MHZ:
++			state->bandwidth = 8000000;
++			break;
++		case BANDWIDTH_7_MHZ:
++			state->bandwidth = 7000000;
++			break;
++		case BANDWIDTH_6_MHZ:
++			state->bandwidth = 6000000;
++			break;
++		default:
++			return -EINVAL;
++		}
++		break;
++	default:
++		return -EINVAL;
++	}
++#else
++static int set_parameters(struct dvb_frontend *fe)
++{
++	int stat;
++	struct stv_state *state = fe->demodulator_priv;
++	u32 OF = 0;
++	u32 IF;
++
++	switch (fe->dtv_property_cache.delivery_system) {
++	case SYS_DVBC_ANNEX_A:
++		state->omode = OM_DVBC;
++		/* symbol rate 0 might cause an oops */
++		if (fe->dtv_property_cache.symbol_rate == 0) {
++			printk(KERN_ERR "stv0367dd: Invalid symbol rate\n");
++			return -EINVAL;
++		}
++		break;
++	case SYS_DVBT:
++		state->omode = OM_DVBT;
++		break;
++	default:
++		return -EINVAL;
++	}
++	if (fe->ops.tuner_ops.set_params)
++		fe->ops.tuner_ops.set_params(fe);
++	state->modulation = fe->dtv_property_cache.modulation;
++	state->symbol_rate = fe->dtv_property_cache.symbol_rate;
++	state->bandwidth = fe->dtv_property_cache.bandwidth_hz;
++#endif
++	fe->ops.tuner_ops.get_if_frequency(fe, &IF);
++	//fe->ops.tuner_ops.get_frequency(fe, &IF);
++
++	switch(state->omode) {
++	case OM_DVBT:
++		stat = OFDM_Start(state, OF, IF);
++		ofdm_lock(state);
++		break;
++	case OM_DVBC:
++	case OM_QAM_ITU_C:
++		stat = QAM_Start(state, OF, IF);
++		break;
++	default:
++		stat = -EINVAL;
++	}
++	//printk("%s IF=%d OF=%d done\n", __FUNCTION__, IF, OF);
++	return stat;
++}
++
++#if 0
++static int c_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
++{
++	//struct stv_state *state = fe->demodulator_priv;
++	//printk("%s\n", __FUNCTION__);
++	return 0;
++}
++
++static int OFDM_GetLockStatus(struct stv_state *state, LOCK_STATUS* pLockStatus, s32 Time)
++{
++	int status = STATUS_SUCCESS;
++	u8 OFDM_Status;
++	s32 DemodTimeOut = 0;
++	s32 FECTimeOut = 0;
++	s32 TSTimeOut = 0;
++	u8 CPAMPMin = 255;
++	u8 CPAMPValue;
++	bool SYRLock;
++	u8 SYR_STAT;
++	u8 FFTMode;
++	u8 TSStatus;
++
++	readreg(state, R367_OFDM_STATUS,&OFDM_Status);
++
++	SYRLock = (OFDM_Status & 0x40) != 0;
++
++	if( Time > m_SignalTimeOut && !SYRLock )
++	{
++	    *pLockStatus = NEVER_LOCK;
++	    break;
++	}
++
++	if( !SYRLock ) break;
++
++	*pLockStatus = SIGNAL_PRESENT;
++
++	// Check Mode
++
++	readreg(state, R367_OFDM_SYR_STAT,&SYR_STAT);
++	FFTMode = (SYR_STAT & 0x0C) >> 2;
++
++	switch(FFTMode)
++	{
++	    case 0: // 2K
++		DemodTimeOut = 10;
++		FECTimeOut = 150;
++		TSTimeOut = 125;
++		CPAMPMin = 20;
++		break;
++	    case 1: // 8K
++		DemodTimeOut = 55;
++		FECTimeOut = 600;
++		TSTimeOut = 500;
++		CPAMPMin = 80;
++		break;
++	    case 2: // 4K
++		DemodTimeOut = 40;
++		FECTimeOut = 300;
++		TSTimeOut = 250;
++		CPAMPMin = 30;
++		break;
++	}
++
++	m_OFDM_FFTMode = FFTMode;
++
++	if( m_DemodTimeOut == 0 && m_bFirstTimeLock )
++	{
++	    m_DemodTimeOut = Time + DemodTimeOut;
++	    //break;
++	}
++
++	readreg(state, R367_OFDM_PPM_CPAMP_DIR,&CPAMPValue);
++
++	if( Time <= m_DemodTimeOut && CPAMPValue < CPAMPMin )
++	{
++	    break;
++	}
++
++	if( CPAMPValue < CPAMPMin && m_bFirstTimeLock )
++	{
++	    // initiate retry
++	    *pLockStatus = NEVER_LOCK;
++	    break;
++	}
++
++	if( CPAMPValue < CPAMPMin ) break;
++
++	*pLockStatus = DEMOD_LOCK;
++
++	if( m_FECTimeOut == 0 && m_bFirstTimeLock )
++	{
++	    // Release FEC and Read Solomon Reset
++	    u8 tmp1;
++	    u8 tmp2;
++	    readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
++	    readreg(state, R367_TSGENERAL,&tmp2);
++	    writereg(state, R367_OFDM_SFDLYSETH,tmp1 & ~0x08);
++	    writereg(state, R367_TSGENERAL,tmp2 & ~0x01);
++
++	    m_FECTimeOut = Time + FECTimeOut;
++	}
++
++	// Wait for TSP_LOCK, LK, PRF
++	if( (OFDM_Status & 0x98) != 0x98 )
++	{
++	    if( Time > m_FECTimeOut ) *pLockStatus = NEVER_LOCK;
++	    break;
++	}
++
++	if( m_bFirstTimeLock && m_TSTimeOut == 0)
++	{
++	    u8 Guard = (SYR_STAT & 0x03);
++	    if(Guard < 2)
++	    {
++		u8 tmp;
++		readreg(state, R367_OFDM_SYR_CTL,&tmp);
++		writereg(state, R367_OFDM_SYR_CTL,tmp & ~0x04); // Clear AUTO_LE_EN
++		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
++		writereg(state, R367_OFDM_SYR_UPDATE,tmp & ~0x10); // Clear SYR_FILTER
++	    } else {
++		u8 tmp;
++		readreg(state, R367_OFDM_SYR_CTL,&tmp);
++		writereg(state, R367_OFDM_SYR_CTL,tmp | 0x04); // Set AUTO_LE_EN
++		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
++		writereg(state, R367_OFDM_SYR_UPDATE,tmp | 0x10); // Set SYR_FILTER
++	    }
++
++	    // apply Sfec workaround if 8K 64QAM CR!=1/2
++	    if( FFTMode == 1)
++	    {
++		u8 tmp[2];
++		readreg(state, R367_OFDM_TPS_RCVD2,tmp,2);
++		if( ((tmp[0] & 0x03) == 0x02) && (( tmp[1] & 0x07 ) != 0) )
++		{
++		    writereg(state, R367_OFDM_SFDLYSETH,0xc0);
++		    writereg(state, R367_OFDM_SFDLYSETM,0x60);
++		    writereg(state, R367_OFDM_SFDLYSETL,0x00);
++		}
++		else
++		{
++		    writereg(state, R367_OFDM_SFDLYSETH,0x00);
++		}
++	    }
++
++	    m_TSTimeOut = Time + TSTimeOut;
++	}
++	readreg(state, R367_OFDM_TSSTATUS,&TSStatus);
++	if( (TSStatus & 0x80) != 0x80 )
++	{
++		if( Time > m_TSTimeOut ) *pLockStatus = NEVER_LOCK;
++	    break;
++	}
++	*pLockStatus = MPEG_LOCK;
++	m_bFirstTimeLock = false;
++	return status;
++}
++
++#endif
++
++static int read_status(struct dvb_frontend *fe, fe_status_t *status)
++{
++	struct stv_state *state = fe->demodulator_priv;
++	*status=0;
++
++	switch(state->demod_state) {
++	case QAMStarted:
++	{
++		u8 FEC_Lock;
++		u8 QAM_Lock;
++
++		readreg(state, R367_QAM_FSM_STS, &QAM_Lock);
++		QAM_Lock &= 0x0F;
++		if (QAM_Lock >10)
++			*status|=0x07;
++		readreg(state, R367_QAM_FEC_STATUS,&FEC_Lock);
++		if (FEC_Lock&2)
++			*status|=0x1f;
++		if (state->m_bFirstTimeLock) {
++			state->m_bFirstTimeLock = false;
++			// QAM_AGC_ACCUMRSTSEL to Tracking;
++			writereg(state, R367_QAM_AGC_CTL, state->m_Save_QAM_AGC_CTL);
++		}
++		break;
++	}
++	case OFDMStarted:
++	{
++		u8 OFDM_Status;
++		u8 TSStatus;
++
++		readreg(state, R367_OFDM_TSSTATUS, &TSStatus);
++
++		readreg(state, R367_OFDM_STATUS, &OFDM_Status);
++		if (OFDM_Status & 0x40)
++			*status |= FE_HAS_SIGNAL;
++
++		if ((OFDM_Status & 0x98) == 0x98)
++			*status|=0x0f;
++
++		if (TSStatus & 0x80)
++			*status |= 0x1f;
++		break;
++	}
++	default:
++		break;
++	}
++	return 0;
++}
++
++static int read_ber(struct dvb_frontend *fe, u32 *ber)
++{
++	//struct stv_state *state = fe->demodulator_priv;
++	*ber=0;
++	return 0;
++}
++
++static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
++{
++	if (fe->ops.tuner_ops.get_rf_strength)
++		fe->ops.tuner_ops.get_rf_strength(fe, strength);
++	else
++		*strength = 0;
++	return 0;
++}
++
++static int read_snr(struct dvb_frontend *fe, u16 *snr)
++{
++	struct stv_state *state = fe->demodulator_priv;
++	s32 snr2 = 0;
++
++	switch(state->demod_state) {
++	case QAMStarted:
++		QAM_GetSignalToNoise(state, &snr2);
++		break;
++	case OFDMStarted:
++		OFDM_GetSignalToNoise(state, &snr2);
++		break;
++	default:
++		break;
++	}
++	*snr = snr2&0xffff;
++	return 0;
++}
++
++static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
++{
++	struct stv_state *state = fe->demodulator_priv;
++	u8 errl, errm, errh;
++	u8 val;
++
++	switch(state->demod_state) {
++	case QAMStarted:
++		readreg(state, R367_QAM_RS_COUNTER_4, &errl);
++		readreg(state, R367_QAM_RS_COUNTER_5, &errm);
++		*ucblocks = (errm << 8) | errl;
++		break;
++	case OFDMStarted:
++		readreg(state, R367_OFDM_SFERRCNTH, &val);
++		if ((val & 0x80) == 0) {
++			readreg(state, R367_OFDM_ERRCNT1H, &errh);
++			readreg(state, R367_OFDM_ERRCNT1M, &errl);
++			readreg(state, R367_OFDM_ERRCNT1L, &errm);
++			state->ucblocks = (errh <<16) | (errm << 8) | errl;
++		}
++		*ucblocks = state->ucblocks;
++		break;
++	default:
++		*ucblocks = 0;
++		break;
++	}
++	return 0;
++}
++
++static int c_get_tune_settings(struct dvb_frontend *fe,
++				    struct dvb_frontend_tune_settings *sets)
++{
++	sets->min_delay_ms=3000;
++	sets->max_drift=0;
++	sets->step_size=0;
++	return 0;
++}
++
++#ifndef USE_API3
++static int get_tune_settings(struct dvb_frontend *fe,
++			     struct dvb_frontend_tune_settings *sets)
++{
++	switch (fe->dtv_property_cache.delivery_system) {
++	case SYS_DVBC_ANNEX_A:
++	case SYS_DVBC_ANNEX_C:
++		return c_get_tune_settings(fe, sets);
++	default:
++		/* DVB-T: Use info.frequency_stepsize. */
++		return -EINVAL;
++	}
++}
++#endif
++
++#ifdef USE_API3
++static void t_release(struct dvb_frontend* fe)
++{
++	//struct stv_state *state=fe->demodulator_priv;
++	//printk("%s\n", __FUNCTION__);
++	//kfree(state);
++}
++
++static int t_init (struct dvb_frontend *fe)
++{
++	struct stv_state *state=fe->demodulator_priv;
++	if (mutex_trylock(&state->ctlock)==0)
++		return -EBUSY;
++	state->omode = OM_DVBT;
++	return 0;
++}
++
++static int t_sleep(struct dvb_frontend* fe)
++{
++	struct stv_state *state=fe->demodulator_priv;
++	mutex_unlock(&state->ctlock);
++	return 0;
++}
++#endif
++
++#if 0
++static int t_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
++{
++	//struct stv_state *state = fe->demodulator_priv;
++	//printk("%s\n", __FUNCTION__);
++	return 0;
++}
++
++static enum dvbfe_algo algo(struct dvb_frontend *fe)
++{
++	return DVBFE_ALGO_CUSTOM;
++}
++#endif
++
++#ifdef USE_API3
++static struct dvb_frontend_ops c_ops = {
++	.info = {
++		.name = "STV0367 DVB-C",
++		.type = FE_QAM,
++		.frequency_stepsize = 62500,
++		.frequency_min = 47000000,
++		.frequency_max = 862000000,
++		.symbol_rate_min = 870000,
++		.symbol_rate_max = 11700000,
++		.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
++			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO
++	},
++	.release = c_release,
++	.init = c_init,
++	.sleep = c_sleep,
++	.i2c_gate_ctrl = gate_ctrl,
++
++	.get_tune_settings = c_get_tune_settings,
++
++	.read_status = read_status,
++	.read_ber = read_ber,
++	.read_signal_strength = read_signal_strength,
++	.read_snr = read_snr,
++	.read_ucblocks = read_ucblocks,
++
++#if 1
++	.set_frontend = set_parameters,
++#else
++	.get_frontend_algo = algo,
++	.search = search,
++#endif
++};
++
++static struct dvb_frontend_ops t_ops = {
++	.info = {
++		.name			= "STV0367 DVB-T",
++		.type			= FE_OFDM,
++		.frequency_min		= 47125000,
++		.frequency_max		= 865000000,
++		.frequency_stepsize	= 166667,
++		.frequency_tolerance	= 0,
++		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
++		FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
++		FE_CAN_FEC_AUTO |
++		FE_CAN_QAM_16 | FE_CAN_QAM_64 |
++		FE_CAN_QAM_AUTO |
++		FE_CAN_TRANSMISSION_MODE_AUTO |
++		FE_CAN_GUARD_INTERVAL_AUTO |
++		FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
++		FE_CAN_MUTE_TS
++	},
++	.release = t_release,
++	.init = t_init,
++	.sleep = t_sleep,
++	.i2c_gate_ctrl = gate_ctrl,
++
++	.set_frontend = set_parameters,
++
++	.read_status = read_status,
++	.read_ber = read_ber,
++	.read_signal_strength = read_signal_strength,
++	.read_snr = read_snr,
++	.read_ucblocks = read_ucblocks,
++};
++
++#else
++
++static struct dvb_frontend_ops common_ops = {
++	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT },
++	.info = {
++		.name = "STV0367 DVB-C DVB-T",
++		.frequency_stepsize = 166667,	/* DVB-T only */
++		.frequency_min = 47000000,	/* DVB-T: 47125000 */
++		.frequency_max = 865000000,	/* DVB-C: 862000000 */
++		.symbol_rate_min = 870000,
++		.symbol_rate_max = 11700000,
++		.caps = /* DVB-C */
++			FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
++			FE_CAN_QAM_128 | FE_CAN_QAM_256 |
++			FE_CAN_FEC_AUTO |
++			/* DVB-T */
++			FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
++			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
++			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
++			FE_CAN_TRANSMISSION_MODE_AUTO |
++			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
++			FE_CAN_RECOVER | FE_CAN_MUTE_TS
++	},
++	.release = release,
++	.i2c_gate_ctrl = gate_ctrl,
++
++	.get_tune_settings = get_tune_settings,
++
++	.set_frontend = set_parameters,
++
++	.read_status = read_status,
++	.read_ber = read_ber,
++	.read_signal_strength = read_signal_strength,
++	.read_snr = read_snr,
++	.read_ucblocks = read_ucblocks,
++};
++#endif
++
++
++static void init_state(struct stv_state *state, struct stv0367_cfg *cfg)
++{
++	u32 ulENARPTLEVEL = 5;
++	u32 ulQAMInversion = 2;
++	state->omode = OM_NONE;
++	state->adr = cfg->adr;
++
++	mutex_init(&state->mutex);
++	mutex_init(&state->ctlock);
++
++#ifdef USE_API3
++	memcpy(&state->c_frontend.ops, &c_ops, sizeof(struct dvb_frontend_ops));
++	memcpy(&state->t_frontend.ops, &t_ops, sizeof(struct dvb_frontend_ops));
++	state->c_frontend.demodulator_priv = state;
++	state->t_frontend.demodulator_priv = state;
++#else
++	memcpy(&state->frontend.ops, &common_ops, sizeof(struct dvb_frontend_ops));
++	state->frontend.demodulator_priv = state;
++#endif
++
++	state->master_clock = 58000000;
++	state->adc_clock = 58000000;
++	state->I2CRPT = 0x08 | ((ulENARPTLEVEL & 0x07) << 4);
++	state->qam_inversion = ((ulQAMInversion & 3) << 6 );
++	state->demod_state   = Off;
++}
++
++
++struct dvb_frontend *stv0367_attach(struct i2c_adapter *i2c, struct stv0367_cfg *cfg,
++				    struct dvb_frontend **fe_t)
++{
++	struct stv_state *state = NULL;
++
++	state = kzalloc(sizeof(struct stv_state), GFP_KERNEL);
++	if (!state)
++		return NULL;
++
++	state->i2c = i2c;
++	init_state(state, cfg);
++
++	if (attach_init(state)<0)
++		goto error;
++#ifdef USE_API3
++	*fe_t = &state->t_frontend;
++	return &state->c_frontend;
++#else
++	return &state->frontend;
++#endif
++
++error:
++	printk("stv0367: not found\n");
++	kfree(state);
++	return NULL;
++}
++
++
++MODULE_DESCRIPTION("STV0367DD driver");
++MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
++MODULE_LICENSE("GPL");
++
++EXPORT_SYMBOL(stv0367_attach);
++
++
++
+diff --git a/drivers/media/dvb-frontends/stv0367dd.h b/drivers/media/dvb-frontends/stv0367dd.h
+new file mode 100644
+index 0000000..665d4c8
+--- /dev/null
++++ b/drivers/media/dvb-frontends/stv0367dd.h
+@@ -0,0 +1,17 @@
++#ifndef _STV0367DD_H_
++#define _STV0367DD_H_
++
++#include <linux/types.h>
++#include <linux/i2c.h>
++
++struct stv0367_cfg {
++	u8  adr;
++	u32 xtal;
++	u32 ts_mode;
++};
++
++
++extern struct dvb_frontend *stv0367_attach(struct i2c_adapter *i2c,
++					   struct stv0367_cfg *cfg,
++					   struct dvb_frontend **fe_t);
++#endif
+diff --git a/drivers/media/dvb-frontends/stv0367dd_regs.h b/drivers/media/dvb-frontends/stv0367dd_regs.h
+new file mode 100644
+index 0000000..f33e787
+--- /dev/null
++++ b/drivers/media/dvb-frontends/stv0367dd_regs.h
+@@ -0,0 +1,3431 @@
++// @DVB-C/DVB-T STMicroelectronics STV0367 register defintions
++// Author Manfred Vlkel, Februar 2011
++// (c) 2010 DigitalDevices GmbH Germany.  All rights reserved
++
++// $Id: DD_STV0367Register.h 357 2011-04-27 02:39:13Z manfred $
++
++/*	=======================================================================
++    -- Registers Declaration
++    -- -------------------------
++    -- Each register (R367_XXXXX) is defined by its address (2 bytes).
++    --
++    -- Each field (F367_XXXXX)is defined as follow:
++    -- [register address -- 2bytes][field sign -- 1byte][field mask -- 1byte]
++	    =======================================================================  */
++
++/* ID */
++#define	R367_ID		0xF000
++#define	F367_IDENTIFICATIONREG		0xF00000FF
++
++/* I2CRPT */
++#define	R367_I2CRPT		0xF001
++#define	F367_I2CT_ON		0xF0010080
++#define	F367_ENARPT_LEVEL		0xF0010070
++#define	F367_SCLT_DELAY		0xF0010008
++#define	F367_SCLT_NOD		0xF0010004
++#define	F367_STOP_ENABLE		0xF0010002
++#define	F367_SDAT_NOD		0xF0010001
++
++/* TOPCTRL */
++#define	R367_TOPCTRL		0xF002
++#define	F367_STDBY		0xF0020080
++#define	F367_STDBY_FEC		0xF0020040
++#define	F367_STDBY_CORE		0xF0020020
++#define	F367_QAM_COFDM		0xF0020010
++#define	F367_TS_DIS		0xF0020008
++#define	F367_DIR_CLK_216		0xF0020004
++#define	F367_TUNER_BB		0xF0020002
++#define	F367_DVBT_H		0xF0020001
++
++/* IOCFG0 */
++#define	R367_IOCFG0		0xF003
++#define	F367_OP0_SD		0xF0030080
++#define	F367_OP0_VAL		0xF0030040
++#define	F367_OP0_OD		0xF0030020
++#define	F367_OP0_INV		0xF0030010
++#define	F367_OP0_DACVALUE_HI		0xF003000F
++
++/* DAC0R */
++#define	R367_DAC0R		0xF004
++#define	F367_OP0_DACVALUE_LO		0xF00400FF
++
++/* IOCFG1 */
++#define	R367_IOCFG1		0xF005
++#define	F367_IP0		0xF0050040
++#define	F367_OP1_OD		0xF0050020
++#define	F367_OP1_INV		0xF0050010
++#define	F367_OP1_DACVALUE_HI		0xF005000F
++
++/* DAC1R */
++#define	R367_DAC1R		0xF006
++#define	F367_OP1_DACVALUE_LO		0xF00600FF
++
++/* IOCFG2 */
++#define	R367_IOCFG2		0xF007
++#define	F367_OP2_LOCK_CONF		0xF00700E0
++#define	F367_OP2_OD		0xF0070010
++#define	F367_OP2_VAL		0xF0070008
++#define	F367_OP1_LOCK_CONF		0xF0070007
++
++/* SDFR */
++#define	R367_SDFR		0xF008
++#define	F367_OP0_FREQ		0xF00800F0
++#define	F367_OP1_FREQ		0xF008000F
++
++/* STATUS */
++#define	R367_OFDM_STATUS		0xF009
++#define	F367_TPS_LOCK		0xF0090080
++#define	F367_SYR_LOCK		0xF0090040
++#define	F367_AGC_LOCK		0xF0090020
++#define	F367_PRF		0xF0090010
++#define	F367_LK		0xF0090008
++#define	F367_PR		0xF0090007
++
++/* AUX_CLK */
++#define	R367_AUX_CLK		0xF00A
++#define	F367_AUXFEC_CTL		0xF00A00C0
++#define	F367_DIS_CKX4		0xF00A0020
++#define	F367_CKSEL		0xF00A0018
++#define	F367_CKDIV_PROG		0xF00A0006
++#define	F367_AUXCLK_ENA		0xF00A0001
++
++/* FREESYS1 */
++#define	R367_FREESYS1		0xF00B
++#define	F367_FREE_SYS1		0xF00B00FF
++
++/* FREESYS2 */
++#define	R367_FREESYS2		0xF00C
++#define	F367_FREE_SYS2		0xF00C00FF
++
++/* FREESYS3 */
++#define	R367_FREESYS3		0xF00D
++#define	F367_FREE_SYS3		0xF00D00FF
++
++/* GPIO_CFG */
++#define	R367_GPIO_CFG		0xF00E
++#define	F367_GPIO7_NOD		0xF00E0080
++#define	F367_GPIO7_CFG		0xF00E0040
++#define	F367_GPIO6_NOD		0xF00E0020
++#define	F367_GPIO6_CFG		0xF00E0010
++#define	F367_GPIO5_NOD		0xF00E0008
++#define	F367_GPIO5_CFG		0xF00E0004
++#define	F367_GPIO4_NOD		0xF00E0002
++#define	F367_GPIO4_CFG		0xF00E0001
++
++/* GPIO_CMD */
++#define	R367_GPIO_CMD		0xF00F
++#define	F367_GPIO7_VAL		0xF00F0008
++#define	F367_GPIO6_VAL		0xF00F0004
++#define	F367_GPIO5_VAL		0xF00F0002
++#define	F367_GPIO4_VAL		0xF00F0001
++
++/* AGC2MAX */
++#define	R367_OFDM_AGC2MAX		0xF010
++#define	F367_OFDM_AGC2_MAX		0xF01000FF
++
++/* AGC2MIN */
++#define	R367_OFDM_AGC2MIN		0xF011
++#define	F367_OFDM_AGC2_MIN		0xF01100FF
++
++/* AGC1MAX */
++#define	R367_OFDM_AGC1MAX		0xF012
++#define	F367_OFDM_AGC1_MAX		0xF01200FF
++
++/* AGC1MIN */
++#define	R367_OFDM_AGC1MIN		0xF013
++#define	F367_OFDM_AGC1_MIN		0xF01300FF
++
++/* AGCR */
++#define	R367_OFDM_AGCR		0xF014
++#define	F367_OFDM_RATIO_A		0xF01400E0
++#define	F367_OFDM_RATIO_B		0xF0140018
++#define	F367_OFDM_RATIO_C		0xF0140007
++
++/* AGC2TH */
++#define	R367_OFDM_AGC2TH		0xF015
++#define	F367_OFDM_AGC2_THRES		0xF01500FF
++
++/* AGC12C */
++#define	R367_OFDM_AGC12C		0xF016
++#define	F367_OFDM_AGC1_IV		0xF0160080
++#define	F367_OFDM_AGC1_OD		0xF0160040
++#define	F367_OFDM_AGC1_LOAD		0xF0160020
++#define	F367_OFDM_AGC2_IV		0xF0160010
++#define	F367_OFDM_AGC2_OD		0xF0160008
++#define	F367_OFDM_AGC2_LOAD		0xF0160004
++#define	F367_OFDM_AGC12_MODE		0xF0160003
++
++/* AGCCTRL1 */
++#define	R367_OFDM_AGCCTRL1		0xF017
++#define	F367_OFDM_DAGC_ON		0xF0170080
++#define	F367_OFDM_INVERT_AGC12		0xF0170040
++#define	F367_OFDM_AGC1_MODE		0xF0170008
++#define	F367_OFDM_AGC2_MODE		0xF0170007
++
++/* AGCCTRL2 */
++#define	R367_OFDM_AGCCTRL2		0xF018
++#define	F367_OFDM_FRZ2_CTRL		0xF0180060
++#define	F367_OFDM_FRZ1_CTRL		0xF0180018
++#define	F367_OFDM_TIME_CST		0xF0180007
++
++/* AGC1VAL1 */
++#define	R367_OFDM_AGC1VAL1		0xF019
++#define	F367_OFDM_AGC1_VAL_LO		0xF01900FF
++
++/* AGC1VAL2 */
++#define	R367_OFDM_AGC1VAL2		0xF01A
++#define	F367_OFDM_AGC1_VAL_HI		0xF01A000F
++
++/* AGC2VAL1 */
++#define	R367_OFDM_AGC2VAL1		0xF01B
++#define	F367_OFDM_AGC2_VAL_LO		0xF01B00FF
++
++/* AGC2VAL2 */
++#define	R367_OFDM_AGC2VAL2		0xF01C
++#define	F367_OFDM_AGC2_VAL_HI		0xF01C000F
++
++/* AGC2PGA */
++#define	R367_OFDM_AGC2PGA		0xF01D
++#define	F367_OFDM_AGC2_PGA		0xF01D00FF
++
++/* OVF_RATE1 */
++#define	R367_OFDM_OVF_RATE1		0xF01E
++#define	F367_OFDM_OVF_RATE_HI		0xF01E000F
++
++/* OVF_RATE2 */
++#define	R367_OFDM_OVF_RATE2		0xF01F
++#define	F367_OFDM_OVF_RATE_LO		0xF01F00FF
++
++/* GAIN_SRC1 */
++#define	R367_OFDM_GAIN_SRC1		0xF020
++#define	F367_OFDM_INV_SPECTR		0xF0200080
++#define	F367_OFDM_IQ_INVERT		0xF0200040
++#define	F367_OFDM_INR_BYPASS		0xF0200020
++#define	F367_OFDM_STATUS_INV_SPECRUM		0xF0200010
++#define	F367_OFDM_GAIN_SRC_HI		0xF020000F
++
++/* GAIN_SRC2 */
++#define	R367_OFDM_GAIN_SRC2		0xF021
++#define	F367_OFDM_GAIN_SRC_LO		0xF02100FF
++
++/* INC_DEROT1 */
++#define	R367_OFDM_INC_DEROT1		0xF022
++#define	F367_OFDM_INC_DEROT_HI		0xF02200FF
++
++/* INC_DEROT2 */
++#define	R367_OFDM_INC_DEROT2		0xF023
++#define	F367_OFDM_INC_DEROT_LO		0xF02300FF
++
++/* PPM_CPAMP_DIR */
++#define	R367_OFDM_PPM_CPAMP_DIR		0xF024
++#define	F367_OFDM_PPM_CPAMP_DIRECT		0xF02400FF
++
++/* PPM_CPAMP_INV */
++#define	R367_OFDM_PPM_CPAMP_INV		0xF025
++#define	F367_OFDM_PPM_CPAMP_INVER		0xF02500FF
++
++/* FREESTFE_1 */
++#define	R367_OFDM_FREESTFE_1		0xF026
++#define	F367_OFDM_SYMBOL_NUMBER_INC		0xF02600C0
++#define	F367_OFDM_SEL_LSB		0xF0260004
++#define	F367_OFDM_AVERAGE_ON		0xF0260002
++#define	F367_OFDM_DC_ADJ		0xF0260001
++
++/* FREESTFE_2 */
++#define	R367_OFDM_FREESTFE_2		0xF027
++#define	F367_OFDM_SEL_SRCOUT		0xF02700C0
++#define	F367_OFDM_SEL_SYRTHR		0xF027001F
++
++/* DCOFFSET */
++#define	R367_OFDM_DCOFFSET		0xF028
++#define	F367_OFDM_SELECT_I_Q		0xF0280080
++#define	F367_OFDM_DC_OFFSET		0xF028007F
++
++/* EN_PROCESS */
++#define	R367_OFDM_EN_PROCESS		0xF029
++#define	F367_OFDM_FREE		0xF02900F0
++#define	F367_OFDM_ENAB_MANUAL		0xF0290001
++
++/* SDI_SMOOTHER */
++#define	R367_OFDM_SDI_SMOOTHER		0xF02A
++#define	F367_OFDM_DIS_SMOOTH		0xF02A0080
++#define	F367_OFDM_SDI_INC_SMOOTHER		0xF02A007F
++
++/* FE_LOOP_OPEN */
++#define	R367_OFDM_FE_LOOP_OPEN		0xF02B
++#define	F367_OFDM_TRL_LOOP_OP		0xF02B0002
++#define	F367_OFDM_CRL_LOOP_OP		0xF02B0001
++
++/* FREQOFF1 */
++#define	R367_OFDM_FREQOFF1		0xF02C
++#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_VHI		0xF02C00FF
++
++/* FREQOFF2 */
++#define	R367_OFDM_FREQOFF2		0xF02D
++#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_HI		0xF02D00FF
++
++/* FREQOFF3 */
++#define	R367_OFDM_FREQOFF3		0xF02E
++#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_LO		0xF02E00FF
++
++/* TIMOFF1 */
++#define	R367_OFDM_TIMOFF1		0xF02F
++#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_HI		0xF02F00FF
++
++/* TIMOFF2 */
++#define	R367_OFDM_TIMOFF2		0xF030
++#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_LO		0xF03000FF
++
++/* EPQ */
++#define	R367_OFDM_EPQ		0xF031
++#define	F367_OFDM_EPQ1		0xF03100FF
++
++/* EPQAUTO */
++#define	R367_OFDM_EPQAUTO		0xF032
++#define	F367_OFDM_EPQ2		0xF03200FF
++
++/* SYR_UPDATE */
++#define	R367_OFDM_SYR_UPDATE		0xF033
++#define	F367_OFDM_SYR_PROTV		0xF0330080
++#define	F367_OFDM_SYR_PROTV_GAIN		0xF0330060
++#define	F367_OFDM_SYR_FILTER		0xF0330010
++#define	F367_OFDM_SYR_TRACK_THRES		0xF033000C
++
++/* CHPFREE */
++#define	R367_OFDM_CHPFREE		0xF034
++#define	F367_OFDM_CHP_FREE		0xF03400FF
++
++/* PPM_STATE_MAC */
++#define	R367_OFDM_PPM_STATE_MAC		0xF035
++#define	F367_OFDM_PPM_STATE_MACHINE_DECODER		0xF035003F
++
++/* INR_THRESHOLD */
++#define	R367_OFDM_INR_THRESHOLD		0xF036
++#define	F367_OFDM_INR_THRESH		0xF03600FF
++
++/* EPQ_TPS_ID_CELL */
++#define	R367_OFDM_EPQ_TPS_ID_CELL		0xF037
++#define	F367_OFDM_ENABLE_LGTH_TO_CF		0xF0370080
++#define	F367_OFDM_DIS_TPS_RSVD		0xF0370040
++#define	F367_OFDM_DIS_BCH		0xF0370020
++#define	F367_OFDM_DIS_ID_CEL		0xF0370010
++#define	F367_OFDM_TPS_ADJUST_SYM		0xF037000F
++
++/* EPQ_CFG */
++#define	R367_OFDM_EPQ_CFG		0xF038
++#define	F367_OFDM_EPQ_RANGE		0xF0380002
++#define	F367_OFDM_EPQ_SOFT		0xF0380001
++
++/* EPQ_STATUS */
++#define	R367_OFDM_EPQ_STATUS		0xF039
++#define	F367_OFDM_SLOPE_INC		0xF03900FC
++#define	F367_OFDM_TPS_FIELD		0xF0390003
++
++/* AUTORELOCK */
++#define	R367_OFDM_AUTORELOCK		0xF03A
++#define	F367_OFDM_BYPASS_BER_TEMPO		0xF03A0080
++#define	F367_OFDM_BER_TEMPO		0xF03A0070
++#define	F367_OFDM_BYPASS_COFDM_TEMPO		0xF03A0008
++#define	F367_OFDM_COFDM_TEMPO		0xF03A0007
++
++/* BER_THR_VMSB */
++#define	R367_OFDM_BER_THR_VMSB		0xF03B
++#define	F367_OFDM_BER_THRESHOLD_HI		0xF03B00FF
++
++/* BER_THR_MSB */
++#define	R367_OFDM_BER_THR_MSB		0xF03C
++#define	F367_OFDM_BER_THRESHOLD_MID		0xF03C00FF
++
++/* BER_THR_LSB */
++#define	R367_OFDM_BER_THR_LSB		0xF03D
++#define	F367_OFDM_BER_THRESHOLD_LO		0xF03D00FF
++
++/* CCD */
++#define	R367_OFDM_CCD		0xF03E
++#define	F367_OFDM_CCD_DETECTED		0xF03E0080
++#define	F367_OFDM_CCD_RESET		0xF03E0040
++#define	F367_OFDM_CCD_THRESHOLD		0xF03E000F
++
++/* SPECTR_CFG */
++#define	R367_OFDM_SPECTR_CFG		0xF03F
++#define	F367_OFDM_SPECT_CFG		0xF03F0003
++
++/* CONSTMU_MSB */
++#define	R367_OFDM_CONSTMU_MSB		0xF040
++#define	F367_OFDM_CONSTMU_FREEZE		0xF0400080
++#define	F367_OFDM_CONSTNU_FORCE_EN		0xF0400040
++#define	F367_OFDM_CONST_MU_MSB		0xF040003F
++
++/* CONSTMU_LSB */
++#define	R367_OFDM_CONSTMU_LSB		0xF041
++#define	F367_OFDM_CONST_MU_LSB		0xF04100FF
++
++/* CONSTMU_MAX_MSB */
++#define	R367_OFDM_CONSTMU_MAX_MSB		0xF042
++#define	F367_OFDM_CONST_MU_MAX_MSB		0xF042003F
++
++/* CONSTMU_MAX_LSB */
++#define	R367_OFDM_CONSTMU_MAX_LSB		0xF043
++#define	F367_OFDM_CONST_MU_MAX_LSB		0xF04300FF
++
++/* ALPHANOISE */
++#define	R367_OFDM_ALPHANOISE		0xF044
++#define	F367_OFDM_USE_ALLFILTER		0xF0440080
++#define	F367_OFDM_INTER_ON		0xF0440040
++#define	F367_OFDM_ALPHA_NOISE		0xF044001F
++
++/* MAXGP_MSB */
++#define	R367_OFDM_MAXGP_MSB		0xF045
++#define	F367_OFDM_MUFILTER_LENGTH		0xF04500F0
++#define	F367_OFDM_MAX_GP_MSB		0xF045000F
++
++/* MAXGP_LSB */
++#define	R367_OFDM_MAXGP_LSB		0xF046
++#define	F367_OFDM_MAX_GP_LSB		0xF04600FF
++
++/* ALPHAMSB */
++#define	R367_OFDM_ALPHAMSB		0xF047
++#define	F367_OFDM_CHC_DATARATE		0xF04700C0
++#define	F367_OFDM_ALPHA_MSB		0xF047003F
++
++/* ALPHALSB */
++#define	R367_OFDM_ALPHALSB		0xF048
++#define	F367_OFDM_ALPHA_LSB		0xF04800FF
++
++/* PILOT_ACCU */
++#define	R367_OFDM_PILOT_ACCU		0xF049
++#define	F367_OFDM_USE_SCAT4ADDAPT		0xF0490080
++#define	F367_OFDM_PILOT_ACC		0xF049001F
++
++/* PILOTMU_ACCU */
++#define	R367_OFDM_PILOTMU_ACCU		0xF04A
++#define	F367_OFDM_DISCARD_BAD_SP		0xF04A0080
++#define	F367_OFDM_DISCARD_BAD_CP		0xF04A0040
++#define	F367_OFDM_PILOT_MU_ACCU		0xF04A001F
++
++/* FILT_CHANNEL_EST */
++#define	R367_OFDM_FILT_CHANNEL_EST		0xF04B
++#define	F367_OFDM_USE_FILT_PILOT		0xF04B0080
++#define	F367_OFDM_FILT_CHANNEL		0xF04B007F
++
++/* ALPHA_NOPISE_FREQ */
++#define	R367_OFDM_ALPHA_NOPISE_FREQ		0xF04C
++#define	F367_OFDM_NOISE_FREQ_FILT		0xF04C0040
++#define	F367_OFDM_ALPHA_NOISE_FREQ		0xF04C003F
++
++/* RATIO_PILOT */
++#define	R367_OFDM_RATIO_PILOT		0xF04D
++#define	F367_OFDM_RATIO_MEAN_SP		0xF04D00F0
++#define	F367_OFDM_RATIO_MEAN_CP		0xF04D000F
++
++/* CHC_CTL */
++#define	R367_OFDM_CHC_CTL		0xF04E
++#define	F367_OFDM_TRACK_EN		0xF04E0080
++#define	F367_OFDM_NOISE_NORM_EN		0xF04E0040
++#define	F367_OFDM_FORCE_CHC_RESET		0xF04E0020
++#define	F367_OFDM_SHORT_TIME		0xF04E0010
++#define	F367_OFDM_FORCE_STATE_EN		0xF04E0008
++#define	F367_OFDM_FORCE_STATE		0xF04E0007
++
++/* EPQ_ADJUST */
++#define	R367_OFDM_EPQ_ADJUST		0xF04F
++#define	F367_OFDM_ADJUST_SCAT_IND		0xF04F00C0
++#define	F367_OFDM_ONE_SYMBOL		0xF04F0010
++#define	F367_OFDM_EPQ_DECAY		0xF04F000E
++#define	F367_OFDM_HOLD_SLOPE		0xF04F0001
++
++/* EPQ_THRES */
++#define	R367_OFDM_EPQ_THRES		0xF050
++#define	F367_OFDM_EPQ_THR		0xF05000FF
++
++/* OMEGA_CTL */
++#define	R367_OFDM_OMEGA_CTL		0xF051
++#define	F367_OFDM_OMEGA_RST		0xF0510080
++#define	F367_OFDM_FREEZE_OMEGA		0xF0510040
++#define	F367_OFDM_OMEGA_SEL		0xF051003F
++
++/* GP_CTL */
++#define	R367_OFDM_GP_CTL		0xF052
++#define	F367_OFDM_CHC_STATE		0xF05200E0
++#define	F367_OFDM_FREEZE_GP		0xF0520010
++#define	F367_OFDM_GP_SEL		0xF052000F
++
++/* MUMSB */
++#define	R367_OFDM_MUMSB		0xF053
++#define	F367_OFDM_MU_MSB		0xF053007F
++
++/* MULSB */
++#define	R367_OFDM_MULSB		0xF054
++#define	F367_OFDM_MU_LSB		0xF05400FF
++
++/* GPMSB */
++#define	R367_OFDM_GPMSB		0xF055
++#define	F367_OFDM_CSI_THRESHOLD		0xF05500E0
++#define	F367_OFDM_GP_MSB		0xF055000F
++
++/* GPLSB */
++#define	R367_OFDM_GPLSB		0xF056
++#define	F367_OFDM_GP_LSB		0xF05600FF
++
++/* OMEGAMSB */
++#define	R367_OFDM_OMEGAMSB		0xF057
++#define	F367_OFDM_OMEGA_MSB		0xF057007F
++
++/* OMEGALSB */
++#define	R367_OFDM_OMEGALSB		0xF058
++#define	F367_OFDM_OMEGA_LSB		0xF05800FF
++
++/* SCAT_NB */
++#define	R367_OFDM_SCAT_NB		0xF059
++#define	F367_OFDM_CHC_TEST		0xF05900F8
++#define	F367_OFDM_SCAT_NUMB		0xF0590003
++
++/* CHC_DUMMY */
++#define	R367_OFDM_CHC_DUMMY		0xF05A
++#define	F367_OFDM_CHC_DUM		0xF05A00FF
++
++/* INC_CTL */
++#define	R367_OFDM_INC_CTL		0xF05B
++#define	F367_OFDM_INC_BYPASS		0xF05B0080
++#define	F367_OFDM_INC_NDEPTH		0xF05B000C
++#define	F367_OFDM_INC_MADEPTH		0xF05B0003
++
++/* INCTHRES_COR1 */
++#define	R367_OFDM_INCTHRES_COR1		0xF05C
++#define	F367_OFDM_INC_THRES_COR1		0xF05C00FF
++
++/* INCTHRES_COR2 */
++#define	R367_OFDM_INCTHRES_COR2		0xF05D
++#define	F367_OFDM_INC_THRES_COR2		0xF05D00FF
++
++/* INCTHRES_DET1 */
++#define	R367_OFDM_INCTHRES_DET1		0xF05E
++#define	F367_OFDM_INC_THRES_DET1		0xF05E003F
++
++/* INCTHRES_DET2 */
++#define	R367_OFDM_INCTHRES_DET2		0xF05F
++#define	F367_OFDM_INC_THRES_DET2		0xF05F003F
++
++/* IIR_CELLNB */
++#define	R367_OFDM_IIR_CELLNB		0xF060
++#define	F367_OFDM_NRST_IIR		0xF0600080
++#define	F367_OFDM_IIR_CELL_NB		0xF0600007
++
++/* IIRCX_COEFF1_MSB */
++#define	R367_OFDM_IIRCX_COEFF1_MSB		0xF061
++#define	F367_OFDM_IIR_CX_COEFF1_MSB		0xF06100FF
++
++/* IIRCX_COEFF1_LSB */
++#define	R367_OFDM_IIRCX_COEFF1_LSB		0xF062
++#define	F367_OFDM_IIR_CX_COEFF1_LSB		0xF06200FF
++
++/* IIRCX_COEFF2_MSB */
++#define	R367_OFDM_IIRCX_COEFF2_MSB		0xF063
++#define	F367_OFDM_IIR_CX_COEFF2_MSB		0xF06300FF
++
++/* IIRCX_COEFF2_LSB */
++#define	R367_OFDM_IIRCX_COEFF2_LSB		0xF064
++#define	F367_OFDM_IIR_CX_COEFF2_LSB		0xF06400FF
++
++/* IIRCX_COEFF3_MSB */
++#define	R367_OFDM_IIRCX_COEFF3_MSB		0xF065
++#define	F367_OFDM_IIR_CX_COEFF3_MSB		0xF06500FF
++
++/* IIRCX_COEFF3_LSB */
++#define	R367_OFDM_IIRCX_COEFF3_LSB		0xF066
++#define	F367_OFDM_IIR_CX_COEFF3_LSB		0xF06600FF
++
++/* IIRCX_COEFF4_MSB */
++#define	R367_OFDM_IIRCX_COEFF4_MSB		0xF067
++#define	F367_OFDM_IIR_CX_COEFF4_MSB		0xF06700FF
++
++/* IIRCX_COEFF4_LSB */
++#define	R367_OFDM_IIRCX_COEFF4_LSB		0xF068
++#define	F367_OFDM_IIR_CX_COEFF4_LSB		0xF06800FF
++
++/* IIRCX_COEFF5_MSB */
++#define	R367_OFDM_IIRCX_COEFF5_MSB		0xF069
++#define	F367_OFDM_IIR_CX_COEFF5_MSB		0xF06900FF
++
++/* IIRCX_COEFF5_LSB */
++#define	R367_OFDM_IIRCX_COEFF5_LSB		0xF06A
++#define	F367_OFDM_IIR_CX_COEFF5_LSB		0xF06A00FF
++
++/* FEPATH_CFG */
++#define	R367_OFDM_FEPATH_CFG		0xF06B
++#define	F367_OFDM_DEMUX_SWAP		0xF06B0004
++#define	F367_OFDM_DIGAGC_SWAP		0xF06B0002
++#define	F367_OFDM_LONGPATH_IF		0xF06B0001
++
++/* PMC1_FUNC */
++#define	R367_OFDM_PMC1_FUNC		0xF06C
++#define	F367_OFDM_SOFT_RSTN		0xF06C0080
++#define	F367_OFDM_PMC1_AVERAGE_TIME		0xF06C0078
++#define	F367_OFDM_PMC1_WAIT_TIME		0xF06C0006
++#define	F367_OFDM_PMC1_2N_SEL		0xF06C0001
++
++/* PMC1_FOR */
++#define	R367_OFDM_PMC1_FOR		0xF06D
++#define	F367_OFDM_PMC1_FORCE		0xF06D0080
++#define	F367_OFDM_PMC1_FORCE_VALUE		0xF06D007C
++
++/* PMC2_FUNC */
++#define	R367_OFDM_PMC2_FUNC		0xF06E
++#define	F367_OFDM_PMC2_SOFT_STN		0xF06E0080
++#define	F367_OFDM_PMC2_ACCU_TIME		0xF06E0070
++#define	F367_OFDM_PMC2_CMDP_MN		0xF06E0008
++#define	F367_OFDM_PMC2_SWAP		0xF06E0004
++
++/* STATUS_ERR_DA */
++#define	R367_OFDM_STATUS_ERR_DA		0xF06F
++#define	F367_OFDM_COM_USEGAINTRK		0xF06F0080
++#define	F367_OFDM_COM_AGCLOCK		0xF06F0040
++#define	F367_OFDM_AUT_AGCLOCK		0xF06F0020
++#define	F367_OFDM_MIN_ERR_X_LSB		0xF06F000F
++
++/* DIG_AGC_R */
++#define	R367_OFDM_DIG_AGC_R		0xF070
++#define	F367_OFDM_COM_SOFT_RSTN		0xF0700080
++#define	F367_OFDM_COM_AGC_ON		0xF0700040
++#define	F367_OFDM_COM_EARLY		0xF0700020
++#define	F367_OFDM_AUT_SOFT_RESETN		0xF0700010
++#define	F367_OFDM_AUT_AGC_ON		0xF0700008
++#define	F367_OFDM_AUT_EARLY		0xF0700004
++#define	F367_OFDM_AUT_ROT_EN		0xF0700002
++#define	F367_OFDM_LOCK_SOFT_RESETN		0xF0700001
++
++/* COMAGC_TARMSB */
++#define	R367_OFDM_COMAGC_TARMSB		0xF071
++#define	F367_OFDM_COM_AGC_TARGET_MSB		0xF07100FF
++
++/* COM_AGC_TAR_ENMODE */
++#define	R367_OFDM_COM_AGC_TAR_ENMODE		0xF072
++#define	F367_OFDM_COM_AGC_TARGET_LSB		0xF07200F0
++#define	F367_OFDM_COM_ENMODE		0xF072000F
++
++/* COM_AGC_CFG */
++#define	R367_OFDM_COM_AGC_CFG		0xF073
++#define	F367_OFDM_COM_N		0xF07300F8
++#define	F367_OFDM_COM_STABMODE		0xF0730006
++#define	F367_OFDM_ERR_SEL		0xF0730001
++
++/* COM_AGC_GAIN1 */
++#define	R367_OFDM_COM_AGC_GAIN1		0xF074
++#define	F367_OFDM_COM_GAIN1ACK		0xF07400F0
++#define	F367_OFDM_COM_GAIN1TRK		0xF074000F
++
++/* AUT_AGC_TARGETMSB */
++#define	R367_OFDM_AUT_AGC_TARGETMSB		0xF075
++#define	F367_OFDM_AUT_AGC_TARGET_MSB		0xF07500FF
++
++/* LOCK_DET_MSB */
++#define	R367_OFDM_LOCK_DET_MSB		0xF076
++#define	F367_OFDM_LOCK_DETECT_MSB		0xF07600FF
++
++/* AGCTAR_LOCK_LSBS */
++#define	R367_OFDM_AGCTAR_LOCK_LSBS		0xF077
++#define	F367_OFDM_AUT_AGC_TARGET_LSB		0xF07700F0
++#define	F367_OFDM_LOCK_DETECT_LSB		0xF077000F
++
++/* AUT_GAIN_EN */
++#define	R367_OFDM_AUT_GAIN_EN		0xF078
++#define	F367_OFDM_AUT_ENMODE		0xF07800F0
++#define	F367_OFDM_AUT_GAIN2		0xF078000F
++
++/* AUT_CFG */
++#define	R367_OFDM_AUT_CFG		0xF079
++#define	F367_OFDM_AUT_N		0xF07900F8
++#define	F367_OFDM_INT_CHOICE		0xF0790006
++#define	F367_OFDM_INT_LOAD		0xF0790001
++
++/* LOCKN */
++#define	R367_OFDM_LOCKN		0xF07A
++#define	F367_OFDM_LOCK_N		0xF07A00F8
++#define	F367_OFDM_SEL_IQNTAR		0xF07A0004
++#define	F367_OFDM_LOCK_DETECT_CHOICE		0xF07A0003
++
++/* INT_X_3 */
++#define	R367_OFDM_INT_X_3		0xF07B
++#define	F367_OFDM_INT_X3		0xF07B00FF
++
++/* INT_X_2 */
++#define	R367_OFDM_INT_X_2		0xF07C
++#define	F367_OFDM_INT_X2		0xF07C00FF
++
++/* INT_X_1 */
++#define	R367_OFDM_INT_X_1		0xF07D
++#define	F367_OFDM_INT_X1		0xF07D00FF
++
++/* INT_X_0 */
++#define	R367_OFDM_INT_X_0		0xF07E
++#define	F367_OFDM_INT_X0		0xF07E00FF
++
++/* MIN_ERRX_MSB */
++#define	R367_OFDM_MIN_ERRX_MSB		0xF07F
++#define	F367_OFDM_MIN_ERR_X_MSB		0xF07F00FF
++
++/* COR_CTL */
++#define	R367_OFDM_COR_CTL		0xF080
++#define	F367_OFDM_CORE_ACTIVE		0xF0800020
++#define	F367_OFDM_HOLD		0xF0800010
++#define	F367_OFDM_CORE_STATE_CTL		0xF080000F
++
++/* COR_STAT */
++#define	R367_OFDM_COR_STAT		0xF081
++#define	F367_OFDM_SCATT_LOCKED		0xF0810080
++#define	F367_OFDM_TPS_LOCKED		0xF0810040
++#define	F367_OFDM_SYR_LOCKED_COR		0xF0810020
++#define	F367_OFDM_AGC_LOCKED_STAT		0xF0810010
++#define	F367_OFDM_CORE_STATE_STAT		0xF081000F
++
++/* COR_INTEN */
++#define	R367_OFDM_COR_INTEN		0xF082
++#define	F367_OFDM_INTEN		0xF0820080
++#define	F367_OFDM_INTEN_SYR		0xF0820020
++#define	F367_OFDM_INTEN_FFT		0xF0820010
++#define	F367_OFDM_INTEN_AGC		0xF0820008
++#define	F367_OFDM_INTEN_TPS1		0xF0820004
++#define	F367_OFDM_INTEN_TPS2		0xF0820002
++#define	F367_OFDM_INTEN_TPS3		0xF0820001
++
++/* COR_INTSTAT */
++#define	R367_OFDM_COR_INTSTAT		0xF083
++#define	F367_OFDM_INTSTAT_SYR		0xF0830020
++#define	F367_OFDM_INTSTAT_FFT		0xF0830010
++#define	F367_OFDM_INTSAT_AGC		0xF0830008
++#define	F367_OFDM_INTSTAT_TPS1		0xF0830004
++#define	F367_OFDM_INTSTAT_TPS2		0xF0830002
++#define	F367_OFDM_INTSTAT_TPS3		0xF0830001
++
++/* COR_MODEGUARD */
++#define	R367_OFDM_COR_MODEGUARD		0xF084
++#define	F367_OFDM_FORCE		0xF0840010
++#define	F367_OFDM_MODE		0xF084000C
++#define	F367_OFDM_GUARD		0xF0840003
++
++/* AGC_CTL */
++#define	R367_OFDM_AGC_CTL		0xF085
++#define	F367_OFDM_AGC_TIMING_FACTOR		0xF08500E0
++#define	F367_OFDM_AGC_LAST		0xF0850010
++#define	F367_OFDM_AGC_GAIN		0xF085000C
++#define	F367_OFDM_AGC_NEG		0xF0850002
++#define	F367_OFDM_AGC_SET		0xF0850001
++
++/* AGC_MANUAL1 */
++#define	R367_OFDM_AGC_MANUAL1		0xF086
++#define	F367_OFDM_AGC_VAL_LO		0xF08600FF
++
++/* AGC_MANUAL2 */
++#define	R367_OFDM_AGC_MANUAL2		0xF087
++#define	F367_OFDM_AGC_VAL_HI		0xF087000F
++
++/* AGC_TARG */
++#define	R367_OFDM_AGC_TARG		0xF088
++#define	F367_OFDM_AGC_TARGET		0xF08800FF
++
++/* AGC_GAIN1 */
++#define	R367_OFDM_AGC_GAIN1		0xF089
++#define	F367_OFDM_AGC_GAIN_LO		0xF08900FF
++
++/* AGC_GAIN2 */
++#define	R367_OFDM_AGC_GAIN2		0xF08A
++#define	F367_OFDM_AGC_LOCKED_GAIN2		0xF08A0010
++#define	F367_OFDM_AGC_GAIN_HI		0xF08A000F
++
++/* RESERVED_1 */
++#define	R367_OFDM_RESERVED_1		0xF08B
++#define	F367_OFDM_RESERVED1		0xF08B00FF
++
++/* RESERVED_2 */
++#define	R367_OFDM_RESERVED_2		0xF08C
++#define	F367_OFDM_RESERVED2		0xF08C00FF
++
++/* RESERVED_3 */
++#define	R367_OFDM_RESERVED_3		0xF08D
++#define	F367_OFDM_RESERVED3		0xF08D00FF
++
++/* CAS_CTL */
++#define	R367_OFDM_CAS_CTL		0xF08E
++#define	F367_OFDM_CCS_ENABLE		0xF08E0080
++#define	F367_OFDM_ACS_DISABLE		0xF08E0040
++#define	F367_OFDM_DAGC_DIS		0xF08E0020
++#define	F367_OFDM_DAGC_GAIN		0xF08E0018
++#define	F367_OFDM_CCSMU		0xF08E0007
++
++/* CAS_FREQ */
++#define	R367_OFDM_CAS_FREQ		0xF08F
++#define	F367_OFDM_CCS_FREQ		0xF08F00FF
++
++/* CAS_DAGCGAIN */
++#define	R367_OFDM_CAS_DAGCGAIN		0xF090
++#define	F367_OFDM_CAS_DAGC_GAIN		0xF09000FF
++
++/* SYR_CTL */
++#define	R367_OFDM_SYR_CTL		0xF091
++#define	F367_OFDM_SICTH_ENABLE		0xF0910080
++#define	F367_OFDM_LONG_ECHO		0xF0910078
++#define	F367_OFDM_AUTO_LE_EN		0xF0910004
++#define	F367_OFDM_SYR_BYPASS		0xF0910002
++#define	F367_OFDM_SYR_TR_DIS		0xF0910001
++
++/* SYR_STAT */
++#define	R367_OFDM_SYR_STAT		0xF092
++#define	F367_OFDM_SYR_LOCKED_STAT		0xF0920010
++#define	F367_OFDM_SYR_MODE		0xF092000C
++#define	F367_OFDM_SYR_GUARD		0xF0920003
++
++/* SYR_NCO1 */
++#define	R367_OFDM_SYR_NCO1		0xF093
++#define	F367_OFDM_SYR_NCO_LO		0xF09300FF
++
++/* SYR_NCO2 */
++#define	R367_OFDM_SYR_NCO2		0xF094
++#define	F367_OFDM_SYR_NCO_HI		0xF094003F
++
++/* SYR_OFFSET1 */
++#define	R367_OFDM_SYR_OFFSET1		0xF095
++#define	F367_OFDM_SYR_OFFSET_LO		0xF09500FF
++
++/* SYR_OFFSET2 */
++#define	R367_OFDM_SYR_OFFSET2		0xF096
++#define	F367_OFDM_SYR_OFFSET_HI		0xF096003F
++
++/* FFT_CTL */
++#define	R367_OFDM_FFT_CTL		0xF097
++#define	F367_OFDM_SHIFT_FFT_TRIG		0xF0970018
++#define	F367_OFDM_FFT_TRIGGER		0xF0970004
++#define	F367_OFDM_FFT_MANUAL		0xF0970002
++#define	F367_OFDM_IFFT_MODE		0xF0970001
++
++/* SCR_CTL */
++#define	R367_OFDM_SCR_CTL		0xF098
++#define	F367_OFDM_SYRADJDECAY		0xF0980070
++#define	F367_OFDM_SCR_CPEDIS		0xF0980002
++#define	F367_OFDM_SCR_DIS		0xF0980001
++
++/* PPM_CTL1 */
++#define	R367_OFDM_PPM_CTL1		0xF099
++#define	F367_OFDM_PPM_MAXFREQ		0xF0990030
++#define	F367_OFDM_PPM_MAXTIM		0xF0990008
++#define	F367_OFDM_PPM_INVSEL		0xF0990004
++#define	F367_OFDM_PPM_SCATDIS		0xF0990002
++#define	F367_OFDM_PPM_BYP		0xF0990001
++
++/* TRL_CTL */
++#define	R367_OFDM_TRL_CTL		0xF09A
++#define	F367_OFDM_TRL_NOMRATE_LSB		0xF09A0080
++#define	F367_OFDM_TRL_GAIN_FACTOR		0xF09A0078
++#define	F367_OFDM_TRL_LOOPGAIN		0xF09A0007
++
++/* TRL_NOMRATE1 */
++#define	R367_OFDM_TRL_NOMRATE1		0xF09B
++#define	F367_OFDM_TRL_NOMRATE_LO		0xF09B00FF
++
++/* TRL_NOMRATE2 */
++#define	R367_OFDM_TRL_NOMRATE2		0xF09C
++#define	F367_OFDM_TRL_NOMRATE_HI		0xF09C00FF
++
++/* TRL_TIME1 */
++#define	R367_OFDM_TRL_TIME1		0xF09D
++#define	F367_OFDM_TRL_TOFFSET_LO		0xF09D00FF
++
++/* TRL_TIME2 */
++#define	R367_OFDM_TRL_TIME2		0xF09E
++#define	F367_OFDM_TRL_TOFFSET_HI		0xF09E00FF
++
++/* CRL_CTL */
++#define	R367_OFDM_CRL_CTL		0xF09F
++#define	F367_OFDM_CRL_DIS		0xF09F0080
++#define	F367_OFDM_CRL_GAIN_FACTOR		0xF09F0078
++#define	F367_OFDM_CRL_LOOPGAIN		0xF09F0007
++
++/* CRL_FREQ1 */
++#define	R367_OFDM_CRL_FREQ1		0xF0A0
++#define	F367_OFDM_CRL_FOFFSET_LO		0xF0A000FF
++
++/* CRL_FREQ2 */
++#define	R367_OFDM_CRL_FREQ2		0xF0A1
++#define	F367_OFDM_CRL_FOFFSET_HI		0xF0A100FF
++
++/* CRL_FREQ3 */
++#define	R367_OFDM_CRL_FREQ3		0xF0A2
++#define	F367_OFDM_CRL_FOFFSET_VHI		0xF0A200FF
++
++/* TPS_SFRAME_CTL */
++#define	R367_OFDM_TPS_SFRAME_CTL		0xF0A3
++#define	F367_OFDM_TPS_SFRAME_SYNC		0xF0A30001
++
++/* CHC_SNR */
++#define	R367_OFDM_CHC_SNR		0xF0A4
++#define	F367_OFDM_CHCSNR		0xF0A400FF
++
++/* BDI_CTL */
++#define	R367_OFDM_BDI_CTL		0xF0A5
++#define	F367_OFDM_BDI_LPSEL		0xF0A50002
++#define	F367_OFDM_BDI_SERIAL		0xF0A50001
++
++/* DMP_CTL */
++#define	R367_OFDM_DMP_CTL		0xF0A6
++#define	F367_OFDM_DMP_SCALING_FACTOR		0xF0A6001E
++#define	F367_OFDM_DMP_SDDIS		0xF0A60001
++
++/* TPS_RCVD1 */
++#define	R367_OFDM_TPS_RCVD1		0xF0A7
++#define	F367_OFDM_TPS_CHANGE		0xF0A70040
++#define	F367_OFDM_BCH_OK		0xF0A70020
++#define	F367_OFDM_TPS_SYNC		0xF0A70010
++#define	F367_OFDM_TPS_FRAME		0xF0A70003
++
++/* TPS_RCVD2 */
++#define	R367_OFDM_TPS_RCVD2		0xF0A8
++#define	F367_OFDM_TPS_HIERMODE		0xF0A80070
++#define	F367_OFDM_TPS_CONST		0xF0A80003
++
++/* TPS_RCVD3 */
++#define	R367_OFDM_TPS_RCVD3		0xF0A9
++#define	F367_OFDM_TPS_LPCODE		0xF0A90070
++#define	F367_OFDM_TPS_HPCODE		0xF0A90007
++
++/* TPS_RCVD4 */
++#define	R367_OFDM_TPS_RCVD4		0xF0AA
++#define	F367_OFDM_TPS_GUARD		0xF0AA0030
++#define	F367_OFDM_TPS_MODE		0xF0AA0003
++
++/* TPS_ID_CELL1 */
++#define	R367_OFDM_TPS_ID_CELL1		0xF0AB
++#define	F367_OFDM_TPS_ID_CELL_LO		0xF0AB00FF
++
++/* TPS_ID_CELL2 */
++#define	R367_OFDM_TPS_ID_CELL2		0xF0AC
++#define	F367_OFDM_TPS_ID_CELL_HI		0xF0AC00FF
++
++/* TPS_RCVD5_SET1 */
++#define	R367_OFDM_TPS_RCVD5_SET1		0xF0AD
++#define	F367_OFDM_TPS_NA		0xF0AD00FC
++#define	F367_OFDM_TPS_SETFRAME		0xF0AD0003
++
++/* TPS_SET2 */
++#define	R367_OFDM_TPS_SET2		0xF0AE
++#define	F367_OFDM_TPS_SETHIERMODE		0xF0AE0070
++#define	F367_OFDM_TPS_SETCONST		0xF0AE0003
++
++/* TPS_SET3 */
++#define	R367_OFDM_TPS_SET3		0xF0AF
++#define	F367_OFDM_TPS_SETLPCODE		0xF0AF0070
++#define	F367_OFDM_TPS_SETHPCODE		0xF0AF0007
++
++/* TPS_CTL */
++#define	R367_OFDM_TPS_CTL		0xF0B0
++#define	F367_OFDM_TPS_IMM		0xF0B00004
++#define	F367_OFDM_TPS_BCHDIS		0xF0B00002
++#define	F367_OFDM_TPS_UPDDIS		0xF0B00001
++
++/* CTL_FFTOSNUM */
++#define	R367_OFDM_CTL_FFTOSNUM		0xF0B1
++#define	F367_OFDM_SYMBOL_NUMBER		0xF0B1007F
++
++/* TESTSELECT */
++#define	R367_OFDM_TESTSELECT		0xF0B2
++#define	F367_OFDM_TEST_SELECT		0xF0B2001F
++
++/* MSC_REV */
++#define	R367_OFDM_MSC_REV		0xF0B3
++#define	F367_OFDM_REV_NUMBER		0xF0B300FF
++
++/* PIR_CTL */
++#define	R367_OFDM_PIR_CTL		0xF0B4
++#define	F367_OFDM_FREEZE		0xF0B40001
++
++/* SNR_CARRIER1 */
++#define	R367_OFDM_SNR_CARRIER1		0xF0B5
++#define	F367_OFDM_SNR_CARRIER_LO		0xF0B500FF
++
++/* SNR_CARRIER2 */
++#define	R367_OFDM_SNR_CARRIER2		0xF0B6
++#define	F367_OFDM_MEAN		0xF0B600C0
++#define	F367_OFDM_SNR_CARRIER_HI		0xF0B6001F
++
++/* PPM_CPAMP */
++#define	R367_OFDM_PPM_CPAMP		0xF0B7
++#define	F367_OFDM_PPM_CPC		0xF0B700FF
++
++/* TSM_AP0 */
++#define	R367_OFDM_TSM_AP0		0xF0B8
++#define	F367_OFDM_ADDRESS_BYTE_0		0xF0B800FF
++
++/* TSM_AP1 */
++#define	R367_OFDM_TSM_AP1		0xF0B9
++#define	F367_OFDM_ADDRESS_BYTE_1		0xF0B900FF
++
++/* TSM_AP2 */
++#define	R367_OFDM_TSM_AP2		0xF0BA
++#define	F367_OFDM_DATA_BYTE_0		0xF0BA00FF
++
++/* TSM_AP3 */
++#define	R367_OFDM_TSM_AP3		0xF0BB
++#define	F367_OFDM_DATA_BYTE_1		0xF0BB00FF
++
++/* TSM_AP4 */
++#define	R367_OFDM_TSM_AP4		0xF0BC
++#define	F367_OFDM_DATA_BYTE_2		0xF0BC00FF
++
++/* TSM_AP5 */
++#define	R367_OFDM_TSM_AP5		0xF0BD
++#define	F367_OFDM_DATA_BYTE_3		0xF0BD00FF
++
++/* TSM_AP6 */
++#define	R367_OFDM_TSM_AP6		0xF0BE
++#define	F367_OFDM_TSM_AP_6		0xF0BE00FF
++
++/* TSM_AP7 */
++#define	R367_OFDM_TSM_AP7		0xF0BF
++#define	F367_OFDM_MEM_SELECT_BYTE		0xF0BF00FF
++
++/* TSTRES */
++#define	R367_TSTRES		0xF0C0
++#define	F367_FRES_DISPLAY		0xF0C00080
++#define	F367_FRES_FIFO_AD		0xF0C00020
++#define	F367_FRESRS		0xF0C00010
++#define	F367_FRESACS		0xF0C00008
++#define	F367_FRESFEC		0xF0C00004
++#define	F367_FRES_PRIF		0xF0C00002
++#define	F367_FRESCORE		0xF0C00001
++
++/* ANACTRL */
++#define	R367_ANACTRL		0xF0C1
++#define	F367_BYPASS_XTAL		0xF0C10040
++#define	F367_BYPASS_PLLXN		0xF0C1000C
++#define	F367_DIS_PAD_OSC		0xF0C10002
++#define	F367_STDBY_PLLXN		0xF0C10001
++
++/* TSTBUS */
++#define	R367_TSTBUS		0xF0C2
++#define	F367_TS_BYTE_CLK_INV		0xF0C20080
++#define	F367_CFG_IP		0xF0C20070
++#define	F367_CFG_TST		0xF0C2000F
++
++/* TSTRATE */
++#define	R367_TSTRATE		0xF0C6
++#define	F367_FORCEPHA		0xF0C60080
++#define	F367_FNEWPHA		0xF0C60010
++#define	F367_FROT90		0xF0C60008
++#define	F367_FR		0xF0C60007
++
++/* CONSTMODE */
++#define	R367_OFDM_CONSTMODE		0xF0CB
++#define	F367_OFDM_TST_PRIF		0xF0CB00E0
++#define	F367_OFDM_CAR_TYPE		0xF0CB0018
++#define	F367_OFDM_CONST_MODE		0xF0CB0003
++
++/* CONSTCARR1 */
++#define	R367_OFDM_CONSTCARR1		0xF0CC
++#define	F367_OFDM_CONST_CARR_LO		0xF0CC00FF
++
++/* CONSTCARR2 */
++#define	R367_OFDM_CONSTCARR2		0xF0CD
++#define	F367_OFDM_CONST_CARR_HI		0xF0CD001F
++
++/* ICONSTEL */
++#define	R367_OFDM_ICONSTEL		0xF0CE
++#define	F367_OFDM_PICONSTEL		0xF0CE00FF
++
++/* QCONSTEL */
++#define	R367_OFDM_QCONSTEL		0xF0CF
++#define	F367_OFDM_PQCONSTEL		0xF0CF00FF
++
++/* TSTBISTRES0 */
++#define	R367_OFDM_TSTBISTRES0		0xF0D0
++#define	F367_OFDM_BEND_PPM		0xF0D00080
++#define	F367_OFDM_BBAD_PPM		0xF0D00040
++#define	F367_OFDM_BEND_FFTW		0xF0D00020
++#define	F367_OFDM_BBAD_FFTW		0xF0D00010
++#define	F367_OFDM_BEND_FFT_BUF		0xF0D00008
++#define	F367_OFDM_BBAD_FFT_BUF		0xF0D00004
++#define	F367_OFDM_BEND_SYR		0xF0D00002
++#define	F367_OFDM_BBAD_SYR		0xF0D00001
++
++/* TSTBISTRES1 */
++#define	R367_OFDM_TSTBISTRES1		0xF0D1
++#define	F367_OFDM_BEND_CHC_CP		0xF0D10080
++#define	F367_OFDM_BBAD_CHC_CP		0xF0D10040
++#define	F367_OFDM_BEND_CHCI		0xF0D10020
++#define	F367_OFDM_BBAD_CHCI		0xF0D10010
++#define	F367_OFDM_BEND_BDI		0xF0D10008
++#define	F367_OFDM_BBAD_BDI		0xF0D10004
++#define	F367_OFDM_BEND_SDI		0xF0D10002
++#define	F367_OFDM_BBAD_SDI		0xF0D10001
++
++/* TSTBISTRES2 */
++#define	R367_OFDM_TSTBISTRES2		0xF0D2
++#define	F367_OFDM_BEND_CHC_INC		0xF0D20080
++#define	F367_OFDM_BBAD_CHC_INC		0xF0D20040
++#define	F367_OFDM_BEND_CHC_SPP		0xF0D20020
++#define	F367_OFDM_BBAD_CHC_SPP		0xF0D20010
++#define	F367_OFDM_BEND_CHC_CPP		0xF0D20008
++#define	F367_OFDM_BBAD_CHC_CPP		0xF0D20004
++#define	F367_OFDM_BEND_CHC_SP		0xF0D20002
++#define	F367_OFDM_BBAD_CHC_SP		0xF0D20001
++
++/* TSTBISTRES3 */
++#define	R367_OFDM_TSTBISTRES3		0xF0D3
++#define	F367_OFDM_BEND_QAM		0xF0D30080
++#define	F367_OFDM_BBAD_QAM		0xF0D30040
++#define	F367_OFDM_BEND_SFEC_VIT		0xF0D30020
++#define	F367_OFDM_BBAD_SFEC_VIT		0xF0D30010
++#define	F367_OFDM_BEND_SFEC_DLINE		0xF0D30008
++#define	F367_OFDM_BBAD_SFEC_DLINE		0xF0D30004
++#define	F367_OFDM_BEND_SFEC_HW		0xF0D30002
++#define	F367_OFDM_BBAD_SFEC_HW		0xF0D30001
++
++/* RF_AGC1 */
++#define	R367_RF_AGC1		0xF0D4
++#define	F367_RF_AGC1_LEVEL_HI		0xF0D400FF
++
++/* RF_AGC2 */
++#define	R367_RF_AGC2		0xF0D5
++#define	F367_REF_ADGP		0xF0D50080
++#define	F367_STDBY_ADCGP		0xF0D50020
++#define	F367_CHANNEL_SEL		0xF0D5001C
++#define	F367_RF_AGC1_LEVEL_LO		0xF0D50003
++
++/* ANADIGCTRL */
++#define	R367_ANADIGCTRL		0xF0D7
++#define	F367_SEL_CLKDEM		0xF0D70020
++#define	F367_EN_BUFFER_Q		0xF0D70010
++#define	F367_EN_BUFFER_I		0xF0D70008
++#define	F367_ADC_RIS_EGDE		0xF0D70004
++#define	F367_SGN_ADC		0xF0D70002
++#define	F367_SEL_AD12_SYNC		0xF0D70001
++
++/* PLLMDIV */
++#define	R367_PLLMDIV		0xF0D8
++#define	F367_PLL_MDIV		0xF0D800FF
++
++/* PLLNDIV */
++#define	R367_PLLNDIV		0xF0D9
++#define	F367_PLL_NDIV		0xF0D900FF
++
++/* PLLSETUP */
++#define	R367_PLLSETUP		0xF0DA
++#define	F367_PLL_PDIV		0xF0DA0070
++#define	F367_PLL_KDIV		0xF0DA000F
++
++/* DUAL_AD12 */
++#define	R367_DUAL_AD12		0xF0DB
++#define	F367_FS20M		0xF0DB0020
++#define	F367_FS50M		0xF0DB0010
++#define	F367_INMODE0		0xF0DB0008
++#define	F367_POFFQ		0xF0DB0004
++#define	F367_POFFI		0xF0DB0002
++#define	F367_INMODE1		0xF0DB0001
++
++/* TSTBIST */
++#define	R367_TSTBIST		0xF0DC
++#define	F367_TST_BYP_CLK		0xF0DC0080
++#define	F367_TST_GCLKENA_STD		0xF0DC0040
++#define	F367_TST_GCLKENA		0xF0DC0020
++#define	F367_TST_MEMBIST		0xF0DC001F
++
++/* PAD_COMP_CTRL */
++#define	R367_PAD_COMP_CTRL		0xF0DD
++#define	F367_COMPTQ		0xF0DD0010
++#define	F367_COMPEN		0xF0DD0008
++#define	F367_FREEZE2		0xF0DD0004
++#define	F367_SLEEP_INHBT		0xF0DD0002
++#define	F367_CHIP_SLEEP		0xF0DD0001
++
++/* PAD_COMP_WR */
++#define	R367_PAD_COMP_WR		0xF0DE
++#define	F367_WR_ASRC		0xF0DE007F
++
++/* PAD_COMP_RD */
++#define	R367_PAD_COMP_RD		0xF0DF
++#define	F367_COMPOK		0xF0DF0080
++#define	F367_RD_ASRC		0xF0DF007F
++
++/* SYR_TARGET_FFTADJT_MSB */
++#define	R367_OFDM_SYR_TARGET_FFTADJT_MSB		0xF100
++#define	F367_OFDM_SYR_START		0xF1000080
++#define	F367_OFDM_SYR_TARGET_FFTADJ_HI		0xF100000F
++
++/* SYR_TARGET_FFTADJT_LSB */
++#define	R367_OFDM_SYR_TARGET_FFTADJT_LSB		0xF101
++#define	F367_OFDM_SYR_TARGET_FFTADJ_LO		0xF10100FF
++
++/* SYR_TARGET_CHCADJT_MSB */
++#define	R367_OFDM_SYR_TARGET_CHCADJT_MSB		0xF102
++#define	F367_OFDM_SYR_TARGET_CHCADJ_HI		0xF102000F
++
++/* SYR_TARGET_CHCADJT_LSB */
++#define	R367_OFDM_SYR_TARGET_CHCADJT_LSB		0xF103
++#define	F367_OFDM_SYR_TARGET_CHCADJ_LO		0xF10300FF
++
++/* SYR_FLAG */
++#define	R367_OFDM_SYR_FLAG		0xF104
++#define	F367_OFDM_TRIG_FLG1		0xF1040080
++#define	F367_OFDM_TRIG_FLG0		0xF1040040
++#define	F367_OFDM_FFT_FLG1		0xF1040008
++#define	F367_OFDM_FFT_FLG0		0xF1040004
++#define	F367_OFDM_CHC_FLG1		0xF1040002
++#define	F367_OFDM_CHC_FLG0		0xF1040001
++
++/* CRL_TARGET1 */
++#define	R367_OFDM_CRL_TARGET1		0xF105
++#define	F367_OFDM_CRL_START		0xF1050080
++#define	F367_OFDM_CRL_TARGET_VHI		0xF105000F
++
++/* CRL_TARGET2 */
++#define	R367_OFDM_CRL_TARGET2		0xF106
++#define	F367_OFDM_CRL_TARGET_HI		0xF10600FF
++
++/* CRL_TARGET3 */
++#define	R367_OFDM_CRL_TARGET3		0xF107
++#define	F367_OFDM_CRL_TARGET_LO		0xF10700FF
++
++/* CRL_TARGET4 */
++#define	R367_OFDM_CRL_TARGET4		0xF108
++#define	F367_OFDM_CRL_TARGET_VLO		0xF10800FF
++
++/* CRL_FLAG */
++#define	R367_OFDM_CRL_FLAG		0xF109
++#define	F367_OFDM_CRL_FLAG1		0xF1090002
++#define	F367_OFDM_CRL_FLAG0		0xF1090001
++
++/* TRL_TARGET1 */
++#define	R367_OFDM_TRL_TARGET1		0xF10A
++#define	F367_OFDM_TRL_TARGET_HI		0xF10A00FF
++
++/* TRL_TARGET2 */
++#define	R367_OFDM_TRL_TARGET2		0xF10B
++#define	F367_OFDM_TRL_TARGET_LO		0xF10B00FF
++
++/* TRL_CHC */
++#define	R367_OFDM_TRL_CHC		0xF10C
++#define	F367_OFDM_TRL_START		0xF10C0080
++#define	F367_OFDM_CHC_START		0xF10C0040
++#define	F367_OFDM_TRL_FLAG1		0xF10C0002
++#define	F367_OFDM_TRL_FLAG0		0xF10C0001
++
++/* CHC_SNR_TARG */
++#define	R367_OFDM_CHC_SNR_TARG		0xF10D
++#define	F367_OFDM_CHC_SNR_TARGET		0xF10D00FF
++
++/* TOP_TRACK */
++#define	R367_OFDM_TOP_TRACK		0xF10E
++#define	F367_OFDM_TOP_START		0xF10E0080
++#define	F367_OFDM_FIRST_FLAG		0xF10E0070
++#define	F367_OFDM_TOP_FLAG1		0xF10E0008
++#define	F367_OFDM_TOP_FLAG0		0xF10E0004
++#define	F367_OFDM_CHC_FLAG1		0xF10E0002
++#define	F367_OFDM_CHC_FLAG0		0xF10E0001
++
++/* TRACKER_FREE1 */
++#define	R367_OFDM_TRACKER_FREE1		0xF10F
++#define	F367_OFDM_TRACKER_FREE_1		0xF10F00FF
++
++/* ERROR_CRL1 */
++#define	R367_OFDM_ERROR_CRL1		0xF110
++#define	F367_OFDM_ERROR_CRL_VHI		0xF11000FF
++
++/* ERROR_CRL2 */
++#define	R367_OFDM_ERROR_CRL2		0xF111
++#define	F367_OFDM_ERROR_CRL_HI		0xF11100FF
++
++/* ERROR_CRL3 */
++#define	R367_OFDM_ERROR_CRL3		0xF112
++#define	F367_OFDM_ERROR_CRL_LOI		0xF11200FF
++
++/* ERROR_CRL4 */
++#define	R367_OFDM_ERROR_CRL4		0xF113
++#define	F367_OFDM_ERROR_CRL_VLO		0xF11300FF
++
++/* DEC_NCO1 */
++#define	R367_OFDM_DEC_NCO1		0xF114
++#define	F367_OFDM_DEC_NCO_VHI		0xF11400FF
++
++/* DEC_NCO2 */
++#define	R367_OFDM_DEC_NCO2		0xF115
++#define	F367_OFDM_DEC_NCO_HI		0xF11500FF
++
++/* DEC_NCO3 */
++#define	R367_OFDM_DEC_NCO3		0xF116
++#define	F367_OFDM_DEC_NCO_LO		0xF11600FF
++
++/* SNR */
++#define	R367_OFDM_SNR		0xF117
++#define	F367_OFDM_SNRATIO		0xF11700FF
++
++/* SYR_FFTADJ1 */
++#define	R367_OFDM_SYR_FFTADJ1		0xF118
++#define	F367_OFDM_SYR_FFTADJ_HI		0xF11800FF
++
++/* SYR_FFTADJ2 */
++#define	R367_OFDM_SYR_FFTADJ2		0xF119
++#define	F367_OFDM_SYR_FFTADJ_LO		0xF11900FF
++
++/* SYR_CHCADJ1 */
++#define	R367_OFDM_SYR_CHCADJ1		0xF11A
++#define	F367_OFDM_SYR_CHCADJ_HI		0xF11A00FF
++
++/* SYR_CHCADJ2 */
++#define	R367_OFDM_SYR_CHCADJ2		0xF11B
++#define	F367_OFDM_SYR_CHCADJ_LO		0xF11B00FF
++
++/* SYR_OFF */
++#define	R367_OFDM_SYR_OFF		0xF11C
++#define	F367_OFDM_SYR_OFFSET		0xF11C00FF
++
++/* PPM_OFFSET1 */
++#define	R367_OFDM_PPM_OFFSET1		0xF11D
++#define	F367_OFDM_PPM_OFFSET_HI		0xF11D00FF
++
++/* PPM_OFFSET2 */
++#define	R367_OFDM_PPM_OFFSET2		0xF11E
++#define	F367_OFDM_PPM_OFFSET_LO		0xF11E00FF
++
++/* TRACKER_FREE2 */
++#define	R367_OFDM_TRACKER_FREE2		0xF11F
++#define	F367_OFDM_TRACKER_FREE_2		0xF11F00FF
++
++/* DEBG_LT10 */
++#define	R367_OFDM_DEBG_LT10		0xF120
++#define	F367_OFDM_DEBUG_LT10		0xF12000FF
++
++/* DEBG_LT11 */
++#define	R367_OFDM_DEBG_LT11		0xF121
++#define	F367_OFDM_DEBUG_LT11		0xF12100FF
++
++/* DEBG_LT12 */
++#define	R367_OFDM_DEBG_LT12		0xF122
++#define	F367_OFDM_DEBUG_LT12		0xF12200FF
++
++/* DEBG_LT13 */
++#define	R367_OFDM_DEBG_LT13		0xF123
++#define	F367_OFDM_DEBUG_LT13		0xF12300FF
++
++/* DEBG_LT14 */
++#define	R367_OFDM_DEBG_LT14		0xF124
++#define	F367_OFDM_DEBUG_LT14		0xF12400FF
++
++/* DEBG_LT15 */
++#define	R367_OFDM_DEBG_LT15		0xF125
++#define	F367_OFDM_DEBUG_LT15		0xF12500FF
++
++/* DEBG_LT16 */
++#define	R367_OFDM_DEBG_LT16		0xF126
++#define	F367_OFDM_DEBUG_LT16		0xF12600FF
++
++/* DEBG_LT17 */
++#define	R367_OFDM_DEBG_LT17		0xF127
++#define	F367_OFDM_DEBUG_LT17		0xF12700FF
++
++/* DEBG_LT18 */
++#define	R367_OFDM_DEBG_LT18		0xF128
++#define	F367_OFDM_DEBUG_LT18		0xF12800FF
++
++/* DEBG_LT19 */
++#define	R367_OFDM_DEBG_LT19		0xF129
++#define	F367_OFDM_DEBUG_LT19		0xF12900FF
++
++/* DEBG_LT1A */
++#define	R367_OFDM_DEBG_LT1A		0xF12A
++#define	F367_OFDM_DEBUG_LT1A		0xF12A00FF
++
++/* DEBG_LT1B */
++#define	R367_OFDM_DEBG_LT1B		0xF12B
++#define	F367_OFDM_DEBUG_LT1B		0xF12B00FF
++
++/* DEBG_LT1C */
++#define	R367_OFDM_DEBG_LT1C		0xF12C
++#define	F367_OFDM_DEBUG_LT1C		0xF12C00FF
++
++/* DEBG_LT1D */
++#define	R367_OFDM_DEBG_LT1D		0xF12D
++#define	F367_OFDM_DEBUG_LT1D		0xF12D00FF
++
++/* DEBG_LT1E */
++#define	R367_OFDM_DEBG_LT1E		0xF12E
++#define	F367_OFDM_DEBUG_LT1E		0xF12E00FF
++
++/* DEBG_LT1F */
++#define	R367_OFDM_DEBG_LT1F		0xF12F
++#define	F367_OFDM_DEBUG_LT1F		0xF12F00FF
++
++/* RCCFGH */
++#define	R367_OFDM_RCCFGH		0xF200
++#define	F367_OFDM_TSRCFIFO_DVBCI		0xF2000080
++#define	F367_OFDM_TSRCFIFO_SERIAL		0xF2000040
++#define	F367_OFDM_TSRCFIFO_DISABLE		0xF2000020
++#define	F367_OFDM_TSFIFO_2TORC		0xF2000010
++#define	F367_OFDM_TSRCFIFO_HSGNLOUT		0xF2000008
++#define	F367_OFDM_TSRCFIFO_ERRMODE		0xF2000006
++#define	F367_OFDM_RCCFGH_0		0xF2000001
++
++/* RCCFGM */
++#define	R367_OFDM_RCCFGM		0xF201
++#define	F367_OFDM_TSRCFIFO_MANSPEED		0xF20100C0
++#define	F367_OFDM_TSRCFIFO_PERMDATA		0xF2010020
++#define	F367_OFDM_TSRCFIFO_NONEWSGNL		0xF2010010
++#define	F367_OFDM_RCBYTE_OVERSAMPLING		0xF201000E
++#define	F367_OFDM_TSRCFIFO_INVDATA		0xF2010001
++
++/* RCCFGL */
++#define	R367_OFDM_RCCFGL		0xF202
++#define	F367_OFDM_TSRCFIFO_BCLKDEL1CK		0xF20200C0
++#define	F367_OFDM_RCCFGL_5		0xF2020020
++#define	F367_OFDM_TSRCFIFO_DUTY50		0xF2020010
++#define	F367_OFDM_TSRCFIFO_NSGNL2DATA		0xF2020008
++#define	F367_OFDM_TSRCFIFO_DISSERMUX		0xF2020004
++#define	F367_OFDM_RCCFGL_1		0xF2020002
++#define	F367_OFDM_TSRCFIFO_STOPCKDIS		0xF2020001
++
++/* RCINSDELH */
++#define	R367_OFDM_RCINSDELH		0xF203
++#define	F367_OFDM_TSRCDEL_SYNCBYTE		0xF2030080
++#define	F367_OFDM_TSRCDEL_XXHEADER		0xF2030040
++#define	F367_OFDM_TSRCDEL_BBHEADER		0xF2030020
++#define	F367_OFDM_TSRCDEL_DATAFIELD		0xF2030010
++#define	F367_OFDM_TSRCINSDEL_ISCR		0xF2030008
++#define	F367_OFDM_TSRCINSDEL_NPD		0xF2030004
++#define	F367_OFDM_TSRCINSDEL_RSPARITY		0xF2030002
++#define	F367_OFDM_TSRCINSDEL_CRC8		0xF2030001
++
++/* RCINSDELM */
++#define	R367_OFDM_RCINSDELM		0xF204
++#define	F367_OFDM_TSRCINS_BBPADDING		0xF2040080
++#define	F367_OFDM_TSRCINS_BCHFEC		0xF2040040
++#define	F367_OFDM_TSRCINS_LDPCFEC		0xF2040020
++#define	F367_OFDM_TSRCINS_EMODCOD		0xF2040010
++#define	F367_OFDM_TSRCINS_TOKEN		0xF2040008
++#define	F367_OFDM_TSRCINS_XXXERR		0xF2040004
++#define	F367_OFDM_TSRCINS_MATYPE		0xF2040002
++#define	F367_OFDM_TSRCINS_UPL		0xF2040001
++
++/* RCINSDELL */
++#define	R367_OFDM_RCINSDELL		0xF205
++#define	F367_OFDM_TSRCINS_DFL		0xF2050080
++#define	F367_OFDM_TSRCINS_SYNCD		0xF2050040
++#define	F367_OFDM_TSRCINS_BLOCLEN		0xF2050020
++#define	F367_OFDM_TSRCINS_SIGPCOUNT		0xF2050010
++#define	F367_OFDM_TSRCINS_FIFO		0xF2050008
++#define	F367_OFDM_TSRCINS_REALPACK		0xF2050004
++#define	F367_OFDM_TSRCINS_TSCONFIG		0xF2050002
++#define	F367_OFDM_TSRCINS_LATENCY		0xF2050001
++
++/* RCSTATUS */
++#define	R367_OFDM_RCSTATUS		0xF206
++#define	F367_OFDM_TSRCFIFO_LINEOK		0xF2060080
++#define	F367_OFDM_TSRCFIFO_ERROR		0xF2060040
++#define	F367_OFDM_TSRCFIFO_DATA7		0xF2060020
++#define	F367_OFDM_RCSTATUS_4		0xF2060010
++#define	F367_OFDM_TSRCFIFO_DEMODSEL		0xF2060008
++#define	F367_OFDM_TSRC1FIFOSPEED_STORE		0xF2060004
++#define	F367_OFDM_RCSTATUS_1		0xF2060002
++#define	F367_OFDM_TSRCSERIAL_IMPOSSIBLE		0xF2060001
++
++/* RCSPEED */
++#define	R367_OFDM_RCSPEED		0xF207
++#define	F367_OFDM_TSRCFIFO_OUTSPEED		0xF20700FF
++
++/* RCDEBUGM */
++#define	R367_OFDM_RCDEBUGM		0xF208
++#define	F367_OFDM_SD_UNSYNC		0xF2080080
++#define	F367_OFDM_ULFLOCK_DETECTM		0xF2080040
++#define	F367_OFDM_SUL_SELECTOS		0xF2080020
++#define	F367_OFDM_DILUL_NOSCRBLE		0xF2080010
++#define	F367_OFDM_NUL_SCRB		0xF2080008
++#define	F367_OFDM_UL_SCRB		0xF2080004
++#define	F367_OFDM_SCRAULBAD		0xF2080002
++#define	F367_OFDM_SCRAUL_UNSYNC		0xF2080001
++
++/* RCDEBUGL */
++#define	R367_OFDM_RCDEBUGL		0xF209
++#define	F367_OFDM_RS_ERR		0xF2090080
++#define	F367_OFDM_LLFLOCK_DETECTM		0xF2090040
++#define	F367_OFDM_NOT_SUL_SELECTOS		0xF2090020
++#define	F367_OFDM_DILLL_NOSCRBLE		0xF2090010
++#define	F367_OFDM_NLL_SCRB		0xF2090008
++#define	F367_OFDM_LL_SCRB		0xF2090004
++#define	F367_OFDM_SCRALLBAD		0xF2090002
++#define	F367_OFDM_SCRALL_UNSYNC		0xF2090001
++
++/* RCOBSCFG */
++#define	R367_OFDM_RCOBSCFG		0xF20A
++#define	F367_OFDM_TSRCFIFO_OBSCFG		0xF20A00FF
++
++/* RCOBSM */
++#define	R367_OFDM_RCOBSM		0xF20B
++#define	F367_OFDM_TSRCFIFO_OBSDATA_HI		0xF20B00FF
++
++/* RCOBSL */
++#define	R367_OFDM_RCOBSL		0xF20C
++#define	F367_OFDM_TSRCFIFO_OBSDATA_LO		0xF20C00FF
++
++/* RCFECSPY */
++#define	R367_OFDM_RCFECSPY		0xF210
++#define	F367_OFDM_SPYRC_ENABLE		0xF2100080
++#define	F367_OFDM_RCNO_SYNCBYTE		0xF2100040
++#define	F367_OFDM_RCSERIAL_MODE		0xF2100020
++#define	F367_OFDM_RCUNUSUAL_PACKET		0xF2100010
++#define	F367_OFDM_BERRCMETER_DATAMODE		0xF210000C
++#define	F367_OFDM_BERRCMETER_LMODE		0xF2100002
++#define	F367_OFDM_BERRCMETER_RESET		0xF2100001
++
++/* RCFSPYCFG */
++#define	R367_OFDM_RCFSPYCFG		0xF211
++#define	F367_OFDM_FECSPYRC_INPUT		0xF21100C0
++#define	F367_OFDM_RCRST_ON_ERROR		0xF2110020
++#define	F367_OFDM_RCONE_SHOT		0xF2110010
++#define	F367_OFDM_RCI2C_MODE		0xF211000C
++#define	F367_OFDM_SPYRC_HSTERESIS		0xF2110003
++
++/* RCFSPYDATA */
++#define	R367_OFDM_RCFSPYDATA		0xF212
++#define	F367_OFDM_SPYRC_STUFFING		0xF2120080
++#define	F367_OFDM_RCNOERR_PKTJITTER		0xF2120040
++#define	F367_OFDM_SPYRC_CNULLPKT		0xF2120020
++#define	F367_OFDM_SPYRC_OUTDATA_MODE		0xF212001F
++
++/* RCFSPYOUT */
++#define	R367_OFDM_RCFSPYOUT		0xF213
++#define	F367_OFDM_FSPYRC_DIRECT		0xF2130080
++#define	F367_OFDM_RCFSPYOUT_6		0xF2130040
++#define	F367_OFDM_SPYRC_OUTDATA_BUS		0xF2130038
++#define	F367_OFDM_RCSTUFF_MODE		0xF2130007
++
++/* RCFSTATUS */
++#define	R367_OFDM_RCFSTATUS		0xF214
++#define	F367_OFDM_SPYRC_ENDSIM		0xF2140080
++#define	F367_OFDM_RCVALID_SIM		0xF2140040
++#define	F367_OFDM_RCFOUND_SIGNAL		0xF2140020
++#define	F367_OFDM_RCDSS_SYNCBYTE		0xF2140010
++#define	F367_OFDM_RCRESULT_STATE		0xF214000F
++
++/* RCFGOODPACK */
++#define	R367_OFDM_RCFGOODPACK		0xF215
++#define	F367_OFDM_RCGOOD_PACKET		0xF21500FF
++
++/* RCFPACKCNT */
++#define	R367_OFDM_RCFPACKCNT		0xF216
++#define	F367_OFDM_RCPACKET_COUNTER		0xF21600FF
++
++/* RCFSPYMISC */
++#define	R367_OFDM_RCFSPYMISC		0xF217
++#define	F367_OFDM_RCLABEL_COUNTER		0xF21700FF
++
++/* RCFBERCPT4 */
++#define	R367_OFDM_RCFBERCPT4		0xF218
++#define	F367_OFDM_FBERRCMETER_CPT_MMMMSB		0xF21800FF
++
++/* RCFBERCPT3 */
++#define	R367_OFDM_RCFBERCPT3		0xF219
++#define	F367_OFDM_FBERRCMETER_CPT_MMMSB		0xF21900FF
++
++/* RCFBERCPT2 */
++#define	R367_OFDM_RCFBERCPT2		0xF21A
++#define	F367_OFDM_FBERRCMETER_CPT_MMSB		0xF21A00FF
++
++/* RCFBERCPT1 */
++#define	R367_OFDM_RCFBERCPT1		0xF21B
++#define	F367_OFDM_FBERRCMETER_CPT_MSB		0xF21B00FF
++
++/* RCFBERCPT0 */
++#define	R367_OFDM_RCFBERCPT0		0xF21C
++#define	F367_OFDM_FBERRCMETER_CPT_LSB		0xF21C00FF
++
++/* RCFBERERR2 */
++#define	R367_OFDM_RCFBERERR2		0xF21D
++#define	F367_OFDM_FBERRCMETER_ERR_HI		0xF21D00FF
++
++/* RCFBERERR1 */
++#define	R367_OFDM_RCFBERERR1		0xF21E
++#define	F367_OFDM_FBERRCMETER_ERR		0xF21E00FF
++
++/* RCFBERERR0 */
++#define	R367_OFDM_RCFBERERR0		0xF21F
++#define	F367_OFDM_FBERRCMETER_ERR_LO		0xF21F00FF
++
++/* RCFSTATESM */
++#define	R367_OFDM_RCFSTATESM		0xF220
++#define	F367_OFDM_RCRSTATE_F		0xF2200080
++#define	F367_OFDM_RCRSTATE_E		0xF2200040
++#define	F367_OFDM_RCRSTATE_D		0xF2200020
++#define	F367_OFDM_RCRSTATE_C		0xF2200010
++#define	F367_OFDM_RCRSTATE_B		0xF2200008
++#define	F367_OFDM_RCRSTATE_A		0xF2200004
++#define	F367_OFDM_RCRSTATE_9		0xF2200002
++#define	F367_OFDM_RCRSTATE_8		0xF2200001
++
++/* RCFSTATESL */
++#define	R367_OFDM_RCFSTATESL		0xF221
++#define	F367_OFDM_RCRSTATE_7		0xF2210080
++#define	F367_OFDM_RCRSTATE_6		0xF2210040
++#define	F367_OFDM_RCRSTATE_5		0xF2210020
++#define	F367_OFDM_RCRSTATE_4		0xF2210010
++#define	F367_OFDM_RCRSTATE_3		0xF2210008
++#define	F367_OFDM_RCRSTATE_2		0xF2210004
++#define	F367_OFDM_RCRSTATE_1		0xF2210002
++#define	F367_OFDM_RCRSTATE_0		0xF2210001
++
++/* RCFSPYBER */
++#define	R367_OFDM_RCFSPYBER		0xF222
++#define	F367_OFDM_RCFSPYBER_7		0xF2220080
++#define	F367_OFDM_SPYRCOBS_XORREAD		0xF2220040
++#define	F367_OFDM_FSPYRCBER_OBSMODE		0xF2220020
++#define	F367_OFDM_FSPYRCBER_SYNCBYT		0xF2220010
++#define	F367_OFDM_FSPYRCBER_UNSYNC		0xF2220008
++#define	F367_OFDM_FSPYRCBER_CTIME		0xF2220007
++
++/* RCFSPYDISTM */
++#define	R367_OFDM_RCFSPYDISTM		0xF223
++#define	F367_OFDM_RCPKTTIME_DISTANCE_HI		0xF22300FF
++
++/* RCFSPYDISTL */
++#define	R367_OFDM_RCFSPYDISTL		0xF224
++#define	F367_OFDM_RCPKTTIME_DISTANCE_LO		0xF22400FF
++
++/* RCFSPYOBS7 */
++#define	R367_OFDM_RCFSPYOBS7		0xF228
++#define	F367_OFDM_RCSPYOBS_SPYFAIL		0xF2280080
++#define	F367_OFDM_RCSPYOBS_SPYFAIL1		0xF2280040
++#define	F367_OFDM_RCSPYOBS_ERROR		0xF2280020
++#define	F367_OFDM_RCSPYOBS_STROUT		0xF2280010
++#define	F367_OFDM_RCSPYOBS_RESULTSTATE1		0xF228000F
++
++/* RCFSPYOBS6 */
++#define	R367_OFDM_RCFSPYOBS6		0xF229
++#define	F367_OFDM_RCSPYOBS_RESULTSTATE0		0xF22900F0
++#define	F367_OFDM_RCSPYOBS_RESULTSTATEM1		0xF229000F
++
++/* RCFSPYOBS5 */
++#define	R367_OFDM_RCFSPYOBS5		0xF22A
++#define	F367_OFDM_RCSPYOBS_BYTEOFPACKET1		0xF22A00FF
++
++/* RCFSPYOBS4 */
++#define	R367_OFDM_RCFSPYOBS4		0xF22B
++#define	F367_OFDM_RCSPYOBS_BYTEVALUE1		0xF22B00FF
++
++/* RCFSPYOBS3 */
++#define	R367_OFDM_RCFSPYOBS3		0xF22C
++#define	F367_OFDM_RCSPYOBS_DATA1		0xF22C00FF
++
++/* RCFSPYOBS2 */
++#define	R367_OFDM_RCFSPYOBS2		0xF22D
++#define	F367_OFDM_RCSPYOBS_DATA0		0xF22D00FF
++
++/* RCFSPYOBS1 */
++#define	R367_OFDM_RCFSPYOBS1		0xF22E
++#define	F367_OFDM_RCSPYOBS_DATAM1		0xF22E00FF
++
++/* RCFSPYOBS0 */
++#define	R367_OFDM_RCFSPYOBS0		0xF22F
++#define	F367_OFDM_RCSPYOBS_DATAM2		0xF22F00FF
++
++/* TSGENERAL */
++#define	R367_TSGENERAL		0xF230
++#define	F367_TSGENERAL_7		0xF2300080
++#define	F367_TSGENERAL_6		0xF2300040
++#define	F367_TSFIFO_BCLK1ALL		0xF2300020
++#define	F367_TSGENERAL_4		0xF2300010
++#define	F367_MUXSTREAM_OUTMODE		0xF2300008
++#define	F367_TSFIFO_PERMPARAL		0xF2300006
++#define	F367_RST_REEDSOLO		0xF2300001
++
++/* RC1SPEED */
++#define	R367_RC1SPEED		0xF231
++#define	F367_TSRCFIFO1_OUTSPEED		0xF23100FF
++
++/* TSGSTATUS */
++#define	R367_TSGSTATUS		0xF232
++#define	F367_TSGSTATUS_7		0xF2320080
++#define	F367_TSGSTATUS_6		0xF2320040
++#define	F367_RSMEM_FULL		0xF2320020
++#define	F367_RS_MULTCALC		0xF2320010
++#define	F367_RSIN_OVERTIME		0xF2320008
++#define	F367_TSFIFO3_DEMODSEL		0xF2320004
++#define	F367_TSFIFO2_DEMODSEL		0xF2320002
++#define	F367_TSFIFO1_DEMODSEL		0xF2320001
++
++
++/* FECM */
++#define	R367_OFDM_FECM		0xF233
++#define	F367_OFDM_DSS_DVB		0xF2330080
++#define	F367_OFDM_DEMOD_BYPASS		0xF2330040
++#define	F367_OFDM_CMP_SLOWMODE		0xF2330020
++#define	F367_OFDM_DSS_SRCH		0xF2330010
++#define	F367_OFDM_FECM_3		0xF2330008
++#define	F367_OFDM_DIFF_MODEVIT		0xF2330004
++#define	F367_OFDM_SYNCVIT		0xF2330002
++#define	F367_OFDM_I2CSYM		0xF2330001
++
++/* VTH12 */
++#define	R367_OFDM_VTH12		0xF234
++#define	F367_OFDM_VTH_12		0xF23400FF
++
++/* VTH23 */
++#define	R367_OFDM_VTH23		0xF235
++#define	F367_OFDM_VTH_23		0xF23500FF
++
++/* VTH34 */
++#define	R367_OFDM_VTH34		0xF236
++#define	F367_OFDM_VTH_34		0xF23600FF
++
++/* VTH56 */
++#define	R367_OFDM_VTH56		0xF237
++#define	F367_OFDM_VTH_56		0xF23700FF
++
++/* VTH67 */
++#define	R367_OFDM_VTH67		0xF238
++#define	F367_OFDM_VTH_67		0xF23800FF
++
++/* VTH78 */
++#define	R367_OFDM_VTH78		0xF239
++#define	F367_OFDM_VTH_78		0xF23900FF
++
++/* VITCURPUN */
++#define	R367_OFDM_VITCURPUN		0xF23A
++#define	F367_OFDM_VIT_MAPPING		0xF23A00E0
++#define	F367_OFDM_VIT_CURPUN		0xF23A001F
++
++/* VERROR */
++#define	R367_OFDM_VERROR		0xF23B
++#define	F367_OFDM_REGERR_VIT		0xF23B00FF
++
++/* PRVIT */
++#define	R367_OFDM_PRVIT		0xF23C
++#define	F367_OFDM_PRVIT_7		0xF23C0080
++#define	F367_OFDM_DIS_VTHLOCK		0xF23C0040
++#define	F367_OFDM_E7_8VIT		0xF23C0020
++#define	F367_OFDM_E6_7VIT		0xF23C0010
++#define	F367_OFDM_E5_6VIT		0xF23C0008
++#define	F367_OFDM_E3_4VIT		0xF23C0004
++#define	F367_OFDM_E2_3VIT		0xF23C0002
++#define	F367_OFDM_E1_2VIT		0xF23C0001
++
++/* VAVSRVIT */
++#define	R367_OFDM_VAVSRVIT		0xF23D
++#define	F367_OFDM_AMVIT		0xF23D0080
++#define	F367_OFDM_FROZENVIT		0xF23D0040
++#define	F367_OFDM_SNVIT		0xF23D0030
++#define	F367_OFDM_TOVVIT		0xF23D000C
++#define	F367_OFDM_HYPVIT		0xF23D0003
++
++/* VSTATUSVIT */
++#define	R367_OFDM_VSTATUSVIT		0xF23E
++#define	F367_OFDM_VITERBI_ON		0xF23E0080
++#define	F367_OFDM_END_LOOPVIT		0xF23E0040
++#define	F367_OFDM_VITERBI_DEPRF		0xF23E0020
++#define	F367_OFDM_PRFVIT		0xF23E0010
++#define	F367_OFDM_LOCKEDVIT		0xF23E0008
++#define	F367_OFDM_VITERBI_DELOCK		0xF23E0004
++#define	F367_OFDM_VIT_DEMODSEL		0xF23E0002
++#define	F367_OFDM_VITERBI_COMPOUT		0xF23E0001
++
++/* VTHINUSE */
++#define	R367_OFDM_VTHINUSE		0xF23F
++#define	F367_OFDM_VIT_INUSE		0xF23F00FF
++
++/* KDIV12 */
++#define	R367_OFDM_KDIV12		0xF240
++#define	F367_OFDM_KDIV12_MANUAL		0xF2400080
++#define	F367_OFDM_K_DIVIDER_12		0xF240007F
++
++/* KDIV23 */
++#define	R367_OFDM_KDIV23		0xF241
++#define	F367_OFDM_KDIV23_MANUAL		0xF2410080
++#define	F367_OFDM_K_DIVIDER_23		0xF241007F
++
++/* KDIV34 */
++#define	R367_OFDM_KDIV34		0xF242
++#define	F367_OFDM_KDIV34_MANUAL		0xF2420080
++#define	F367_OFDM_K_DIVIDER_34		0xF242007F
++
++/* KDIV56 */
++#define	R367_OFDM_KDIV56		0xF243
++#define	F367_OFDM_KDIV56_MANUAL		0xF2430080
++#define	F367_OFDM_K_DIVIDER_56		0xF243007F
++
++/* KDIV67 */
++#define	R367_OFDM_KDIV67		0xF244
++#define	F367_OFDM_KDIV67_MANUAL		0xF2440080
++#define	F367_OFDM_K_DIVIDER_67		0xF244007F
++
++/* KDIV78 */
++#define	R367_OFDM_KDIV78		0xF245
++#define	F367_OFDM_KDIV78_MANUAL		0xF2450080
++#define	F367_OFDM_K_DIVIDER_78		0xF245007F
++
++/* SIGPOWER */
++#define	R367_OFDM_SIGPOWER		0xF246
++#define	F367_OFDM_SIGPOWER_MANUAL		0xF2460080
++#define	F367_OFDM_SIG_POWER		0xF246007F
++
++/* DEMAPVIT */
++#define	R367_OFDM_DEMAPVIT		0xF247
++#define	F367_OFDM_DEMAPVIT_7		0xF2470080
++#define	F367_OFDM_K_DIVIDER_VIT		0xF247007F
++
++/* VITSCALE */
++#define	R367_OFDM_VITSCALE		0xF248
++#define	F367_OFDM_NVTH_NOSRANGE		0xF2480080
++#define	F367_OFDM_VERROR_MAXMODE		0xF2480040
++#define	F367_OFDM_KDIV_MODE		0xF2480030
++#define	F367_OFDM_NSLOWSN_LOCKED		0xF2480008
++#define	F367_OFDM_DELOCK_PRFLOSS		0xF2480004
++#define	F367_OFDM_DIS_RSFLOCK		0xF2480002
++#define	F367_OFDM_VITSCALE_0		0xF2480001
++
++/* FFEC1PRG */
++#define	R367_OFDM_FFEC1PRG		0xF249
++#define	F367_OFDM_FDSS_DVB		0xF2490080
++#define	F367_OFDM_FDSS_SRCH		0xF2490040
++#define	F367_OFDM_FFECPROG_5		0xF2490020
++#define	F367_OFDM_FFECPROG_4		0xF2490010
++#define	F367_OFDM_FFECPROG_3		0xF2490008
++#define	F367_OFDM_FFECPROG_2		0xF2490004
++#define	F367_OFDM_FTS1_DISABLE		0xF2490002
++#define	F367_OFDM_FTS2_DISABLE		0xF2490001
++
++/* FVITCURPUN */
++#define	R367_OFDM_FVITCURPUN		0xF24A
++#define	F367_OFDM_FVIT_MAPPING		0xF24A00E0
++#define	F367_OFDM_FVIT_CURPUN		0xF24A001F
++
++/* FVERROR */
++#define	R367_OFDM_FVERROR		0xF24B
++#define	F367_OFDM_FREGERR_VIT		0xF24B00FF
++
++/* FVSTATUSVIT */
++#define	R367_OFDM_FVSTATUSVIT		0xF24C
++#define	F367_OFDM_FVITERBI_ON		0xF24C0080
++#define	F367_OFDM_F1END_LOOPVIT		0xF24C0040
++#define	F367_OFDM_FVITERBI_DEPRF		0xF24C0020
++#define	F367_OFDM_FPRFVIT		0xF24C0010
++#define	F367_OFDM_FLOCKEDVIT		0xF24C0008
++#define	F367_OFDM_FVITERBI_DELOCK		0xF24C0004
++#define	F367_OFDM_FVIT_DEMODSEL		0xF24C0002
++#define	F367_OFDM_FVITERBI_COMPOUT		0xF24C0001
++
++/* DEBUG_LT1 */
++#define	R367_OFDM_DEBUG_LT1		0xF24D
++#define	F367_OFDM_DBG_LT1		0xF24D00FF
++
++/* DEBUG_LT2 */
++#define	R367_OFDM_DEBUG_LT2		0xF24E
++#define	F367_OFDM_DBG_LT2		0xF24E00FF
++
++/* DEBUG_LT3 */
++#define	R367_OFDM_DEBUG_LT3		0xF24F
++#define	F367_OFDM_DBG_LT3		0xF24F00FF
++
++	/*	TSTSFMET */
++#define	R367_OFDM_TSTSFMET			0xF250
++#define F367_OFDM_TSTSFEC_METRIQUES	0xF25000FF
++
++	/*	SELOUT */
++#define	R367_OFDM_SELOUT				0xF252
++#define	F367_OFDM_EN_SYNC			0xF2520080
++#define	F367_OFDM_EN_TBUSDEMAP       0xF2520040
++#define	F367_OFDM_SELOUT_5			0xF2520020
++#define	F367_OFDM_SELOUT_4			0xF2520010
++#define	F367_OFDM_TSTSYNCHRO_MODE    0xF2520002
++
++	/*	TSYNC */
++#define R367_OFDM_TSYNC				0xF253
++#define F367_OFDM_CURPUN_INCMODE		0xF2530080
++#define F367_OFDM_CERR_TSTMODE		0xF2530040
++#define F367_OFDM_SHIFTSOF_MODE		0xF2530030
++#define F367_OFDM_SLOWPHA_MODE		0xF2530008
++#define F367_OFDM_PXX_BYPALL			0xF2530004
++#define F367_OFDM_FROTA45_FIRST		0xF2530002
++#define F367_OFDM_TST_BCHERROR		0xF2530001
++
++	/*	TSTERR */
++#define R367_OFDM_TSTERR				0xF254
++#define F367_OFDM_TST_LONGPKT		0xF2540080
++#define F367_OFDM_TST_ISSYION		0xF2540040
++#define F367_OFDM_TST_NPDON			0xF2540020
++#define F367_OFDM_TSTERR_4			0xF2540010
++#define F367_OFDM_TRACEBACK_MODE		0xF2540008
++#define F367_OFDM_TST_RSPARITY		0xF2540004
++#define F367_OFDM_METRIQUE_MODE		0xF2540003
++
++	/*	TSFSYNC */
++#define R367_OFDM_TSFSYNC			0xF255
++#define F367_OFDM_EN_SFECSYNC		0xF2550080
++#define F367_OFDM_EN_SFECDEMAP		0xF2550040
++#define F367_OFDM_SFCERR_TSTMODE		0xF2550020
++#define F367_OFDM_SFECPXX_BYPALL		0xF2550010
++#define F367_OFDM_SFECTSTSYNCHRO_MODE 0xF255000F
++
++	/*	TSTSFERR */
++#define R367_OFDM_TSTSFERR			0xF256
++#define F367_OFDM_TSTSTERR_7			0xF2560080
++#define F367_OFDM_TSTSTERR_6			0xF2560040
++#define F367_OFDM_TSTSTERR_5 		0xF2560020
++#define F367_OFDM_TSTSTERR_4			0xF2560010
++#define F367_OFDM_SFECTRACEBACK_MODE	0xF2560008
++#define F367_OFDM_SFEC_NCONVPROG		0xF2560004
++#define F367_OFDM_SFECMETRIQUE_MODE	0xF2560003
++
++	/*	TSTTSSF1 */
++#define R367_OFDM_TSTTSSF1			0xF258
++#define F367_OFDM_TSTERSSF			0xF2580080
++#define F367_OFDM_TSTTSSFEN			0xF2580040
++#define F367_OFDM_SFEC_OUTMODE		0xF2580030
++#define F367_OFDM_XLSF_NOFTHRESHOLD  0xF2580008
++#define F367_OFDM_TSTTSSF_STACKSEL	0xF2580007
++
++	/*	TSTTSSF2 */
++#define R367_OFDM_TSTTSSF2			0xF259
++#define F367_OFDM_DILSF_DBBHEADER	0xF2590080
++#define F367_OFDM_TSTTSSF_DISBUG		0xF2590040
++#define F367_OFDM_TSTTSSF_NOBADSTART	0xF2590020
++#define F367_OFDM_TSTTSSF_SELECT 	0xF259001F
++
++	/*	TSTTSSF3 */
++#define R367_OFDM_TSTTSSF3			0xF25A
++#define F367_OFDM_TSTTSSF3_7			0xF25A0080
++#define F367_OFDM_TSTTSSF3_6			0xF25A0040
++#define F367_OFDM_TSTTSSF3_5			0xF25A0020
++#define F367_OFDM_TSTTSSF3_4			0xF25A0010
++#define F367_OFDM_TSTTSSF3_3			0xF25A0008
++#define F367_OFDM_TSTTSSF3_2			0xF25A0004
++#define F367_OFDM_TSTTSSF3_1			0xF25A0002
++#define F367_OFDM_DISSF_CLKENABLE    0xF25A0001
++
++	/*	TSTTS1 */
++#define R367_OFDM_TSTTS1				0xF25C
++#define F367_OFDM_TSTERS				0xF25C0080
++#define F367_OFDM_TSFIFO_DSSSYNCB	0xF25C0040
++#define F367_OFDM_TSTTS_FSPYBEFRS	0xF25C0020
++#define F367_OFDM_NFORCE_SYNCBYTE	0xF25C0010
++#define F367_OFDM_XL_NOFTHRESHOLD	0xF25C0008
++#define F367_OFDM_TSTTS_FRFORCEPKT	0xF25C0004
++#define F367_OFDM_DESCR_NOTAUTO		0xF25C0002
++#define F367_OFDM_TSTTSEN			0xF25C0001
++
++	/*	TSTTS2 */
++#define R367_OFDM_TSTTS2				0xF25D
++#define F367_OFDM_DIL_DBBHEADER		0xF25D0080
++#define F367_OFDM_TSTTS_NOBADXXX		0xF25D0040
++#define F367_OFDM_TSFIFO_DELSPEEDUP	0xF25D0020
++#define F367_OFDM_TSTTS_SELECT		0xF25D001F
++
++	/*	TSTTS3 */
++#define R367_OFDM_TSTTS3				0xF25E
++#define F367_OFDM_TSTTS_NOPKTGAIN	0xF25E0080
++#define F367_OFDM_TSTTS_NOPKTENE		0xF25E0040
++#define F367_OFDM_TSTTS_ISOLATION	0xF25E0020
++#define F367_OFDM_TSTTS_DISBUG		0xF25E0010
++#define F367_OFDM_TSTTS_NOBADSTART	0xF25E0008
++#define F367_OFDM_TSTTS_STACKSEL		0xF25E0007
++
++	/*	TSTTS4 */
++#define R367_OFDM_TSTTS4				0xF25F
++#define F367_OFDM_TSTTS4_7			0xF25F0080
++#define F367_OFDM_TSTTS4_6			0xF25F0040
++#define F367_OFDM_TSTTS4_5			0xF25F0020
++#define F367_OFDM_TSTTS_DISDSTATE	0xF25F0010
++#define F367_OFDM_TSTTS_FASTNOSYNC	0xF25F0008
++#define F367_OFDM_EXT_FECSPYIN		0xF25F0004
++#define F367_OFDM_TSTTS_NODPZERO		0xF25F0002
++#define F367_OFDM_TSTTS_NODIV3		0xF25F0001
++
++	/*	TSTTSRC */
++#define R367_OFDM_TSTTSRC				0xF26C
++#define F367_OFDM_TSTTSRC_7				0xF26C0080
++#define F367_OFDM_TSRCFIFO_DSSSYNCB		0xF26C0040
++#define F367_OFDM_TSRCFIFO_DPUNACTIVE	0xF26C0020
++#define F367_OFDM_TSRCFIFO_DELSPEEDUP	0xF26C0010
++#define F367_OFDM_TSTTSRC_NODIV3			0xF26C0008
++#define F367_OFDM_TSTTSRC_FRFORCEPKT		0xF26C0004
++#define F367_OFDM_SAT25_SDDORIGINE		0xF26C0002
++#define F367_OFDM_TSTTSRC_INACTIVE		0xF26C0001
++
++	/*	TSTTSRS */
++#define R367_OFDM_TSTTSRS				0xF26D
++#define F367_OFDM_TSTTSRS_7				0xF26D0080
++#define F367_OFDM_TSTTSRS_6				0xF26D0040
++#define F367_OFDM_TSTTSRS_5				0xF26D0020
++#define F367_OFDM_TSTTSRS_4				0xF26D0010
++#define F367_OFDM_TSTTSRS_3				0xF26D0008
++#define F367_OFDM_TSTTSRS_2				0xF26D0004
++#define F367_OFDM_TSTRS_DISRS2			0xF26D0002
++#define F367_OFDM_TSTRS_DISRS1			0xF26D0001
++
++/* TSSTATEM */
++#define	R367_OFDM_TSSTATEM		0xF270
++#define	F367_OFDM_TSDIL_ON		0xF2700080
++#define	F367_OFDM_TSSKIPRS_ON		0xF2700040
++#define	F367_OFDM_TSRS_ON		0xF2700020
++#define	F367_OFDM_TSDESCRAMB_ON		0xF2700010
++#define	F367_OFDM_TSFRAME_MODE		0xF2700008
++#define	F367_OFDM_TS_DISABLE		0xF2700004
++#define	F367_OFDM_TSACM_MODE		0xF2700002
++#define	F367_OFDM_TSOUT_NOSYNC		0xF2700001
++
++/* TSSTATEL */
++#define	R367_OFDM_TSSTATEL		0xF271
++#define	F367_OFDM_TSNOSYNCBYTE		0xF2710080
++#define	F367_OFDM_TSPARITY_ON		0xF2710040
++#define	F367_OFDM_TSSYNCOUTRS_ON		0xF2710020
++#define	F367_OFDM_TSDVBS2_MODE		0xF2710010
++#define	F367_OFDM_TSISSYI_ON		0xF2710008
++#define	F367_OFDM_TSNPD_ON		0xF2710004
++#define	F367_OFDM_TSCRC8_ON		0xF2710002
++#define	F367_OFDM_TSDSS_PACKET		0xF2710001
++
++/* TSCFGH */
++#define	R367_OFDM_TSCFGH		0xF272
++#define	F367_OFDM_TSFIFO_DVBCI		0xF2720080
++#define	F367_OFDM_TSFIFO_SERIAL		0xF2720040
++#define	F367_OFDM_TSFIFO_TEIUPDATE		0xF2720020
++#define	F367_OFDM_TSFIFO_DUTY50		0xF2720010
++#define	F367_OFDM_TSFIFO_HSGNLOUT		0xF2720008
++#define	F367_OFDM_TSFIFO_ERRMODE		0xF2720006
++#define	F367_OFDM_RST_HWARE		0xF2720001
++
++/* TSCFGM */
++#define	R367_OFDM_TSCFGM		0xF273
++#define	F367_OFDM_TSFIFO_MANSPEED		0xF27300C0
++#define	F367_OFDM_TSFIFO_PERMDATA		0xF2730020
++#define	F367_OFDM_TSFIFO_NONEWSGNL		0xF2730010
++#define	F367_OFDM_TSFIFO_BITSPEED		0xF2730008
++#define	F367_OFDM_NPD_SPECDVBS2		0xF2730004
++#define	F367_OFDM_TSFIFO_STOPCKDIS		0xF2730002
++#define	F367_OFDM_TSFIFO_INVDATA		0xF2730001
++
++/* TSCFGL */
++#define	R367_OFDM_TSCFGL		0xF274
++#define	F367_OFDM_TSFIFO_BCLKDEL1CK		0xF27400C0
++#define	F367_OFDM_BCHERROR_MODE		0xF2740030
++#define	F367_OFDM_TSFIFO_NSGNL2DATA		0xF2740008
++#define	F367_OFDM_TSFIFO_EMBINDVB		0xF2740004
++#define	F367_OFDM_TSFIFO_DPUNACT		0xF2740002
++#define	F367_OFDM_TSFIFO_NPDOFF		0xF2740001
++
++/* TSSYNC */
++#define	R367_OFDM_TSSYNC		0xF275
++#define	F367_OFDM_TSFIFO_PERMUTE		0xF2750080
++#define	F367_OFDM_TSFIFO_FISCR3B		0xF2750060
++#define	F367_OFDM_TSFIFO_SYNCMODE		0xF2750018
++#define	F367_OFDM_TSFIFO_SYNCSEL		0xF2750007
++
++/* TSINSDELH */
++#define	R367_OFDM_TSINSDELH		0xF276
++#define	F367_OFDM_TSDEL_SYNCBYTE		0xF2760080
++#define	F367_OFDM_TSDEL_XXHEADER		0xF2760040
++#define	F367_OFDM_TSDEL_BBHEADER		0xF2760020
++#define	F367_OFDM_TSDEL_DATAFIELD		0xF2760010
++#define	F367_OFDM_TSINSDEL_ISCR		0xF2760008
++#define	F367_OFDM_TSINSDEL_NPD		0xF2760004
++#define	F367_OFDM_TSINSDEL_RSPARITY		0xF2760002
++#define	F367_OFDM_TSINSDEL_CRC8		0xF2760001
++
++/* TSINSDELM */
++#define	R367_OFDM_TSINSDELM		0xF277
++#define	F367_OFDM_TSINS_BBPADDING		0xF2770080
++#define	F367_OFDM_TSINS_BCHFEC		0xF2770040
++#define	F367_OFDM_TSINS_LDPCFEC		0xF2770020
++#define	F367_OFDM_TSINS_EMODCOD		0xF2770010
++#define	F367_OFDM_TSINS_TOKEN		0xF2770008
++#define	F367_OFDM_TSINS_XXXERR		0xF2770004
++#define	F367_OFDM_TSINS_MATYPE		0xF2770002
++#define	F367_OFDM_TSINS_UPL		0xF2770001
++
++/* TSINSDELL */
++#define	R367_OFDM_TSINSDELL		0xF278
++#define	F367_OFDM_TSINS_DFL		0xF2780080
++#define	F367_OFDM_TSINS_SYNCD		0xF2780040
++#define	F367_OFDM_TSINS_BLOCLEN		0xF2780020
++#define	F367_OFDM_TSINS_SIGPCOUNT		0xF2780010
++#define	F367_OFDM_TSINS_FIFO		0xF2780008
++#define	F367_OFDM_TSINS_REALPACK		0xF2780004
++#define	F367_OFDM_TSINS_TSCONFIG		0xF2780002
++#define	F367_OFDM_TSINS_LATENCY		0xF2780001
++
++/* TSDIVN */
++#define	R367_OFDM_TSDIVN		0xF279
++#define	F367_OFDM_TSFIFO_LOWSPEED		0xF2790080
++#define	F367_OFDM_BYTE_OVERSAMPLING		0xF2790070
++#define	F367_OFDM_TSMANUAL_PACKETNBR		0xF279000F
++
++/* TSDIVPM */
++#define	R367_OFDM_TSDIVPM		0xF27A
++#define	F367_OFDM_TSMANUAL_P_HI		0xF27A00FF
++
++/* TSDIVPL */
++#define	R367_OFDM_TSDIVPL		0xF27B
++#define	F367_OFDM_TSMANUAL_P_LO		0xF27B00FF
++
++/* TSDIVQM */
++#define	R367_OFDM_TSDIVQM		0xF27C
++#define	F367_OFDM_TSMANUAL_Q_HI		0xF27C00FF
++
++/* TSDIVQL */
++#define	R367_OFDM_TSDIVQL		0xF27D
++#define	F367_OFDM_TSMANUAL_Q_LO		0xF27D00FF
++
++/* TSDILSTKM */
++#define	R367_OFDM_TSDILSTKM		0xF27E
++#define	F367_OFDM_TSFIFO_DILSTK_HI		0xF27E00FF
++
++/* TSDILSTKL */
++#define	R367_OFDM_TSDILSTKL		0xF27F
++#define	F367_OFDM_TSFIFO_DILSTK_LO		0xF27F00FF
++
++/* TSSPEED */
++#define	R367_OFDM_TSSPEED		0xF280
++#define	F367_OFDM_TSFIFO_OUTSPEED		0xF28000FF
++
++/* TSSTATUS */
++#define	R367_OFDM_TSSTATUS		0xF281
++#define	F367_OFDM_TSFIFO_LINEOK		0xF2810080
++#define	F367_OFDM_TSFIFO_ERROR		0xF2810040
++#define	F367_OFDM_TSFIFO_DATA7		0xF2810020
++#define	F367_OFDM_TSFIFO_NOSYNC		0xF2810010
++#define	F367_OFDM_ISCR_INITIALIZED		0xF2810008
++#define	F367_OFDM_ISCR_UPDATED		0xF2810004
++#define	F367_OFDM_SOFFIFO_UNREGUL		0xF2810002
++#define	F367_OFDM_DIL_READY		0xF2810001
++
++/* TSSTATUS2 */
++#define	R367_OFDM_TSSTATUS2		0xF282
++#define	F367_OFDM_TSFIFO_DEMODSEL		0xF2820080
++#define	F367_OFDM_TSFIFOSPEED_STORE		0xF2820040
++#define	F367_OFDM_DILXX_RESET		0xF2820020
++#define	F367_OFDM_TSSERIAL_IMPOSSIBLE		0xF2820010
++#define	F367_OFDM_TSFIFO_UNDERSPEED		0xF2820008
++#define	F367_OFDM_BITSPEED_EVENT		0xF2820004
++#define	F367_OFDM_UL_SCRAMBDETECT		0xF2820002
++#define	F367_OFDM_ULDTV67_FALSELOCK		0xF2820001
++
++/* TSBITRATEM */
++#define	R367_OFDM_TSBITRATEM		0xF283
++#define	F367_OFDM_TSFIFO_BITRATE_HI		0xF28300FF
++
++/* TSBITRATEL */
++#define	R367_OFDM_TSBITRATEL		0xF284
++#define	F367_OFDM_TSFIFO_BITRATE_LO		0xF28400FF
++
++/* TSPACKLENM */
++#define	R367_OFDM_TSPACKLENM		0xF285
++#define	F367_OFDM_TSFIFO_PACKCPT		0xF28500E0
++#define	F367_OFDM_DIL_RPLEN_HI		0xF285001F
++
++/* TSPACKLENL */
++#define	R367_OFDM_TSPACKLENL		0xF286
++#define	F367_OFDM_DIL_RPLEN_LO		0xF28600FF
++
++/* TSBLOCLENM */
++#define	R367_OFDM_TSBLOCLENM		0xF287
++#define	F367_OFDM_TSFIFO_PFLEN_HI		0xF28700FF
++
++/* TSBLOCLENL */
++#define	R367_OFDM_TSBLOCLENL		0xF288
++#define	F367_OFDM_TSFIFO_PFLEN_LO		0xF28800FF
++
++/* TSDLYH */
++#define	R367_OFDM_TSDLYH		0xF289
++#define	F367_OFDM_SOFFIFO_TSTIMEVALID		0xF2890080
++#define	F367_OFDM_SOFFIFO_SPEEDUP		0xF2890040
++#define	F367_OFDM_SOFFIFO_STOP		0xF2890020
++#define	F367_OFDM_SOFFIFO_REGULATED		0xF2890010
++#define	F367_OFDM_SOFFIFO_REALSBOFF_HI		0xF289000F
++
++/* TSDLYM */
++#define	R367_OFDM_TSDLYM		0xF28A
++#define	F367_OFDM_SOFFIFO_REALSBOFF_MED		0xF28A00FF
++
++/* TSDLYL */
++#define	R367_OFDM_TSDLYL		0xF28B
++#define	F367_OFDM_SOFFIFO_REALSBOFF_LO		0xF28B00FF
++
++/* TSNPDAV */
++#define	R367_OFDM_TSNPDAV		0xF28C
++#define	F367_OFDM_TSNPD_AVERAGE		0xF28C00FF
++
++/* TSBUFSTATH */
++#define	R367_OFDM_TSBUFSTATH		0xF28D
++#define	F367_OFDM_TSISCR_3BYTES		0xF28D0080
++#define	F367_OFDM_TSISCR_NEWDATA		0xF28D0040
++#define	F367_OFDM_TSISCR_BUFSTAT_HI		0xF28D003F
++
++/* TSBUFSTATM */
++#define	R367_OFDM_TSBUFSTATM		0xF28E
++#define	F367_OFDM_TSISCR_BUFSTAT_MED		0xF28E00FF
++
++/* TSBUFSTATL */
++#define	R367_OFDM_TSBUFSTATL		0xF28F
++#define	F367_OFDM_TSISCR_BUFSTAT_LO		0xF28F00FF
++
++/* TSDEBUGM */
++#define	R367_OFDM_TSDEBUGM		0xF290
++#define	F367_OFDM_TSFIFO_ILLPACKET		0xF2900080
++#define	F367_OFDM_DIL_NOSYNC		0xF2900040
++#define	F367_OFDM_DIL_ISCR		0xF2900020
++#define	F367_OFDM_DILOUT_BSYNCB		0xF2900010
++#define	F367_OFDM_TSFIFO_EMPTYPKT		0xF2900008
++#define	F367_OFDM_TSFIFO_EMPTYRD		0xF2900004
++#define	F367_OFDM_SOFFIFO_STOPM		0xF2900002
++#define	F367_OFDM_SOFFIFO_SPEEDUPM		0xF2900001
++
++/* TSDEBUGL */
++#define	R367_OFDM_TSDEBUGL		0xF291
++#define	F367_OFDM_TSFIFO_PACKLENFAIL		0xF2910080
++#define	F367_OFDM_TSFIFO_SYNCBFAIL		0xF2910040
++#define	F367_OFDM_TSFIFO_VITLIBRE		0xF2910020
++#define	F367_OFDM_TSFIFO_BOOSTSPEEDM		0xF2910010
++#define	F367_OFDM_TSFIFO_UNDERSPEEDM		0xF2910008
++#define	F367_OFDM_TSFIFO_ERROR_EVNT		0xF2910004
++#define	F367_OFDM_TSFIFO_FULL		0xF2910002
++#define	F367_OFDM_TSFIFO_OVERFLOWM		0xF2910001
++
++/* TSDLYSETH */
++#define	R367_OFDM_TSDLYSETH		0xF292
++#define	F367_OFDM_SOFFIFO_OFFSET		0xF29200E0
++#define	F367_OFDM_SOFFIFO_SYMBOFFSET_HI		0xF292001F
++
++/* TSDLYSETM */
++#define	R367_OFDM_TSDLYSETM		0xF293
++#define	F367_OFDM_SOFFIFO_SYMBOFFSET_MED		0xF29300FF
++
++/* TSDLYSETL */
++#define	R367_OFDM_TSDLYSETL		0xF294
++#define	F367_OFDM_SOFFIFO_SYMBOFFSET_LO		0xF29400FF
++
++/* TSOBSCFG */
++#define	R367_OFDM_TSOBSCFG		0xF295
++#define	F367_OFDM_TSFIFO_OBSCFG		0xF29500FF
++
++/* TSOBSM */
++#define	R367_OFDM_TSOBSM		0xF296
++#define	F367_OFDM_TSFIFO_OBSDATA_HI		0xF29600FF
++
++/* TSOBSL */
++#define	R367_OFDM_TSOBSL		0xF297
++#define	F367_OFDM_TSFIFO_OBSDATA_LO		0xF29700FF
++
++/* ERRCTRL1 */
++#define	R367_OFDM_ERRCTRL1		0xF298
++#define	F367_OFDM_ERR_SRC1		0xF29800F0
++#define	F367_OFDM_ERRCTRL1_3		0xF2980008
++#define	F367_OFDM_NUM_EVT1		0xF2980007
++
++/* ERRCNT1H */
++#define	R367_OFDM_ERRCNT1H		0xF299
++#define	F367_OFDM_ERRCNT1_OLDVALUE		0xF2990080
++#define	F367_OFDM_ERR_CNT1		0xF299007F
++
++/* ERRCNT1M */
++#define	R367_OFDM_ERRCNT1M		0xF29A
++#define	F367_OFDM_ERR_CNT1_HI		0xF29A00FF
++
++/* ERRCNT1L */
++#define	R367_OFDM_ERRCNT1L		0xF29B
++#define	F367_OFDM_ERR_CNT1_LO		0xF29B00FF
++
++/* ERRCTRL2 */
++#define	R367_OFDM_ERRCTRL2		0xF29C
++#define	F367_OFDM_ERR_SRC2		0xF29C00F0
++#define	F367_OFDM_ERRCTRL2_3		0xF29C0008
++#define	F367_OFDM_NUM_EVT2		0xF29C0007
++
++/* ERRCNT2H */
++#define	R367_OFDM_ERRCNT2H		0xF29D
++#define	F367_OFDM_ERRCNT2_OLDVALUE		0xF29D0080
++#define	F367_OFDM_ERR_CNT2_HI		0xF29D007F
++
++/* ERRCNT2M */
++#define	R367_OFDM_ERRCNT2M		0xF29E
++#define	F367_OFDM_ERR_CNT2_MED		0xF29E00FF
++
++/* ERRCNT2L */
++#define	R367_OFDM_ERRCNT2L		0xF29F
++#define	F367_OFDM_ERR_CNT2_LO		0xF29F00FF
++
++/* FECSPY */
++#define	R367_OFDM_FECSPY		0xF2A0
++#define	F367_OFDM_SPY_ENABLE		0xF2A00080
++#define	F367_OFDM_NO_SYNCBYTE		0xF2A00040
++#define	F367_OFDM_SERIAL_MODE		0xF2A00020
++#define	F367_OFDM_UNUSUAL_PACKET		0xF2A00010
++#define	F367_OFDM_BERMETER_DATAMODE		0xF2A0000C
++#define	F367_OFDM_BERMETER_LMODE		0xF2A00002
++#define	F367_OFDM_BERMETER_RESET		0xF2A00001
++
++/* FSPYCFG */
++#define	R367_OFDM_FSPYCFG		0xF2A1
++#define	F367_OFDM_FECSPY_INPUT		0xF2A100C0
++#define	F367_OFDM_RST_ON_ERROR		0xF2A10020
++#define	F367_OFDM_ONE_SHOT		0xF2A10010
++#define	F367_OFDM_I2C_MOD		0xF2A1000C
++#define	F367_OFDM_SPY_HYSTERESIS		0xF2A10003
++
++/* FSPYDATA */
++#define	R367_OFDM_FSPYDATA		0xF2A2
++#define	F367_OFDM_SPY_STUFFING		0xF2A20080
++#define	F367_OFDM_NOERROR_PKTJITTER		0xF2A20040
++#define	F367_OFDM_SPY_CNULLPKT		0xF2A20020
++#define	F367_OFDM_SPY_OUTDATA_MODE		0xF2A2001F
++
++/* FSPYOUT */
++#define	R367_OFDM_FSPYOUT		0xF2A3
++#define	F367_OFDM_FSPY_DIRECT		0xF2A30080
++#define	F367_OFDM_FSPYOUT_6		0xF2A30040
++#define	F367_OFDM_SPY_OUTDATA_BUS		0xF2A30038
++#define	F367_OFDM_STUFF_MODE		0xF2A30007
++
++/* FSTATUS */
++#define	R367_OFDM_FSTATUS		0xF2A4
++#define	F367_OFDM_SPY_ENDSIM		0xF2A40080
++#define	F367_OFDM_VALID_SIM		0xF2A40040
++#define	F367_OFDM_FOUND_SIGNAL		0xF2A40020
++#define	F367_OFDM_DSS_SYNCBYTE		0xF2A40010
++#define	F367_OFDM_RESULT_STATE		0xF2A4000F
++
++/* FGOODPACK */
++#define	R367_OFDM_FGOODPACK		0xF2A5
++#define	F367_OFDM_FGOOD_PACKET		0xF2A500FF
++
++/* FPACKCNT */
++#define	R367_OFDM_FPACKCNT		0xF2A6
++#define	F367_OFDM_FPACKET_COUNTER		0xF2A600FF
++
++/* FSPYMISC */
++#define	R367_OFDM_FSPYMISC		0xF2A7
++#define	F367_OFDM_FLABEL_COUNTER		0xF2A700FF
++
++/* FBERCPT4 */
++#define	R367_OFDM_FBERCPT4		0xF2A8
++#define	F367_OFDM_FBERMETER_CPT5		0xF2A800FF
++
++/* FBERCPT3 */
++#define	R367_OFDM_FBERCPT3		0xF2A9
++#define	F367_OFDM_FBERMETER_CPT4		0xF2A900FF
++
++/* FBERCPT2 */
++#define	R367_OFDM_FBERCPT2		0xF2AA
++#define	F367_OFDM_FBERMETER_CPT3		0xF2AA00FF
++
++/* FBERCPT1 */
++#define	R367_OFDM_FBERCPT1		0xF2AB
++#define	F367_OFDM_FBERMETER_CPT2		0xF2AB00FF
++
++/* FBERCPT0 */
++#define	R367_OFDM_FBERCPT0		0xF2AC
++#define	F367_OFDM_FBERMETER_CPT1		0xF2AC00FF
++
++/* FBERERR2 */
++#define	R367_OFDM_FBERERR2		0xF2AD
++#define	F367_OFDM_FBERMETER_ERR_HI		0xF2AD00FF
++
++/* FBERERR1 */
++#define	R367_OFDM_FBERERR1		0xF2AE
++#define	F367_OFDM_FBERMETER_ERR_MED		0xF2AE00FF
++
++/* FBERERR0 */
++#define	R367_OFDM_FBERERR0		0xF2AF
++#define	F367_OFDM_FBERMETER_ERR_LO		0xF2AF00FF
++
++/* FSTATESM */
++#define	R367_OFDM_FSTATESM		0xF2B0
++#define	F367_OFDM_RSTATE_F		0xF2B00080
++#define	F367_OFDM_RSTATE_E		0xF2B00040
++#define	F367_OFDM_RSTATE_D		0xF2B00020
++#define	F367_OFDM_RSTATE_C		0xF2B00010
++#define	F367_OFDM_RSTATE_B		0xF2B00008
++#define	F367_OFDM_RSTATE_A		0xF2B00004
++#define	F367_OFDM_RSTATE_9		0xF2B00002
++#define	F367_OFDM_RSTATE_8		0xF2B00001
++
++/* FSTATESL */
++#define	R367_OFDM_FSTATESL		0xF2B1
++#define	F367_OFDM_RSTATE_7		0xF2B10080
++#define	F367_OFDM_RSTATE_6		0xF2B10040
++#define	F367_OFDM_RSTATE_5		0xF2B10020
++#define	F367_OFDM_RSTATE_4		0xF2B10010
++#define	F367_OFDM_RSTATE_3		0xF2B10008
++#define	F367_OFDM_RSTATE_2		0xF2B10004
++#define	F367_OFDM_RSTATE_1		0xF2B10002
++#define	F367_OFDM_RSTATE_0		0xF2B10001
++
++/* FSPYBER */
++#define	R367_OFDM_FSPYBER		0xF2B2
++#define	F367_OFDM_FSPYBER_7		0xF2B20080
++#define	F367_OFDM_FSPYOBS_XORREAD		0xF2B20040
++#define	F367_OFDM_FSPYBER_OBSMODE		0xF2B20020
++#define	F367_OFDM_FSPYBER_SYNCBYTE		0xF2B20010
++#define	F367_OFDM_FSPYBER_UNSYNC		0xF2B20008
++#define	F367_OFDM_FSPYBER_CTIME		0xF2B20007
++
++/* FSPYDISTM */
++#define	R367_OFDM_FSPYDISTM		0xF2B3
++#define	F367_OFDM_PKTTIME_DISTANCE_HI		0xF2B300FF
++
++/* FSPYDISTL */
++#define	R367_OFDM_FSPYDISTL		0xF2B4
++#define	F367_OFDM_PKTTIME_DISTANCE_LO		0xF2B400FF
++
++/* FSPYOBS7 */
++#define	R367_OFDM_FSPYOBS7		0xF2B8
++#define	F367_OFDM_FSPYOBS_SPYFAIL		0xF2B80080
++#define	F367_OFDM_FSPYOBS_SPYFAIL1		0xF2B80040
++#define	F367_OFDM_FSPYOBS_ERROR		0xF2B80020
++#define	F367_OFDM_FSPYOBS_STROUT		0xF2B80010
++#define	F367_OFDM_FSPYOBS_RESULTSTATE1		0xF2B8000F
++
++/* FSPYOBS6 */
++#define	R367_OFDM_FSPYOBS6		0xF2B9
++#define	F367_OFDM_FSPYOBS_RESULTSTATE0		0xF2B900F0
++#define	F367_OFDM_FSPYOBS_RESULTSTATEM1		0xF2B9000F
++
++/* FSPYOBS5 */
++#define	R367_OFDM_FSPYOBS5		0xF2BA
++#define	F367_OFDM_FSPYOBS_BYTEOFPACKET1		0xF2BA00FF
++
++/* FSPYOBS4 */
++#define	R367_OFDM_FSPYOBS4		0xF2BB
++#define	F367_OFDM_FSPYOBS_BYTEVALUE1		0xF2BB00FF
++
++/* FSPYOBS3 */
++#define	R367_OFDM_FSPYOBS3		0xF2BC
++#define	F367_OFDM_FSPYOBS_DATA1		0xF2BC00FF
++
++/* FSPYOBS2 */
++#define	R367_OFDM_FSPYOBS2		0xF2BD
++#define	F367_OFDM_FSPYOBS_DATA0		0xF2BD00FF
++
++/* FSPYOBS1 */
++#define	R367_OFDM_FSPYOBS1		0xF2BE
++#define	F367_OFDM_FSPYOBS_DATAM1		0xF2BE00FF
++
++/* FSPYOBS0 */
++#define	R367_OFDM_FSPYOBS0		0xF2BF
++#define	F367_OFDM_FSPYOBS_DATAM2		0xF2BF00FF
++
++/* SFDEMAP */
++#define	R367_OFDM_SFDEMAP		0xF2C0
++#define	F367_OFDM_SFDEMAP_7		0xF2C00080
++#define	F367_OFDM_SFEC_K_DIVIDER_VIT		0xF2C0007F
++
++/* SFERROR */
++#define	R367_OFDM_SFERROR		0xF2C1
++#define	F367_OFDM_SFEC_REGERR_VIT		0xF2C100FF
++
++/* SFAVSR */
++#define	R367_OFDM_SFAVSR		0xF2C2
++#define	F367_OFDM_SFEC_SUMERRORS		0xF2C20080
++#define	F367_OFDM_SERROR_MAXMODE		0xF2C20040
++#define	F367_OFDM_SN_SFEC		0xF2C20030
++#define	F367_OFDM_KDIV_MODE_SFEC		0xF2C2000C
++#define	F367_OFDM_SFAVSR_1		0xF2C20002
++#define	F367_OFDM_SFAVSR_0		0xF2C20001
++
++/* SFECSTATUS */
++#define	R367_OFDM_SFECSTATUS		0xF2C3
++#define	F367_OFDM_SFEC_ON		0xF2C30080
++#define	F367_OFDM_SFSTATUS_6		0xF2C30040
++#define	F367_OFDM_SFSTATUS_5		0xF2C30020
++#define	F367_OFDM_SFSTATUS_4		0xF2C30010
++#define	F367_OFDM_LOCKEDSFEC		0xF2C30008
++#define	F367_OFDM_SFEC_DELOCK		0xF2C30004
++#define	F367_OFDM_SFEC_DEMODSEL1		0xF2C30002
++#define	F367_OFDM_SFEC_OVFON		0xF2C30001
++
++/* SFKDIV12 */
++#define	R367_OFDM_SFKDIV12		0xF2C4
++#define	F367_OFDM_SFECKDIV12_MAN		0xF2C40080
++#define	F367_OFDM_SFEC_K_DIVIDER_12		0xF2C4007F
++
++/* SFKDIV23 */
++#define	R367_OFDM_SFKDIV23		0xF2C5
++#define	F367_OFDM_SFECKDIV23_MAN		0xF2C50080
++#define	F367_OFDM_SFEC_K_DIVIDER_23		0xF2C5007F
++
++/* SFKDIV34 */
++#define	R367_OFDM_SFKDIV34		0xF2C6
++#define	F367_OFDM_SFECKDIV34_MAN		0xF2C60080
++#define	F367_OFDM_SFEC_K_DIVIDER_34		0xF2C6007F
++
++/* SFKDIV56 */
++#define	R367_OFDM_SFKDIV56		0xF2C7
++#define	F367_OFDM_SFECKDIV56_MAN		0xF2C70080
++#define	F367_OFDM_SFEC_K_DIVIDER_56		0xF2C7007F
++
++/* SFKDIV67 */
++#define	R367_OFDM_SFKDIV67		0xF2C8
++#define	F367_OFDM_SFECKDIV67_MAN		0xF2C80080
++#define	F367_OFDM_SFEC_K_DIVIDER_67		0xF2C8007F
++
++/* SFKDIV78 */
++#define	R367_OFDM_SFKDIV78		0xF2C9
++#define	F367_OFDM_SFECKDIV78_MAN		0xF2C90080
++#define	F367_OFDM_SFEC_K_DIVIDER_78		0xF2C9007F
++
++/* SFDILSTKM */
++#define	R367_OFDM_SFDILSTKM		0xF2CA
++#define	F367_OFDM_SFEC_PACKCPT		0xF2CA00E0
++#define	F367_OFDM_SFEC_DILSTK_HI		0xF2CA001F
++
++/* SFDILSTKL */
++#define	R367_OFDM_SFDILSTKL		0xF2CB
++#define	F367_OFDM_SFEC_DILSTK_LO		0xF2CB00FF
++
++/* SFSTATUS */
++#define	R367_OFDM_SFSTATUS		0xF2CC
++#define	F367_OFDM_SFEC_LINEOK		0xF2CC0080
++#define	F367_OFDM_SFEC_ERROR		0xF2CC0040
++#define	F367_OFDM_SFEC_DATA7		0xF2CC0020
++#define	F367_OFDM_SFEC_OVERFLOW		0xF2CC0010
++#define	F367_OFDM_SFEC_DEMODSEL2		0xF2CC0008
++#define	F367_OFDM_SFEC_NOSYNC		0xF2CC0004
++#define	F367_OFDM_SFEC_UNREGULA		0xF2CC0002
++#define	F367_OFDM_SFEC_READY		0xF2CC0001
++
++/* SFDLYH */
++#define	R367_OFDM_SFDLYH		0xF2CD
++#define	F367_OFDM_SFEC_TSTIMEVALID		0xF2CD0080
++#define	F367_OFDM_SFEC_SPEEDUP		0xF2CD0040
++#define	F367_OFDM_SFEC_STOP		0xF2CD0020
++#define	F367_OFDM_SFEC_REGULATED		0xF2CD0010
++#define	F367_OFDM_SFEC_REALSYMBOFFSET		0xF2CD000F
++
++/* SFDLYM */
++#define	R367_OFDM_SFDLYM		0xF2CE
++#define	F367_OFDM_SFEC_REALSYMBOFFSET_HI		0xF2CE00FF
++
++/* SFDLYL */
++#define	R367_OFDM_SFDLYL		0xF2CF
++#define	F367_OFDM_SFEC_REALSYMBOFFSET_LO		0xF2CF00FF
++
++/* SFDLYSETH */
++#define	R367_OFDM_SFDLYSETH		0xF2D0
++#define	F367_OFDM_SFEC_OFFSET		0xF2D000E0
++#define	F367_OFDM_SFECDLYSETH_4		0xF2D00010
++#define	F367_OFDM_RST_SFEC		0xF2D00008
++#define	F367_OFDM_SFECDLYSETH_2		0xF2D00004
++#define	F367_OFDM_SFEC_DISABLE		0xF2D00002
++#define	F367_OFDM_SFEC_UNREGUL		0xF2D00001
++
++/* SFDLYSETM */
++#define	R367_OFDM_SFDLYSETM		0xF2D1
++#define	F367_OFDM_SFECDLYSETM_7		0xF2D10080
++#define	F367_OFDM_SFEC_SYMBOFFSET_HI		0xF2D1007F
++
++/* SFDLYSETL */
++#define	R367_OFDM_SFDLYSETL		0xF2D2
++#define	F367_OFDM_SFEC_SYMBOFFSET_LO		0xF2D200FF
++
++/* SFOBSCFG */
++#define	R367_OFDM_SFOBSCFG		0xF2D3
++#define	F367_OFDM_SFEC_OBSCFG		0xF2D300FF
++
++/* SFOBSM */
++#define	R367_OFDM_SFOBSM		0xF2D4
++#define	F367_OFDM_SFEC_OBSDATA_HI		0xF2D400FF
++
++/* SFOBSL */
++#define	R367_OFDM_SFOBSL		0xF2D5
++#define	F367_OFDM_SFEC_OBSDATA_LO		0xF2D500FF
++
++/* SFECINFO */
++#define	R367_OFDM_SFECINFO		0xF2D6
++#define	F367_OFDM_SFECINFO_7		0xF2D60080
++#define	F367_OFDM_SFEC_SYNCDLSB		0xF2D60070
++#define	F367_OFDM_SFCE_S1CPHASE		0xF2D6000F
++
++/* SFERRCTRL */
++#define	R367_OFDM_SFERRCTRL		0xF2D8
++#define	F367_OFDM_SFEC_ERR_SOURCE		0xF2D800F0
++#define	F367_OFDM_SFERRCTRL_3		0xF2D80008
++#define	F367_OFDM_SFEC_NUM_EVENT		0xF2D80007
++
++/* SFERRCNTH */
++#define	R367_OFDM_SFERRCNTH		0xF2D9
++#define	F367_OFDM_SFERRC_OLDVALUE		0xF2D90080
++#define	F367_OFDM_SFEC_ERR_CNT		0xF2D9007F
++
++/* SFERRCNTM */
++#define	R367_OFDM_SFERRCNTM		0xF2DA
++#define	F367_OFDM_SFEC_ERR_CNT_HI		0xF2DA00FF
++
++/* SFERRCNTL */
++#define	R367_OFDM_SFERRCNTL		0xF2DB
++#define	F367_OFDM_SFEC_ERR_CNT_LO		0xF2DB00FF
++
++/* SYMBRATEM */
++#define	R367_OFDM_SYMBRATEM		0xF2E0
++#define	F367_OFDM_DEFGEN_SYMBRATE_HI		0xF2E000FF
++
++/* SYMBRATEL */
++#define	R367_OFDM_SYMBRATEL		0xF2E1
++#define	F367_OFDM_DEFGEN_SYMBRATE_LO		0xF2E100FF
++
++/* SYMBSTATUS */
++#define	R367_OFDM_SYMBSTATUS		0xF2E2
++#define	F367_OFDM_SYMBDLINE2_OFF		0xF2E20080
++#define	F367_OFDM_SDDL_REINIT1		0xF2E20040
++#define	F367_OFDM_SDD_REINIT1		0xF2E20020
++#define	F367_OFDM_TOKENID_ERROR		0xF2E20010
++#define	F367_OFDM_SYMBRATE_OVERFLOW		0xF2E20008
++#define	F367_OFDM_SYMBRATE_UNDERFLOW		0xF2E20004
++#define	F367_OFDM_TOKENID_RSTEVENT		0xF2E20002
++#define	F367_OFDM_TOKENID_RESET1		0xF2E20001
++
++/* SYMBCFG */
++#define	R367_OFDM_SYMBCFG		0xF2E3
++#define	F367_OFDM_SYMBCFG_7		0xF2E30080
++#define	F367_OFDM_SYMBCFG_6		0xF2E30040
++#define	F367_OFDM_SYMBCFG_5		0xF2E30020
++#define	F367_OFDM_SYMBCFG_4		0xF2E30010
++#define	F367_OFDM_SYMRATE_FSPEED		0xF2E3000C
++#define	F367_OFDM_SYMRATE_SSPEED		0xF2E30003
++
++/* SYMBFIFOM */
++#define	R367_OFDM_SYMBFIFOM		0xF2E4
++#define	F367_OFDM_SYMBFIFOM_7		0xF2E40080
++#define	F367_OFDM_SYMBFIFOM_6		0xF2E40040
++#define	F367_OFDM_DEFGEN_SYMFIFO_HI		0xF2E4003F
++
++/* SYMBFIFOL */
++#define	R367_OFDM_SYMBFIFOL		0xF2E5
++#define	F367_OFDM_DEFGEN_SYMFIFO_LO		0xF2E500FF
++
++/* SYMBOFFSM */
++#define	R367_OFDM_SYMBOFFSM		0xF2E6
++#define	F367_OFDM_TOKENID_RESET2		0xF2E60080
++#define	F367_OFDM_SDDL_REINIT2		0xF2E60040
++#define	F367_OFDM_SDD_REINIT2		0xF2E60020
++#define	F367_OFDM_SYMBOFFSM_4		0xF2E60010
++#define	F367_OFDM_SYMBOFFSM_3		0xF2E60008
++#define	F367_OFDM_DEFGEN_SYMBOFFSET_HI		0xF2E60007
++
++/* SYMBOFFSL */
++#define	R367_OFDM_SYMBOFFSL		0xF2E7
++#define	F367_OFDM_DEFGEN_SYMBOFFSET_LO		0xF2E700FF
++
++/* DEBUG_LT4 */
++#define	R367_DEBUG_LT4		0xF400
++#define	F367_F_DEBUG_LT4		0xF40000FF
++
++/* DEBUG_LT5 */
++#define	R367_DEBUG_LT5		0xF401
++#define	F367_F_DEBUG_LT5		0xF40100FF
++
++/* DEBUG_LT6 */
++#define	R367_DEBUG_LT6		0xF402
++#define	F367_F_DEBUG_LT6		0xF40200FF
++
++/* DEBUG_LT7 */
++#define	R367_DEBUG_LT7		0xF403
++#define	F367_F_DEBUG_LT7		0xF40300FF
++
++/* DEBUG_LT8 */
++#define	R367_DEBUG_LT8		0xF404
++#define	F367_F_DEBUG_LT8		0xF40400FF
++
++/* DEBUG_LT9 */
++#define	R367_DEBUG_LT9		0xF405
++#define	F367_F_DEBUG_LT9		0xF40500FF
++
++/* CTRL_1 */
++#define	R367_QAM_CTRL_1		0xF402
++#define	F367_QAM_SOFT_RST		0xF4020080
++#define	F367_QAM_EQU_RST		0xF4020008
++#define	F367_QAM_CRL_RST		0xF4020004
++#define	F367_QAM_TRL_RST		0xF4020002
++#define	F367_QAM_AGC_RST		0xF4020001
++
++/* CTRL_2 */
++#define	R367_QAM_CTRL_2		0xF403
++#define	F367_QAM_DEINT_RST		0xF4030008
++#define	F367_QAM_RS_RST		0xF4030004
++
++/* IT_STATUS1 */
++#define	R367_QAM_IT_STATUS1		0xF408
++#define	F367_QAM_SWEEP_OUT		0xF4080080
++#define	F367_QAM_FSM_CRL		0xF4080040
++#define	F367_QAM_CRL_LOCK		0xF4080020
++#define	F367_QAM_MFSM		0xF4080010
++#define	F367_QAM_TRL_LOCK		0xF4080008
++#define	F367_QAM_TRL_AGC_LIMIT		0xF4080004
++#define	F367_QAM_ADJ_AGC_LOCK		0xF4080002
++#define	F367_QAM_AGC_QAM_LOCK		0xF4080001
++
++/* IT_STATUS2 */
++#define	R367_QAM_IT_STATUS2		0xF409
++#define	F367_QAM_TSMF_CNT		0xF4090080
++#define	F367_QAM_TSMF_EOF		0xF4090040
++#define	F367_QAM_TSMF_RDY		0xF4090020
++#define	F367_QAM_FEC_NOCORR		0xF4090010
++#define	F367_QAM_SYNCSTATE		0xF4090008
++#define	F367_QAM_DEINT_LOCK		0xF4090004
++#define	F367_QAM_FADDING_FRZ		0xF4090002
++#define	F367_QAM_TAPMON_ALARM		0xF4090001
++
++/* IT_EN1 */
++#define	R367_QAM_IT_EN1		0xF40A
++#define	F367_QAM_SWEEP_OUTE		0xF40A0080
++#define	F367_QAM_FSM_CRLE		0xF40A0040
++#define	F367_QAM_CRL_LOCKE		0xF40A0020
++#define	F367_QAM_MFSME		0xF40A0010
++#define	F367_QAM_TRL_LOCKE		0xF40A0008
++#define	F367_QAM_TRL_AGC_LIMITE		0xF40A0004
++#define	F367_QAM_ADJ_AGC_LOCKE		0xF40A0002
++#define	F367_QAM_AGC_LOCKE		0xF40A0001
++
++/* IT_EN2 */
++#define	R367_QAM_IT_EN2		0xF40B
++#define	F367_QAM_TSMF_CNTE		0xF40B0080
++#define	F367_QAM_TSMF_EOFE		0xF40B0040
++#define	F367_QAM_TSMF_RDYE		0xF40B0020
++#define	F367_QAM_FEC_NOCORRE		0xF40B0010
++#define	F367_QAM_SYNCSTATEE		0xF40B0008
++#define	F367_QAM_DEINT_LOCKE		0xF40B0004
++#define	F367_QAM_FADDING_FRZE		0xF40B0002
++#define	F367_QAM_TAPMON_ALARME		0xF40B0001
++
++/* CTRL_STATUS */
++#define	R367_QAM_CTRL_STATUS		0xF40C
++#define	F367_QAM_QAMFEC_LOCK		0xF40C0004
++#define	F367_QAM_TSMF_LOCK		0xF40C0002
++#define	F367_QAM_TSMF_ERROR		0xF40C0001
++
++/* TEST_CTL */
++#define	R367_QAM_TEST_CTL		0xF40F
++#define	F367_QAM_TST_BLK_SEL		0xF40F0060
++#define	F367_QAM_TST_BUS_SEL		0xF40F001F
++
++/* AGC_CTL */
++#define	R367_QAM_AGC_CTL		0xF410
++#define	F367_QAM_AGC_LCK_TH		0xF41000F0
++#define	F367_QAM_AGC_ACCUMRSTSEL		0xF4100007
++
++/* AGC_IF_CFG */
++#define	R367_QAM_AGC_IF_CFG		0xF411
++#define	F367_QAM_AGC_IF_BWSEL		0xF41100F0
++#define	F367_QAM_AGC_IF_FREEZE		0xF4110002
++
++/* AGC_RF_CFG */
++#define	R367_QAM_AGC_RF_CFG		0xF412
++#define	F367_QAM_AGC_RF_BWSEL		0xF4120070
++#define	F367_QAM_AGC_RF_FREEZE		0xF4120002
++
++/* AGC_PWM_CFG */
++#define	R367_QAM_AGC_PWM_CFG		0xF413
++#define	F367_QAM_AGC_RF_PWM_TST		0xF4130080
++#define	F367_QAM_AGC_RF_PWM_INV		0xF4130040
++#define	F367_QAM_AGC_IF_PWM_TST		0xF4130008
++#define	F367_QAM_AGC_IF_PWM_INV		0xF4130004
++#define	F367_QAM_AGC_PWM_CLKDIV		0xF4130003
++
++/* AGC_PWR_REF_L */
++#define	R367_QAM_AGC_PWR_REF_L		0xF414
++#define	F367_QAM_AGC_PWRREF_LO		0xF41400FF
++
++/* AGC_PWR_REF_H */
++#define	R367_QAM_AGC_PWR_REF_H		0xF415
++#define	F367_QAM_AGC_PWRREF_HI		0xF4150003
++
++/* AGC_RF_TH_L */
++#define	R367_QAM_AGC_RF_TH_L		0xF416
++#define	F367_QAM_AGC_RF_TH_LO		0xF41600FF
++
++/* AGC_RF_TH_H */
++#define	R367_QAM_AGC_RF_TH_H		0xF417
++#define	F367_QAM_AGC_RF_TH_HI		0xF417000F
++
++/* AGC_IF_LTH_L */
++#define	R367_QAM_AGC_IF_LTH_L		0xF418
++#define	F367_QAM_AGC_IF_THLO_LO		0xF41800FF
++
++/* AGC_IF_LTH_H */
++#define	R367_QAM_AGC_IF_LTH_H		0xF419
++#define	F367_QAM_AGC_IF_THLO_HI		0xF419000F
++
++/* AGC_IF_HTH_L */
++#define	R367_QAM_AGC_IF_HTH_L		0xF41A
++#define	F367_QAM_AGC_IF_THHI_LO		0xF41A00FF
++
++/* AGC_IF_HTH_H */
++#define	R367_QAM_AGC_IF_HTH_H		0xF41B
++#define	F367_QAM_AGC_IF_THHI_HI		0xF41B000F
++
++/* AGC_PWR_RD_L */
++#define	R367_QAM_AGC_PWR_RD_L		0xF41C
++#define	F367_QAM_AGC_PWR_WORD_LO		0xF41C00FF
++
++/* AGC_PWR_RD_M */
++#define	R367_QAM_AGC_PWR_RD_M		0xF41D
++#define	F367_QAM_AGC_PWR_WORD_ME		0xF41D00FF
++
++/* AGC_PWR_RD_H */
++#define	R367_QAM_AGC_PWR_RD_H		0xF41E
++#define	F367_QAM_AGC_PWR_WORD_HI		0xF41E0003
++
++/* AGC_PWM_IFCMD_L */
++#define	R367_QAM_AGC_PWM_IFCMD_L		0xF420
++#define	F367_QAM_AGC_IF_PWMCMD_LO		0xF42000FF
++
++/* AGC_PWM_IFCMD_H */
++#define	R367_QAM_AGC_PWM_IFCMD_H		0xF421
++#define	F367_QAM_AGC_IF_PWMCMD_HI		0xF421000F
++
++/* AGC_PWM_RFCMD_L */
++#define	R367_QAM_AGC_PWM_RFCMD_L		0xF422
++#define	F367_QAM_AGC_RF_PWMCMD_LO		0xF42200FF
++
++/* AGC_PWM_RFCMD_H */
++#define	R367_QAM_AGC_PWM_RFCMD_H		0xF423
++#define	F367_QAM_AGC_RF_PWMCMD_HI		0xF423000F
++
++/* IQDEM_CFG */
++#define	R367_QAM_IQDEM_CFG		0xF424
++#define	F367_QAM_IQDEM_CLK_SEL		0xF4240004
++#define	F367_QAM_IQDEM_INVIQ		0xF4240002
++#define	F367_QAM_IQDEM_A2DTYPE		0xF4240001
++
++/* MIX_NCO_LL */
++#define	R367_QAM_MIX_NCO_LL		0xF425
++#define	F367_QAM_MIX_NCO_INC_LL		0xF42500FF
++
++/* MIX_NCO_HL */
++#define	R367_QAM_MIX_NCO_HL		0xF426
++#define	F367_QAM_MIX_NCO_INC_HL		0xF42600FF
++
++/* MIX_NCO_HH */
++#define	R367_QAM_MIX_NCO_HH		0xF427
++#define	F367_QAM_MIX_NCO_INVCNST		0xF4270080
++#define	F367_QAM_MIX_NCO_INC_HH		0xF427007F
++
++/* SRC_NCO_LL */
++#define	R367_QAM_SRC_NCO_LL		0xF428
++#define	F367_QAM_SRC_NCO_INC_LL		0xF42800FF
++
++/* SRC_NCO_LH */
++#define	R367_QAM_SRC_NCO_LH		0xF429
++#define	F367_QAM_SRC_NCO_INC_LH		0xF42900FF
++
++/* SRC_NCO_HL */
++#define	R367_QAM_SRC_NCO_HL		0xF42A
++#define	F367_QAM_SRC_NCO_INC_HL		0xF42A00FF
++
++/* SRC_NCO_HH */
++#define	R367_QAM_SRC_NCO_HH		0xF42B
++#define	F367_QAM_SRC_NCO_INC_HH		0xF42B007F
++
++/* IQDEM_GAIN_SRC_L */
++#define	R367_QAM_IQDEM_GAIN_SRC_L		0xF42C
++#define	F367_QAM_GAIN_SRC_LO		0xF42C00FF
++
++/* IQDEM_GAIN_SRC_H */
++#define	R367_QAM_IQDEM_GAIN_SRC_H		0xF42D
++#define	F367_QAM_GAIN_SRC_HI		0xF42D0003
++
++/* IQDEM_DCRM_CFG_LL */
++#define	R367_QAM_IQDEM_DCRM_CFG_LL		0xF430
++#define	F367_QAM_DCRM0_DCIN_L		0xF43000FF
++
++/* IQDEM_DCRM_CFG_LH */
++#define	R367_QAM_IQDEM_DCRM_CFG_LH		0xF431
++#define	F367_QAM_DCRM1_I_DCIN_L		0xF43100FC
++#define	F367_QAM_DCRM0_DCIN_H		0xF4310003
++
++/* IQDEM_DCRM_CFG_HL */
++#define	R367_QAM_IQDEM_DCRM_CFG_HL		0xF432
++#define	F367_QAM_DCRM1_Q_DCIN_L		0xF43200F0
++#define	F367_QAM_DCRM1_I_DCIN_H		0xF432000F
++
++/* IQDEM_DCRM_CFG_HH */
++#define	R367_QAM_IQDEM_DCRM_CFG_HH		0xF433
++#define	F367_QAM_DCRM1_FRZ		0xF4330080
++#define	F367_QAM_DCRM0_FRZ		0xF4330040
++#define	F367_QAM_DCRM1_Q_DCIN_H		0xF433003F
++
++/* IQDEM_ADJ_COEFF0 */
++#define	R367_QAM_IQDEM_ADJ_COEFF0		0xF434
++#define	F367_QAM_ADJIIR_COEFF10_L		0xF43400FF
++
++/* IQDEM_ADJ_COEFF1 */
++#define	R367_QAM_IQDEM_ADJ_COEFF1		0xF435
++#define	F367_QAM_ADJIIR_COEFF11_L		0xF43500FC
++#define	F367_QAM_ADJIIR_COEFF10_H		0xF4350003
++
++/* IQDEM_ADJ_COEFF2 */
++#define	R367_QAM_IQDEM_ADJ_COEFF2		0xF436
++#define	F367_QAM_ADJIIR_COEFF12_L		0xF43600F0
++#define	F367_QAM_ADJIIR_COEFF11_H		0xF436000F
++
++/* IQDEM_ADJ_COEFF3 */
++#define	R367_QAM_IQDEM_ADJ_COEFF3		0xF437
++#define	F367_QAM_ADJIIR_COEFF20_L		0xF43700C0
++#define	F367_QAM_ADJIIR_COEFF12_H		0xF437003F
++
++/* IQDEM_ADJ_COEFF4 */
++#define	R367_QAM_IQDEM_ADJ_COEFF4		0xF438
++#define	F367_QAM_ADJIIR_COEFF20_H		0xF43800FF
++
++/* IQDEM_ADJ_COEFF5 */
++#define	R367_QAM_IQDEM_ADJ_COEFF5		0xF439
++#define	F367_QAM_ADJIIR_COEFF21_L		0xF43900FF
++
++/* IQDEM_ADJ_COEFF6 */
++#define	R367_QAM_IQDEM_ADJ_COEFF6		0xF43A
++#define	F367_QAM_ADJIIR_COEFF22_L		0xF43A00FC
++#define	F367_QAM_ADJIIR_COEFF21_H		0xF43A0003
++
++/* IQDEM_ADJ_COEFF7 */
++#define	R367_QAM_IQDEM_ADJ_COEFF7		0xF43B
++#define	F367_QAM_ADJIIR_COEFF22_H		0xF43B000F
++
++/* IQDEM_ADJ_EN */
++#define	R367_QAM_IQDEM_ADJ_EN		0xF43C
++#define	F367_QAM_ALLPASSFILT_EN		0xF43C0008
++#define	F367_QAM_ADJ_AGC_EN		0xF43C0004
++#define	F367_QAM_ADJ_COEFF_FRZ		0xF43C0002
++#define	F367_QAM_ADJ_EN		0xF43C0001
++
++/* IQDEM_ADJ_AGC_REF */
++#define	R367_QAM_IQDEM_ADJ_AGC_REF		0xF43D
++#define	F367_QAM_ADJ_AGC_REF		0xF43D00FF
++
++/* ALLPASSFILT1 */
++#define	R367_QAM_ALLPASSFILT1		0xF440
++#define	F367_QAM_ALLPASSFILT_COEFF1_LO		0xF44000FF
++
++/* ALLPASSFILT2 */
++#define	R367_QAM_ALLPASSFILT2		0xF441
++#define	F367_QAM_ALLPASSFILT_COEFF1_ME		0xF44100FF
++
++/* ALLPASSFILT3 */
++#define	R367_QAM_ALLPASSFILT3		0xF442
++#define	F367_QAM_ALLPASSFILT_COEFF2_LO		0xF44200C0
++#define	F367_QAM_ALLPASSFILT_COEFF1_HI		0xF442003F
++
++/* ALLPASSFILT4 */
++#define	R367_QAM_ALLPASSFILT4		0xF443
++#define	F367_QAM_ALLPASSFILT_COEFF2_MEL		0xF44300FF
++
++/* ALLPASSFILT5 */
++#define	R367_QAM_ALLPASSFILT5		0xF444
++#define	F367_QAM_ALLPASSFILT_COEFF2_MEH		0xF44400FF
++
++/* ALLPASSFILT6 */
++#define	R367_QAM_ALLPASSFILT6		0xF445
++#define	F367_QAM_ALLPASSFILT_COEFF3_LO		0xF44500F0
++#define	F367_QAM_ALLPASSFILT_COEFF2_HI		0xF445000F
++
++/* ALLPASSFILT7 */
++#define	R367_QAM_ALLPASSFILT7		0xF446
++#define	F367_QAM_ALLPASSFILT_COEFF3_MEL		0xF44600FF
++
++/* ALLPASSFILT8 */
++#define	R367_QAM_ALLPASSFILT8		0xF447
++#define	F367_QAM_ALLPASSFILT_COEFF3_MEH		0xF44700FF
++
++/* ALLPASSFILT9 */
++#define	R367_QAM_ALLPASSFILT9		0xF448
++#define	F367_QAM_ALLPASSFILT_COEFF4_LO		0xF44800FC
++#define	F367_QAM_ALLPASSFILT_COEFF3_HI		0xF4480003
++
++/* ALLPASSFILT10 */
++#define	R367_QAM_ALLPASSFILT10		0xF449
++#define	F367_QAM_ALLPASSFILT_COEFF4_ME		0xF44900FF
++
++/* ALLPASSFILT11 */
++#define	R367_QAM_ALLPASSFILT11		0xF44A
++#define	F367_QAM_ALLPASSFILT_COEFF4_HI		0xF44A00FF
++
++/* TRL_AGC_CFG */
++#define	R367_QAM_TRL_AGC_CFG		0xF450
++#define	F367_QAM_TRL_AGC_FREEZE		0xF4500080
++#define	F367_QAM_TRL_AGC_REF		0xF450007F
++
++/* TRL_LPF_CFG */
++#define	R367_QAM_TRL_LPF_CFG		0xF454
++#define	F367_QAM_NYQPOINT_INV		0xF4540040
++#define	F367_QAM_TRL_SHIFT		0xF4540030
++#define	F367_QAM_NYQ_COEFF_SEL		0xF454000C
++#define	F367_QAM_TRL_LPF_FREEZE		0xF4540002
++#define	F367_QAM_TRL_LPF_CRT		0xF4540001
++
++/* TRL_LPF_ACQ_GAIN */
++#define	R367_QAM_TRL_LPF_ACQ_GAIN		0xF455
++#define	F367_QAM_TRL_GDIR_ACQ		0xF4550070
++#define	F367_QAM_TRL_GINT_ACQ		0xF4550007
++
++/* TRL_LPF_TRK_GAIN */
++#define	R367_QAM_TRL_LPF_TRK_GAIN		0xF456
++#define	F367_QAM_TRL_GDIR_TRK		0xF4560070
++#define	F367_QAM_TRL_GINT_TRK		0xF4560007
++
++/* TRL_LPF_OUT_GAIN */
++#define	R367_QAM_TRL_LPF_OUT_GAIN		0xF457
++#define	F367_QAM_TRL_GAIN_OUT		0xF4570007
++
++/* TRL_LOCKDET_LTH */
++#define	R367_QAM_TRL_LOCKDET_LTH		0xF458
++#define	F367_QAM_TRL_LCK_THLO		0xF4580007
++
++/* TRL_LOCKDET_HTH */
++#define	R367_QAM_TRL_LOCKDET_HTH		0xF459
++#define	F367_QAM_TRL_LCK_THHI		0xF45900FF
++
++/* TRL_LOCKDET_TRGVAL */
++#define	R367_QAM_TRL_LOCKDET_TRGVAL		0xF45A
++#define	F367_QAM_TRL_LCK_TRG		0xF45A00FF
++
++/* IQ_QAM */
++#define	R367_QAM_IQ_QAM		0xF45C
++#define	F367_QAM_IQ_INPUT		0xF45C0008
++#define	F367_QAM_DETECT_MODE		0xF45C0007
++
++/* FSM_STATE */
++#define	R367_QAM_FSM_STATE		0xF460
++#define	F367_QAM_CRL_DFE		0xF4600080
++#define	F367_QAM_DFE_START		0xF4600040
++#define	F367_QAM_CTRLG_START		0xF4600030
++#define	F367_QAM_FSM_FORCESTATE		0xF460000F
++
++/* FSM_CTL */
++#define	R367_QAM_FSM_CTL		0xF461
++#define	F367_QAM_FEC2_EN		0xF4610040
++#define	F367_QAM_SIT_EN		0xF4610020
++#define	F367_QAM_TRL_AHEAD		0xF4610010
++#define	F367_QAM_TRL2_EN		0xF4610008
++#define	F367_QAM_FSM_EQA1_EN		0xF4610004
++#define	F367_QAM_FSM_BKP_DIS		0xF4610002
++#define	F367_QAM_FSM_FORCE_EN		0xF4610001
++
++/* FSM_STS */
++#define	R367_QAM_FSM_STS		0xF462
++#define	F367_QAM_FSM_STATUS		0xF462000F
++
++/* FSM_SNR0_HTH */
++#define	R367_QAM_FSM_SNR0_HTH		0xF463
++#define	F367_QAM_SNR0_HTH		0xF46300FF
++
++/* FSM_SNR1_HTH */
++#define	R367_QAM_FSM_SNR1_HTH		0xF464
++#define	F367_QAM_SNR1_HTH		0xF46400FF
++
++/* FSM_SNR2_HTH */
++#define	R367_QAM_FSM_SNR2_HTH		0xF465
++#define	F367_QAM_SNR2_HTH		0xF46500FF
++
++/* FSM_SNR0_LTH */
++#define	R367_QAM_FSM_SNR0_LTH		0xF466
++#define	F367_QAM_SNR0_LTH		0xF46600FF
++
++/* FSM_SNR1_LTH */
++#define	R367_QAM_FSM_SNR1_LTH		0xF467
++#define	F367_QAM_SNR1_LTH		0xF46700FF
++
++/* FSM_EQA1_HTH */
++#define	R367_QAM_FSM_EQA1_HTH		0xF468
++#define	F367_QAM_SNR3_HTH_LO		0xF46800F0
++#define	F367_QAM_EQA1_HTH		0xF468000F
++
++/* FSM_TEMPO */
++#define	R367_QAM_FSM_TEMPO		0xF469
++#define	F367_QAM_SIT		0xF46900C0
++#define	F367_QAM_WST		0xF4690038
++#define	F367_QAM_ELT		0xF4690006
++#define	F367_QAM_SNR3_HTH_HI		0xF4690001
++
++/* FSM_CONFIG */
++#define	R367_QAM_FSM_CONFIG		0xF46A
++#define	F367_QAM_FEC2_DFEOFF		0xF46A0004
++#define	F367_QAM_PRIT_STATE		0xF46A0002
++#define	F367_QAM_MODMAP_STATE		0xF46A0001
++
++/* EQU_I_TESTTAP_L */
++#define	R367_QAM_EQU_I_TESTTAP_L		0xF474
++#define	F367_QAM_I_TEST_TAP_L		0xF47400FF
++
++/* EQU_I_TESTTAP_M */
++#define	R367_QAM_EQU_I_TESTTAP_M		0xF475
++#define	F367_QAM_I_TEST_TAP_M		0xF47500FF
++
++/* EQU_I_TESTTAP_H */
++#define	R367_QAM_EQU_I_TESTTAP_H		0xF476
++#define	F367_QAM_I_TEST_TAP_H		0xF476001F
++
++/* EQU_TESTAP_CFG */
++#define	R367_QAM_EQU_TESTAP_CFG		0xF477
++#define	F367_QAM_TEST_FFE_DFE_SEL		0xF4770040
++#define	F367_QAM_TEST_TAP_SELECT		0xF477003F
++
++/* EQU_Q_TESTTAP_L */
++#define	R367_QAM_EQU_Q_TESTTAP_L		0xF478
++#define	F367_QAM_Q_TEST_TAP_L		0xF47800FF
++
++/* EQU_Q_TESTTAP_M */
++#define	R367_QAM_EQU_Q_TESTTAP_M		0xF479
++#define	F367_QAM_Q_TEST_TAP_M		0xF47900FF
++
++/* EQU_Q_TESTTAP_H */
++#define	R367_QAM_EQU_Q_TESTTAP_H		0xF47A
++#define	F367_QAM_Q_TEST_TAP_H		0xF47A001F
++
++/* EQU_TAP_CTRL */
++#define	R367_QAM_EQU_TAP_CTRL		0xF47B
++#define	F367_QAM_MTAP_FRZ		0xF47B0010
++#define	F367_QAM_PRE_FREEZE		0xF47B0008
++#define	F367_QAM_DFE_TAPMON_EN		0xF47B0004
++#define	F367_QAM_FFE_TAPMON_EN		0xF47B0002
++#define	F367_QAM_MTAP_ONLY		0xF47B0001
++
++/* EQU_CTR_CRL_CONTROL_L */
++#define	R367_QAM_EQU_CTR_CRL_CONTROL_L		0xF47C
++#define	F367_QAM_EQU_CTR_CRL_CONTROL_LO		0xF47C00FF
++
++/* EQU_CTR_CRL_CONTROL_H */
++#define	R367_QAM_EQU_CTR_CRL_CONTROL_H		0xF47D
++#define	F367_QAM_EQU_CTR_CRL_CONTROL_HI		0xF47D00FF
++
++/* EQU_CTR_HIPOW_L */
++#define	R367_QAM_EQU_CTR_HIPOW_L		0xF47E
++#define	F367_QAM_CTR_HIPOW_L		0xF47E00FF
++
++/* EQU_CTR_HIPOW_H */
++#define	R367_QAM_EQU_CTR_HIPOW_H		0xF47F
++#define	F367_QAM_CTR_HIPOW_H		0xF47F00FF
++
++/* EQU_I_EQU_LO */
++#define	R367_QAM_EQU_I_EQU_LO		0xF480
++#define	F367_QAM_EQU_I_EQU_L		0xF48000FF
++
++/* EQU_I_EQU_HI */
++#define	R367_QAM_EQU_I_EQU_HI		0xF481
++#define	F367_QAM_EQU_I_EQU_H		0xF4810003
++
++/* EQU_Q_EQU_LO */
++#define	R367_QAM_EQU_Q_EQU_LO		0xF482
++#define	F367_QAM_EQU_Q_EQU_L		0xF48200FF
++
++/* EQU_Q_EQU_HI */
++#define	R367_QAM_EQU_Q_EQU_HI		0xF483
++#define	F367_QAM_EQU_Q_EQU_H		0xF4830003
++
++/* EQU_MAPPER */
++#define	R367_QAM_EQU_MAPPER		0xF484
++#define	F367_QAM_QUAD_AUTO		0xF4840080
++#define	F367_QAM_QUAD_INV		0xF4840040
++#define	F367_QAM_QAM_MODE		0xF4840007
++
++/* EQU_SWEEP_RATE */
++#define	R367_QAM_EQU_SWEEP_RATE		0xF485
++#define	F367_QAM_SNR_PER		0xF48500C0
++#define	F367_QAM_SWEEP_RATE		0xF485003F
++
++/* EQU_SNR_LO */
++#define	R367_QAM_EQU_SNR_LO		0xF486
++#define	F367_QAM_SNR_LO		0xF48600FF
++
++/* EQU_SNR_HI */
++#define	R367_QAM_EQU_SNR_HI		0xF487
++#define	F367_QAM_SNR_HI		0xF48700FF
++
++/* EQU_GAMMA_LO */
++#define	R367_QAM_EQU_GAMMA_LO		0xF488
++#define	F367_QAM_GAMMA_LO		0xF48800FF
++
++/* EQU_GAMMA_HI */
++#define	R367_QAM_EQU_GAMMA_HI		0xF489
++#define	F367_QAM_GAMMA_ME		0xF48900FF
++
++/* EQU_ERR_GAIN */
++#define	R367_QAM_EQU_ERR_GAIN		0xF48A
++#define	F367_QAM_EQA1MU		0xF48A0070
++#define	F367_QAM_CRL2MU		0xF48A000E
++#define	F367_QAM_GAMMA_HI		0xF48A0001
++
++/* EQU_RADIUS */
++#define	R367_QAM_EQU_RADIUS		0xF48B
++#define	F367_QAM_RADIUS		0xF48B00FF
++
++/* EQU_FFE_MAINTAP */
++#define	R367_QAM_EQU_FFE_MAINTAP		0xF48C
++#define	F367_QAM_FFE_MAINTAP_INIT		0xF48C00FF
++
++/* EQU_FFE_LEAKAGE */
++#define	R367_QAM_EQU_FFE_LEAKAGE		0xF48E
++#define	F367_QAM_LEAK_PER		0xF48E00F0
++#define	F367_QAM_EQU_OUTSEL		0xF48E0002
++#define	F367_QAM_PNT2DFE		0xF48E0001
++
++/* EQU_FFE_MAINTAP_POS */
++#define	R367_QAM_EQU_FFE_MAINTAP_POS		0xF48F
++#define	F367_QAM_FFE_LEAK_EN		0xF48F0080
++#define	F367_QAM_DFE_LEAK_EN		0xF48F0040
++#define	F367_QAM_FFE_MAINTAP_POS		0xF48F003F
++
++/* EQU_GAIN_WIDE */
++#define	R367_QAM_EQU_GAIN_WIDE		0xF490
++#define	F367_QAM_DFE_GAIN_WIDE		0xF49000F0
++#define	F367_QAM_FFE_GAIN_WIDE		0xF490000F
++
++/* EQU_GAIN_NARROW */
++#define	R367_QAM_EQU_GAIN_NARROW		0xF491
++#define	F367_QAM_DFE_GAIN_NARROW		0xF49100F0
++#define	F367_QAM_FFE_GAIN_NARROW		0xF491000F
++
++/* EQU_CTR_LPF_GAIN */
++#define	R367_QAM_EQU_CTR_LPF_GAIN		0xF492
++#define	F367_QAM_CTR_GTO		0xF4920080
++#define	F367_QAM_CTR_GDIR		0xF4920070
++#define	F367_QAM_SWEEP_EN		0xF4920008
++#define	F367_QAM_CTR_GINT		0xF4920007
++
++/* EQU_CRL_LPF_GAIN */
++#define	R367_QAM_EQU_CRL_LPF_GAIN		0xF493
++#define	F367_QAM_CRL_GTO		0xF4930080
++#define	F367_QAM_CRL_GDIR		0xF4930070
++#define	F367_QAM_SWEEP_DIR		0xF4930008
++#define	F367_QAM_CRL_GINT		0xF4930007
++
++/* EQU_GLOBAL_GAIN */
++#define	R367_QAM_EQU_GLOBAL_GAIN		0xF494
++#define	F367_QAM_CRL_GAIN		0xF49400F8
++#define	F367_QAM_CTR_INC_GAIN		0xF4940004
++#define	F367_QAM_CTR_FRAC		0xF4940003
++
++/* EQU_CRL_LD_SEN */
++#define	R367_QAM_EQU_CRL_LD_SEN		0xF495
++#define	F367_QAM_CTR_BADPOINT_EN		0xF4950080
++#define	F367_QAM_CTR_GAIN		0xF4950070
++#define	F367_QAM_LIMANEN		0xF4950008
++#define	F367_QAM_CRL_LD_SEN		0xF4950007
++
++/* EQU_CRL_LD_VAL */
++#define	R367_QAM_EQU_CRL_LD_VAL		0xF496
++#define	F367_QAM_CRL_BISTH_LIMIT		0xF4960080
++#define	F367_QAM_CARE_EN		0xF4960040
++#define	F367_QAM_CRL_LD_PER		0xF4960030
++#define	F367_QAM_CRL_LD_WST		0xF496000C
++#define	F367_QAM_CRL_LD_TFS		0xF4960003
++
++/* EQU_CRL_TFR */
++#define	R367_QAM_EQU_CRL_TFR		0xF497
++#define	F367_QAM_CRL_LD_TFR		0xF49700FF
++
++/* EQU_CRL_BISTH_LO */
++#define	R367_QAM_EQU_CRL_BISTH_LO		0xF498
++#define	F367_QAM_CRL_BISTH_LO		0xF49800FF
++
++/* EQU_CRL_BISTH_HI */
++#define	R367_QAM_EQU_CRL_BISTH_HI		0xF499
++#define	F367_QAM_CRL_BISTH_HI		0xF49900FF
++
++/* EQU_SWEEP_RANGE_LO */
++#define	R367_QAM_EQU_SWEEP_RANGE_LO		0xF49A
++#define	F367_QAM_SWEEP_RANGE_LO		0xF49A00FF
++
++/* EQU_SWEEP_RANGE_HI */
++#define	R367_QAM_EQU_SWEEP_RANGE_HI		0xF49B
++#define	F367_QAM_SWEEP_RANGE_HI		0xF49B00FF
++
++/* EQU_CRL_LIMITER */
++#define	R367_QAM_EQU_CRL_LIMITER		0xF49C
++#define	F367_QAM_BISECTOR_EN		0xF49C0080
++#define	F367_QAM_PHEST128_EN		0xF49C0040
++#define	F367_QAM_CRL_LIM		0xF49C003F
++
++/* EQU_MODULUS_MAP */
++#define	R367_QAM_EQU_MODULUS_MAP		0xF49D
++#define	F367_QAM_PNT_DEPTH		0xF49D00E0
++#define	F367_QAM_MODULUS_CMP		0xF49D001F
++
++/* EQU_PNT_GAIN */
++#define	R367_QAM_EQU_PNT_GAIN		0xF49E
++#define	F367_QAM_PNT_EN		0xF49E0080
++#define	F367_QAM_MODULUSMAP_EN		0xF49E0040
++#define	F367_QAM_PNT_GAIN		0xF49E003F
++
++/* FEC_AC_CTR_0 */
++#define	R367_QAM_FEC_AC_CTR_0		0xF4A8
++#define	F367_QAM_BE_BYPASS		0xF4A80020
++#define	F367_QAM_REFRESH47		0xF4A80010
++#define	F367_QAM_CT_NBST		0xF4A80008
++#define	F367_QAM_TEI_ENA		0xF4A80004
++#define	F367_QAM_DS_ENA		0xF4A80002
++#define	F367_QAM_TSMF_EN		0xF4A80001
++
++/* FEC_AC_CTR_1 */
++#define	R367_QAM_FEC_AC_CTR_1		0xF4A9
++#define	F367_QAM_DEINT_DEPTH		0xF4A900FF
++
++/* FEC_AC_CTR_2 */
++#define	R367_QAM_FEC_AC_CTR_2		0xF4AA
++#define	F367_QAM_DEINT_M		0xF4AA00F8
++#define	F367_QAM_DIS_UNLOCK		0xF4AA0004
++#define	F367_QAM_DESCR_MODE		0xF4AA0003
++
++/* FEC_AC_CTR_3 */
++#define	R367_QAM_FEC_AC_CTR_3		0xF4AB
++#define	F367_QAM_DI_UNLOCK		0xF4AB0080
++#define	F367_QAM_DI_FREEZE		0xF4AB0040
++#define	F367_QAM_MISMATCH		0xF4AB0030
++#define	F367_QAM_ACQ_MODE		0xF4AB000C
++#define	F367_QAM_TRK_MODE		0xF4AB0003
++
++/* FEC_STATUS */
++#define	R367_QAM_FEC_STATUS		0xF4AC
++#define	F367_QAM_DEINT_SMCNTR		0xF4AC00E0
++#define	F367_QAM_DEINT_SYNCSTATE		0xF4AC0018
++#define	F367_QAM_DEINT_SYNLOST		0xF4AC0004
++#define	F367_QAM_DESCR_SYNCSTATE		0xF4AC0002
++
++/* RS_COUNTER_0 */
++#define	R367_QAM_RS_COUNTER_0		0xF4AE
++#define	F367_QAM_BK_CT_L		0xF4AE00FF
++
++/* RS_COUNTER_1 */
++#define	R367_QAM_RS_COUNTER_1		0xF4AF
++#define	F367_QAM_BK_CT_H		0xF4AF00FF
++
++/* RS_COUNTER_2 */
++#define	R367_QAM_RS_COUNTER_2		0xF4B0
++#define	F367_QAM_CORR_CT_L		0xF4B000FF
++
++/* RS_COUNTER_3 */
++#define	R367_QAM_RS_COUNTER_3		0xF4B1
++#define	F367_QAM_CORR_CT_H		0xF4B100FF
++
++/* RS_COUNTER_4 */
++#define	R367_QAM_RS_COUNTER_4		0xF4B2
++#define	F367_QAM_UNCORR_CT_L		0xF4B200FF
++
++/* RS_COUNTER_5 */
++#define	R367_QAM_RS_COUNTER_5		0xF4B3
++#define	F367_QAM_UNCORR_CT_H		0xF4B300FF
++
++/* BERT_0 */
++#define	R367_QAM_BERT_0		0xF4B4
++#define	F367_QAM_RS_NOCORR		0xF4B40004
++#define	F367_QAM_CT_HOLD		0xF4B40002
++#define	F367_QAM_CT_CLEAR		0xF4B40001
++
++/* BERT_1 */
++#define	R367_QAM_BERT_1		0xF4B5
++#define	F367_QAM_BERT_ON		0xF4B50020
++#define	F367_QAM_BERT_ERR_SRC		0xF4B50010
++#define	F367_QAM_BERT_ERR_MODE		0xF4B50008
++#define	F367_QAM_BERT_NBYTE		0xF4B50007
++
++/* BERT_2 */
++#define	R367_QAM_BERT_2		0xF4B6
++#define	F367_QAM_BERT_ERRCOUNT_L		0xF4B600FF
++
++/* BERT_3 */
++#define	R367_QAM_BERT_3		0xF4B7
++#define	F367_QAM_BERT_ERRCOUNT_H		0xF4B700FF
++
++/* OUTFORMAT_0 */
++#define	R367_QAM_OUTFORMAT_0		0xF4B8
++#define	F367_QAM_CLK_POLARITY		0xF4B80080
++#define	F367_QAM_FEC_TYPE		0xF4B80040
++#define	F367_QAM_SYNC_STRIP		0xF4B80008
++#define	F367_QAM_TS_SWAP		0xF4B80004
++#define	F367_QAM_OUTFORMAT		0xF4B80003
++
++/* OUTFORMAT_1 */
++#define	R367_QAM_OUTFORMAT_1		0xF4B9
++#define	F367_QAM_CI_DIVRANGE		0xF4B900FF
++
++/* SMOOTHER_2 */
++#define	R367_QAM_SMOOTHER_2		0xF4BE
++#define	F367_QAM_FIFO_BYPASS		0xF4BE0020
++
++/* TSMF_CTRL_0 */
++#define	R367_QAM_TSMF_CTRL_0		0xF4C0
++#define	F367_QAM_TS_NUMBER		0xF4C0001E
++#define	F367_QAM_SEL_MODE		0xF4C00001
++
++/* TSMF_CTRL_1 */
++#define	R367_QAM_TSMF_CTRL_1		0xF4C1
++#define	F367_QAM_CHECK_ERROR_BIT		0xF4C10080
++#define	F367_QAM_CHCK_F_SYNC		0xF4C10040
++#define	F367_QAM_H_MODE		0xF4C10008
++#define	F367_QAM_D_V_MODE		0xF4C10004
++#define	F367_QAM_MODE		0xF4C10003
++
++/* TSMF_CTRL_3 */
++#define	R367_QAM_TSMF_CTRL_3		0xF4C3
++#define	F367_QAM_SYNC_IN_COUNT		0xF4C300F0
++#define	F367_QAM_SYNC_OUT_COUNT		0xF4C3000F
++
++/* TS_ON_ID_0 */
++#define	R367_QAM_TS_ON_ID_0		0xF4C4
++#define	F367_QAM_TS_ID_L		0xF4C400FF
++
++/* TS_ON_ID_1 */
++#define	R367_QAM_TS_ON_ID_1		0xF4C5
++#define	F367_QAM_TS_ID_H		0xF4C500FF
++
++/* TS_ON_ID_2 */
++#define	R367_QAM_TS_ON_ID_2		0xF4C6
++#define	F367_QAM_ON_ID_L		0xF4C600FF
++
++/* TS_ON_ID_3 */
++#define	R367_QAM_TS_ON_ID_3		0xF4C7
++#define	F367_QAM_ON_ID_H		0xF4C700FF
++
++/* RE_STATUS_0 */
++#define	R367_QAM_RE_STATUS_0		0xF4C8
++#define	F367_QAM_RECEIVE_STATUS_L		0xF4C800FF
++
++/* RE_STATUS_1 */
++#define	R367_QAM_RE_STATUS_1		0xF4C9
++#define	F367_QAM_RECEIVE_STATUS_LH		0xF4C900FF
++
++/* RE_STATUS_2 */
++#define	R367_QAM_RE_STATUS_2		0xF4CA
++#define	F367_QAM_RECEIVE_STATUS_HL		0xF4CA00FF
++
++/* RE_STATUS_3 */
++#define	R367_QAM_RE_STATUS_3		0xF4CB
++#define	F367_QAM_RECEIVE_STATUS_HH		0xF4CB003F
++
++/* TS_STATUS_0 */
++#define	R367_QAM_TS_STATUS_0		0xF4CC
++#define	F367_QAM_TS_STATUS_L		0xF4CC00FF
++
++/* TS_STATUS_1 */
++#define	R367_QAM_TS_STATUS_1		0xF4CD
++#define	F367_QAM_TS_STATUS_H		0xF4CD007F
++
++/* TS_STATUS_2 */
++#define	R367_QAM_TS_STATUS_2		0xF4CE
++#define	F367_QAM_ERROR		0xF4CE0080
++#define	F367_QAM_EMERGENCY		0xF4CE0040
++#define	F367_QAM_CRE_TS		0xF4CE0030
++#define	F367_QAM_VER		0xF4CE000E
++#define	F367_QAM_M_LOCK		0xF4CE0001
++
++/* TS_STATUS_3 */
++#define	R367_QAM_TS_STATUS_3		0xF4CF
++#define	F367_QAM_UPDATE_READY		0xF4CF0080
++#define	F367_QAM_END_FRAME_HEADER		0xF4CF0040
++#define	F367_QAM_CONTCNT		0xF4CF0020
++#define	F367_QAM_TS_IDENTIFIER_SEL		0xF4CF000F
++
++/* T_O_ID_0 */
++#define	R367_QAM_T_O_ID_0		0xF4D0
++#define	F367_QAM_ON_ID_I_L		0xF4D000FF
++
++/* T_O_ID_1 */
++#define	R367_QAM_T_O_ID_1		0xF4D1
++#define	F367_QAM_ON_ID_I_H		0xF4D100FF
++
++/* T_O_ID_2 */
++#define	R367_QAM_T_O_ID_2		0xF4D2
++#define	F367_QAM_TS_ID_I_L		0xF4D200FF
++
++/* T_O_ID_3 */
++#define	R367_QAM_T_O_ID_3		0xF4D3
++#define	F367_QAM_TS_ID_I_H		0xF4D300FF
++
+diff --git a/drivers/media/dvb-frontends/tda18212dd.c b/drivers/media/dvb-frontends/tda18212dd.c
+new file mode 100644
+index 0000000..de2350b
+--- /dev/null
++++ b/drivers/media/dvb-frontends/tda18212dd.c
+@@ -0,0 +1,906 @@
++/*
++ * tda18212: Driver for the TDA18212 tuner
++ *
++ * Copyright (C) 2011 Digital Devices GmbH
++ *
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 only, as published by the Free Software Foundation.
++ *
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301, USA
++ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/firmware.h>
++#include <linux/i2c.h>
++#include <linux/version.h>
++#include <asm/div64.h>
++
++#include "dvb_frontend.h"
++
++#ifndef CHK_ERROR
++    #define CHK_ERROR(s) if ((status = s) < 0) break
++#endif
++
++#define MASTER_PSM_AGC1     0
++#define MASTER_AGC1_6_15dB  1
++
++#define SLAVE_PSM_AGC1      1
++#define SLAVE_AGC1_6_15dB   0
++
++// 0 = 2 Vpp ... 2 = 1 Vpp,   7 = 0.5 Vpp
++#define IF_LEVEL_DVBC    2
++#define IF_LEVEL_DVBT    2
++
++enum {
++	ID_1                = 0x00,
++	ID_2                = 0x01,
++	ID_3                = 0x02,
++	THERMO_1,
++	THERMO_2,
++	POWER_STATE_1,
++	POWER_STATE_2,
++	INPUT_POWER_LEVEL,
++	IRQ_STATUS,
++	IRQ_ENABLE,
++	IRQ_CLEAR,
++	IRQ_SET,
++	AGC1_1,
++	AGC2_1,
++	AGCK_1,
++	RF_AGC_1,
++	IR_MIXER_1          = 0x10,
++	AGC5_1,
++	IF_AGC,
++	IF_1,
++	REFERENCE,
++	IF_FREQUENCY_1,
++	RF_FREQUENCY_1,
++	RF_FREQUENCY_2,
++	RF_FREQUENCY_3,
++	MSM_1,
++	MSM_2,
++	PSM_1,
++	DCC_1,
++	FLO_MAX,
++	IR_CAL_1,
++	IR_CAL_2,
++	IR_CAL_3            = 0x20,
++	IR_CAL_4,
++	VSYNC_MGT,
++	IR_MIXER_2,
++	AGC1_2,
++	AGC5_2,
++	RF_CAL_1,
++	RF_CAL_2,
++	RF_CAL_3,
++	RF_CAL_4,
++	RF_CAL_5,
++	RF_CAL_6,
++	RF_FILTER_1,
++	RF_FILTER_2,
++	RF_FILTER_3,
++	RF_BAND_PASS_FILTER,
++	CP_CURRENT          = 0x30,
++	AGC_DET_OUT         = 0x31,
++	RF_AGC_GAIN_1       = 0x32,
++	RF_AGC_GAIN_2       = 0x33,
++	IF_AGC_GAIN         = 0x34,
++	POWER_1             = 0x35,
++	POWER_2             = 0x36,
++	MISC_1,
++	RFCAL_LOG_1,
++	RFCAL_LOG_2,
++	RFCAL_LOG_3,
++	RFCAL_LOG_4,
++	RFCAL_LOG_5,
++	RFCAL_LOG_6,
++	RFCAL_LOG_7,
++	RFCAL_LOG_8,
++	RFCAL_LOG_9         = 0x40,
++	RFCAL_LOG_10        = 0x41,
++	RFCAL_LOG_11        = 0x42,
++	RFCAL_LOG_12        = 0x43,
++	REG_MAX,
++};
++
++enum HF_Standard {
++	HF_None=0, HF_B, HF_DK, HF_G, HF_I, HF_L, HF_L1, HF_MN, HF_FM_Radio,
++	HF_AnalogMax, HF_DVBT_6MHZ, HF_DVBT_7MHZ, HF_DVBT_8MHZ,
++	HF_DVBT, HF_ATSC,  HF_DVBC_6MHZ,  HF_DVBC_7MHZ,
++	HF_DVBC_8MHZ, HF_DVBC
++};
++
++struct SStandardParams {
++	s32   m_IFFrequency;
++	u32   m_BandWidth;
++	u8    m_IF_1;         // FF IF_HP_fc:2 IF_Notch:1 LP_FC_Offset:2 LP_FC:3
++	u8    m_IR_MIXER_2;   // 03 :6 HI_Pass:1 DC_Notch:1
++	u8    m_AGC1_1;       // 0F :4 AGC1_Top:4
++	u8    m_AGC2_1;       // 0F :4 AGC2_Top:4
++	u8    m_RF_AGC_1_Low; // EF RF_AGC_Adapt:1 RF_AGC_Adapt_Top:2 :1 RF_Atten_3dB:1  RF_AGC_Top:3
++	u8    m_RF_AGC_1_High;// EF RF_AGC_Adapt:1 RF_AGC_Adapt_Top:2 :1 RF_Atten_3dB:1  RF_AGC_Top:3
++	u8    m_IR_MIXER_1;   // 0F :4 IR_mixer_Top:4
++	u8    m_AGC5_1;       // 1F :3 AGC5_Ana AGC5_Top:4
++	u8    m_AGCK_1;       // 0F :4 AGCK_Step:2 AGCK_Mode:2
++	u8    m_PSM_1;        // 20 :2 PSM_StoB:1 :5
++	bool  m_AGC1_Freeze;
++	bool  m_LTO_STO_immune;
++};
++
++struct SStandardParams m_StandardTable[HF_DVBC_8MHZ - HF_DVBT_6MHZ + 1] =
++{
++	{ 3250000, 6000000, 0x20, 0x03, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_6MHZ
++	{ 3500000, 7000000, 0x31, 0x01, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_7MHZ
++	{ 4000000, 8000000, 0x22, 0x01, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_8MHZ
++	{       0,       0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, false, false },    // HF_DVBT (Unused)
++	{ 3250000, 6000000, 0x20, 0x03, 0x0A, 0x07, 0x6D, 0x6D, 0x0E, 0x0E, 0x02, 0x20, false, false },    // HF_ATSC
++	{ 3600000, 6000000, 0x10, 0x01, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_6MHZ
++//    { 5000000, 7000000, 0x53, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_7MHZ (not documented by NXP, use same settings as 8 MHZ)
++//    { 5000000, 8000000, 0x53, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_8MHZ
++	{ 5000000, 7000000, 0x93, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_7MHZ (not documented by NXP, use same settings as 8 MHZ)
++	{ 5000000, 8000000, 0x43, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_8MHZ
++};
++
++struct tda_state {
++	struct i2c_adapter *i2c;
++	u8 adr;
++
++	enum HF_Standard m_Standard;
++	u32   m_Frequency;
++	u32   IF;
++
++	bool    m_isMaster;
++	bool    m_bPowerMeasurement;
++	bool    m_bLTEnable;
++	bool    m_bEnableFreeze;
++
++	u16   m_ID;
++
++	s32    m_SettlingTime;
++
++	u8    m_IFLevelDVBC;
++	u8    m_IFLevelDVBT;
++	u8    m_Regs[REG_MAX];
++	u8    m_LastPowerLevel;
++};
++
++static int i2c_readn(struct i2c_adapter *adapter, u8 adr, u8 *data, int len)
++{
++	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
++				   .buf  = data, .len   = len}};
++	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
++}
++
++static int i2c_read(struct i2c_adapter *adap,
++		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
++{
++	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
++				     .buf = msg, .len = len},
++				   { .addr = adr, .flags = I2C_M_RD,
++				     .buf = answ, .len = alen } };
++	if (i2c_transfer(adap, msgs, 2) != 2) {
++		printk("tda18212dd: i2c_read error\n");
++		return -1;
++	}
++	return 0;
++}
++
++static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
++{
++	struct i2c_msg msg = {.addr = adr, .flags = 0,
++			      .buf = data, .len = len};
++
++	if (i2c_transfer(adap, &msg, 1) != 1) {
++		printk("tda18212: i2c_write error\n");
++		return -1;
++	}
++	return 0;
++}
++
++static int write_regs(struct tda_state *state,
++		      u8 SubAddr, u8 *Regs, u16 nRegs)
++{
++	u8 data[nRegs+1];
++
++	data[0] = SubAddr;
++	memcpy(data + 1, Regs, nRegs);
++	return i2c_write(state->i2c, state->adr, data, nRegs+1);
++}
++
++static int write_reg(struct tda_state *state, u8 SubAddr,u8 Reg)
++{
++	u8 msg[2] = {SubAddr, Reg};
++
++	return i2c_write(state->i2c, state->adr, msg, 2);
++}
++
++static int Read(struct tda_state *state, u8 * Regs)
++{
++	return i2c_readn(state->i2c, state->adr, Regs, REG_MAX);
++}
++
++static int update_regs(struct tda_state *state, u8 RegFrom,u8 RegTo)
++{
++	return write_regs(state, RegFrom,
++			  &state->m_Regs[RegFrom], RegTo-RegFrom+1);
++}
++
++static int update_reg(struct tda_state *state, u8 Reg)
++{
++	return write_reg(state, Reg,state->m_Regs[Reg]);
++}
++
++
++static int read_regs(struct tda_state *state,
++		    u8 SubAddr, u8 *Regs, u16 nRegs)
++{
++	return i2c_read(state->i2c, state->adr,
++			&SubAddr, 1, Regs, nRegs);
++}
++
++static int read_reg(struct tda_state *state,
++		   u8 SubAddr, u8 *Reg)
++{
++	return i2c_read(state->i2c, state->adr,
++			&SubAddr, 1, Reg, 1);
++}
++
++static int read_reg1(struct tda_state *state, u8 Reg)
++{
++	return read_reg(state, Reg, &state->m_Regs[Reg]);
++}
++
++static void init_state(struct tda_state *state)
++{
++    u32   ulIFLevelDVBC = IF_LEVEL_DVBC;
++    u32   ulIFLevelDVBT = IF_LEVEL_DVBT;
++    u32   ulPowerMeasurement = 1;
++    u32   ulLTEnable = 1;
++    u32   ulEnableFreeze = 0;
++
++    state->m_Frequency    = 0;
++    state->m_isMaster = true;
++    state->m_ID = 0;
++    state->m_LastPowerLevel = 0xFF;
++    state->m_IFLevelDVBC = (ulIFLevelDVBC & 0x07);
++    state->m_IFLevelDVBT = (ulIFLevelDVBT & 0x07);
++    state->m_bPowerMeasurement = (ulPowerMeasurement != 0);
++    state->m_bLTEnable = (ulLTEnable != 0);
++    state->m_bEnableFreeze = (ulEnableFreeze != 0);
++}
++
++static int StartCalibration(struct tda_state *state)
++{
++	int  status = 0;
++	do {
++		state->m_Regs[POWER_2] &= ~0x02; // RSSI CK = 31.25 kHz
++		CHK_ERROR(update_reg(state, POWER_2));
++
++		state->m_Regs[AGC1_2] = (state->m_Regs[AGC1_2] & ~0x60) | 0x40;    // AGC1 Do Step = 2
++		CHK_ERROR(update_reg(state, AGC1_2));        // AGC
++
++		state->m_Regs[RF_FILTER_3] = (state->m_Regs[RF_FILTER_3] & ~0xC0) | 0x40;    // AGC2 Do Step = 1
++		CHK_ERROR(update_reg(state, RF_FILTER_3));
++
++		state->m_Regs[AGCK_1] |= 0xC0; // AGCs Assym Up Step = 3      // Datasheet sets all bits to 1!
++		CHK_ERROR(update_reg(state, AGCK_1));
++
++		state->m_Regs[AGC5_1] = (state->m_Regs[AGC5_1] & ~0x60) | 0x40;    // AGCs Assym Do Step = 2
++		CHK_ERROR(update_reg(state, AGC5_1));
++
++		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
++		CHK_ERROR(update_reg(state, IRQ_CLEAR));
++
++		state->m_Regs[MSM_1] = 0x3B; // Set Calibration
++		state->m_Regs[MSM_2] = 0x01; // Start MSM
++		CHK_ERROR(update_regs(state, MSM_1,MSM_2));
++		state->m_Regs[MSM_2] = 0x00;
++
++	} while(0);
++	return status;
++}
++
++static int FinishCalibration(struct tda_state *state)
++{
++	int status = 0;
++	u8 RFCal_Log[12];
++
++	do {
++		u8 IRQ = 0;
++		int Timeout = 150; // 1.5 s
++		while(true) {
++			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
++			if ((IRQ & 0x80) != 0 )
++				break;
++			Timeout -= 1;
++			if (Timeout == 0) {
++				status = -1;
++				break;
++			}
++			msleep(10);
++		}
++		CHK_ERROR(status);
++
++		state->m_Regs[FLO_MAX] = 0x0A;
++		CHK_ERROR(update_reg(state, FLO_MAX));
++
++		state->m_Regs[AGC1_1] &= ~0xC0;
++		if( state->m_bLTEnable ) state->m_Regs[AGC1_1] |= 0x80;    // LTEnable
++
++		state->m_Regs[AGC1_1] |= (state->m_isMaster ? MASTER_AGC1_6_15dB : SLAVE_AGC1_6_15dB ) << 6;
++		CHK_ERROR(update_reg(state, AGC1_1));
++
++		state->m_Regs[PSM_1] &= ~0xC0;
++		state->m_Regs[PSM_1] |= (state->m_isMaster ? MASTER_PSM_AGC1 : SLAVE_PSM_AGC1 ) << 6;
++		CHK_ERROR(update_reg(state, PSM_1));
++
++		state->m_Regs[REFERENCE] |= 0x03; // XTOUT = 3
++		CHK_ERROR(update_reg(state, REFERENCE));
++
++		CHK_ERROR(read_regs(state, RFCAL_LOG_1,RFCal_Log,sizeof(RFCal_Log)));
++	} while(0);
++	return status;
++}
++
++static int PowerOn(struct tda_state *state)
++{
++	state->m_Regs[POWER_STATE_2] &= ~0x0F;
++	update_reg(state, POWER_STATE_2);
++	state->m_Regs[REFERENCE] |= 0x40;  // Digital clock source = Sigma Delta
++	update_reg(state, REFERENCE);
++	return 0;
++}
++
++static int Standby(struct tda_state *state)
++{
++	int status = 0;
++
++	do {
++		state->m_Regs[REFERENCE] &= ~0x40;  // Digital clock source = Quarz
++		CHK_ERROR(update_reg(state, REFERENCE));
++
++		state->m_Regs[POWER_STATE_2] &= ~0x0F;
++		state->m_Regs[POWER_STATE_2] |= state->m_isMaster ? 0x08 : 0x0E;
++		CHK_ERROR(update_reg(state, POWER_STATE_2));
++	} while(0);
++	return status;
++}
++
++static int attach_init(struct tda_state *state)
++{
++	int stat = 0;
++	u8 Id[2];
++	u8 PowerState = 0x00;
++
++	state->m_Standard = HF_None;
++
++	/* first read after cold reset sometimes fails on some cards,
++	   try twice */
++	stat = read_regs(state, ID_1, Id, sizeof(Id));
++	stat = read_regs(state, ID_1, Id, sizeof(Id));
++	if (stat < 0)
++		return -1;
++
++	state->m_ID = ((Id[0] & 0x7F) << 8) | Id[1];
++	state->m_isMaster = ((Id[0] & 0x80) != 0);
++	if( !state->m_isMaster )
++		state->m_bLTEnable = false;
++
++	printk("tda18212dd: ChipID %04x\n", state->m_ID);
++
++	if( state->m_ID != 18212 )
++		return -1;
++
++	stat = read_reg(state, POWER_STATE_1 ,&PowerState);
++	if (stat < 0)
++		return stat;
++
++	printk("tda18212dd: PowerState %02x\n", PowerState);
++
++	if (state->m_isMaster) {
++		if( PowerState & 0x02 ) {
++			// msleep for XTAL Calibration (on a PC this should be long done)
++			u8 IRQStatus = 0;
++			int Timeout = 10;
++
++			while(Timeout > 0) {
++				read_reg(state, IRQ_STATUS, &IRQStatus);
++				if (IRQStatus & 0x20)
++					break;
++				Timeout -= 1;
++				msleep(10);
++			}
++			if( (IRQStatus & 0x20) == 0 ) {
++				stat = -ETIMEDOUT;
++			}
++		}
++	} else {
++		write_reg(state, FLO_MAX, 0x00);
++		write_reg(state, CP_CURRENT,0x68);
++	}
++	Read(state, state->m_Regs);
++
++	PowerOn(state);
++	StartCalibration(state);
++	FinishCalibration(state);
++	Standby(state);
++	return stat;
++}
++
++static int PowerMeasurement(struct tda_state *state, u8 *pPowerLevel)
++{
++	int status = 0;
++
++	do {
++		u8 IRQ = 0;
++		int Timeout = 70; // 700 ms
++
++		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
++		CHK_ERROR(update_reg(state, IRQ_CLEAR));
++
++		state->m_Regs[MSM_1] = 0x80; // power measurement
++		state->m_Regs[MSM_2] = 0x01; // Start MSM
++		CHK_ERROR(update_regs(state, MSM_1,MSM_2));
++		state->m_Regs[MSM_2] = 0x00;
++
++		while(true) {
++			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
++			if( (IRQ & 0x80) != 0 )
++				break;
++			Timeout -= 1;
++			if( Timeout == 0 )
++			{
++				status = -1;
++				break;
++			}
++			msleep(10);
++		}
++		CHK_ERROR(status);
++
++		CHK_ERROR(read_reg1(state, INPUT_POWER_LEVEL));
++		*pPowerLevel = state->m_Regs[INPUT_POWER_LEVEL] & 0x7F;
++
++
++		if( *pPowerLevel > 110 ) *pPowerLevel = 110;
++	} while(0);
++	/* printk("PL %d\n", *pPowerLevel); */
++	return status;
++}
++
++static int SetFrequency(struct tda_state *state, u32 Frequency, enum HF_Standard Standard)
++{
++	int status = 0;
++	struct SStandardParams *StandardParams;
++	u32   f = Frequency / 1000;
++	u8 IRQ = 0;
++	int Timeout = 25; // 250 ms
++	u32 fRatio = Frequency / 16000000;
++	u32 fDelta = Frequency - fRatio * 16000000;
++
++	if( Standard < HF_DVBT_6MHZ || Standard > HF_DVBC_8MHZ )
++		return -EINVAL;
++	StandardParams = &m_StandardTable[Standard - HF_DVBT_6MHZ];
++
++	if( StandardParams->m_IFFrequency == 0 )
++		return -EINVAL;
++	state->m_Standard = HF_None;
++	state->m_Frequency = 0;
++
++	do {
++		// IF Level
++		state->m_Regs[IF_AGC] = (Standard >= HF_DVBC_6MHZ) ? state->m_IFLevelDVBC : state->m_IFLevelDVBT;
++		CHK_ERROR(update_reg(state, IF_AGC));
++
++		// ---------------------------------------------------------------------------------
++		// Standard setup
++
++		state->m_Regs[IF_1] = StandardParams->m_IF_1;
++		CHK_ERROR(update_reg(state, IF_1));
++
++		state->m_Regs[IR_MIXER_2] = (state->m_Regs[IR_MIXER_2] & ~0x03) | StandardParams->m_IR_MIXER_2;
++		CHK_ERROR(update_reg(state, IR_MIXER_2));
++
++		state->m_Regs[AGC1_1] = (state->m_Regs[AGC1_1] & ~0x0F) | StandardParams->m_AGC1_1;
++		CHK_ERROR(update_reg(state, AGC1_1));
++
++		state->m_Regs[AGC2_1] = (state->m_Regs[AGC2_1] & ~0x0F) | StandardParams->m_AGC2_1;
++		CHK_ERROR(update_reg(state, AGC2_1));
++
++		state->m_Regs[RF_AGC_1] &= ~0xEF;
++		if( Frequency < 291000000 )
++			state->m_Regs[RF_AGC_1] |= StandardParams->m_RF_AGC_1_Low;
++		else
++			state->m_Regs[RF_AGC_1] |= StandardParams->m_RF_AGC_1_High;
++		CHK_ERROR(update_reg(state, RF_AGC_1));
++
++		state->m_Regs[IR_MIXER_1] = (state->m_Regs[IR_MIXER_1] & ~0x0F) | StandardParams->m_IR_MIXER_1;
++		CHK_ERROR(update_reg(state, IR_MIXER_1));
++
++		state->m_Regs[AGC5_1] = (state->m_Regs[AGC5_1] & ~0x1F) | StandardParams->m_AGC5_1;
++		CHK_ERROR(update_reg(state, AGC5_1));
++
++		state->m_Regs[AGCK_1] = (state->m_Regs[AGCK_1] & ~0x0F) | StandardParams->m_AGCK_1;
++		CHK_ERROR(update_reg(state, AGCK_1));
++
++		state->m_Regs[PSM_1] = (state->m_Regs[PSM_1] & ~0x20) | StandardParams->m_PSM_1;
++		CHK_ERROR(update_reg(state, PSM_1));
++
++		state->m_Regs[IF_FREQUENCY_1] = ( StandardParams->m_IFFrequency / 50000 );
++		CHK_ERROR(update_reg(state, IF_FREQUENCY_1));
++
++		if( state->m_isMaster && StandardParams->m_LTO_STO_immune )
++		{
++			u8 tmp;
++			u8 RF_Filter_Gain;
++
++			CHK_ERROR(read_reg(state, RF_AGC_GAIN_1,&tmp));
++			RF_Filter_Gain = (tmp & 0x30) >> 4;
++
++			state->m_Regs[RF_FILTER_1] = (state->m_Regs[RF_FILTER_1] & ~0x0C) | (RF_Filter_Gain << 2);
++			CHK_ERROR(update_reg(state, RF_FILTER_1));
++
++			state->m_Regs[RF_FILTER_1] |= 0x10;    // Force
++			CHK_ERROR(update_reg(state, RF_FILTER_1));
++
++			while( RF_Filter_Gain != 0 )
++			{
++				RF_Filter_Gain -= 1;
++				state->m_Regs[RF_FILTER_1] = (state->m_Regs[RF_FILTER_1] & ~0x0C) | (RF_Filter_Gain << 2);
++				CHK_ERROR(update_reg(state, RF_FILTER_1));
++				msleep(10);
++			}
++			CHK_ERROR(status);
++
++			state->m_Regs[RF_AGC_1] |=  0x08;
++			CHK_ERROR(update_reg(state, RF_AGC_1));
++		}
++
++		// ---------------------------------------------------------------------------------
++
++		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
++		CHK_ERROR(update_reg(state, IRQ_CLEAR));
++
++		CHK_ERROR(PowerOn(state));
++
++		state->m_Regs[RF_FREQUENCY_1] = ((f >> 16) & 0xFF);
++		state->m_Regs[RF_FREQUENCY_2] = ((f >>  8) & 0xFF);
++		state->m_Regs[RF_FREQUENCY_3] = ((f      ) & 0xFF);
++		CHK_ERROR(update_regs(state, RF_FREQUENCY_1,RF_FREQUENCY_3));
++
++		state->m_Regs[MSM_1] = 0x41; // Tune
++		state->m_Regs[MSM_2] = 0x01; // Start MSM
++		CHK_ERROR(update_regs(state, MSM_1, MSM_2));
++		state->m_Regs[MSM_2] = 0x00;
++
++		while(true)
++		{
++			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
++			if( (IRQ & 0x80) != 0 ) break;
++			Timeout -= 1;
++			if (Timeout == 0) {
++				status = -1;
++				break;
++			}
++			msleep(10);
++		}
++		CHK_ERROR(status);
++
++		// ---------------------------------------------------------------------------------
++
++		if( state->m_isMaster && StandardParams->m_LTO_STO_immune )
++		{
++			state->m_Regs[RF_AGC_1] &=  ~0x08;
++			CHK_ERROR(update_reg(state, RF_AGC_1));
++
++			msleep(50);
++
++			state->m_Regs[RF_FILTER_1] &= ~0x10;    // remove force
++			CHK_ERROR(update_reg(state, RF_FILTER_1));
++		}
++
++		// ---------------------------------------------------------------------------------
++		//  Spur reduction
++
++		if( Frequency < 72000000 )
++		{
++			state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
++		}
++		else if( Frequency < 104000000 )
++		{
++			state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
++		}
++		else if( Frequency < 120000000 )
++		{
++			state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
++		}
++		else
++		{
++			if( fDelta <= 8000000 )
++			{
++				if( fRatio & 1 ) state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
++				else             state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
++			}
++			else
++			{
++				if( fRatio & 1 ) state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
++				else             state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
++			}
++
++		}
++		CHK_ERROR(update_reg(state, REFERENCE));
++
++		if( StandardParams->m_AGC1_Freeze && state->m_bEnableFreeze )
++		{
++			u8 tmp;
++			int AGC1GainMin = 0;
++			int nSteps = 10;
++			int Step  = 0;
++
++			CHK_ERROR(read_reg(state, AGC1_2,&tmp));
++
++			if( (tmp & 0x80) == 0 )
++			{
++				state->m_Regs[AGC1_2] |= 0x80;         // Loop off
++				CHK_ERROR(update_reg(state, AGC1_2));
++				state->m_Regs[AGC1_2] |= 0x10 ;        // Force gain
++				CHK_ERROR(update_reg(state, AGC1_2));
++			}
++			// Adapt
++			if( state->m_Regs[AGC1_1] & 0x40 ) // AGC1_6_15dB set
++			{
++				AGC1GainMin = 6;
++				nSteps = 4;
++			}
++			while( Step < nSteps )
++			{
++				int Down = 0;
++				int Up = 0, i;
++				u8 AGC1_Gain;
++
++				Step = Step + 1;
++
++				for (i = 0; i < 40; i += 1) {
++					CHK_ERROR(read_reg(state, AGC_DET_OUT, &tmp));
++					Up   += (tmp & 0x02) ?  1 : -4;
++					Down += (tmp & 0x01) ? 14 : -1;
++					msleep(1);
++				}
++				CHK_ERROR(status);
++				AGC1_Gain = (state->m_Regs[AGC1_2] & 0x0F);
++				if( Up >= 15 && AGC1_Gain != 9 )
++				{
++					state->m_Regs[AGC1_2] = ( state->m_Regs[AGC1_2] & ~0x0F ) | (AGC1_Gain + 1);
++					CHK_ERROR(update_reg(state, AGC1_2));
++				}
++				else if ( Down >= 10 && AGC1_Gain != AGC1GainMin )
++				{
++					state->m_Regs[AGC1_2] = ( state->m_Regs[AGC1_2] & ~0x0F ) | (AGC1_Gain - 1);
++					CHK_ERROR(update_reg(state, AGC1_2));
++				}
++				else
++				{
++					Step = nSteps;
++				}
++			}
++		}
++		else
++		{
++			state->m_Regs[AGC1_2] &= ~0x10 ;       // unforce gain
++			CHK_ERROR(update_reg(state, AGC1_2));
++			state->m_Regs[AGC1_2] &= ~0x80;         // Loop on
++			CHK_ERROR(update_reg(state, AGC1_2));
++		}
++
++		state->m_Standard = Standard;
++		state->m_Frequency = Frequency;
++
++		if( state->m_bPowerMeasurement )
++			PowerMeasurement(state, &state->m_LastPowerLevel);
++	} while(0);
++
++	return status;
++}
++
++static int sleep(struct dvb_frontend* fe)
++{
++	struct tda_state *state = fe->tuner_priv;
++
++	Standby(state);
++	return 0;
++}
++
++static int init(struct dvb_frontend* fe)
++{
++	//struct tda_state *state = fe->tuner_priv;
++	return 0;
++}
++
++static int release(struct dvb_frontend* fe)
++{
++	kfree(fe->tuner_priv);
++	fe->tuner_priv = NULL;
++	return 0;
++}
++
++#ifdef USE_API3
++static int set_params(struct dvb_frontend *fe,
++		      struct dvb_frontend_parameters *params)
++{
++	struct tda_state *state = fe->tuner_priv;
++	int status = 0;
++	int Standard;
++
++	state->m_Frequency = params->frequency;
++
++	if (fe->ops.info.type == FE_OFDM)
++		switch (params->u.ofdm.bandwidth) {
++		case BANDWIDTH_6_MHZ:
++			Standard = HF_DVBT_6MHZ;
++			break;
++		case BANDWIDTH_7_MHZ:
++			Standard = HF_DVBT_7MHZ;
++			break;
++		default:
++		case BANDWIDTH_8_MHZ:
++			Standard = HF_DVBT_8MHZ;
++			break;
++		}
++	else if (fe->ops.info.type == FE_QAM) {
++		Standard = HF_DVBC_8MHZ;
++	} else
++		return -EINVAL;
++
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 1);
++	SetFrequency(state, state->m_Frequency, Standard);
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 0);
++
++	return status;
++}
++#else
++static int set_params(struct dvb_frontend *fe)
++{
++	struct tda_state *state = fe->tuner_priv;
++	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
++	int status = 0;
++	int Standard;
++
++	state->m_Frequency = p->frequency;
++
++	if (p->delivery_system == SYS_DVBT)
++		switch (p->bandwidth_hz) {
++		case 6000000:
++			Standard = HF_DVBT_6MHZ;
++			break;
++		case 7000000:
++			Standard = HF_DVBT_7MHZ;
++			break;
++		default:
++		case 8000000:
++			Standard = HF_DVBT_8MHZ;
++			break;
++		}
++	else if (p->delivery_system == SYS_DVBC_ANNEX_A) {
++		Standard = HF_DVBC_8MHZ;
++	} else
++		return -EINVAL;
++
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 1);
++	SetFrequency(state, state->m_Frequency, Standard);
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 0);
++
++	return status;
++}
++#endif
++
++static int get_frequency(struct dvb_frontend *fe, u32 *frequency)
++{
++	struct tda_state *state = fe->tuner_priv;
++
++	*frequency = state->IF;
++	return 0;
++}
++
++static int get_rf_strength(struct dvb_frontend *fe, u16 *st)
++{
++	struct tda_state *state = fe->tuner_priv;
++
++	*st = state->m_LastPowerLevel;
++	return 0;
++}
++
++static int get_if(struct dvb_frontend *fe, u32 *frequency)
++{
++	struct tda_state *state = fe->tuner_priv;
++
++	state->IF = 0;
++	if (state->m_Standard < HF_DVBT_6MHZ ||
++	    state->m_Standard > HF_DVBC_8MHZ)
++		return 0;
++	state->IF = m_StandardTable[state->m_Standard - HF_DVBT_6MHZ].m_IFFrequency;
++	*frequency = state->IF;
++	return 0;
++}
++
++static int get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
++{
++	//struct tda_state *state = fe->tuner_priv;
++	//*bandwidth = priv->bandwidth;
++	return 0;
++}
++
++
++static struct dvb_tuner_ops tuner_ops = {
++	.info = {
++		.name = "NXP TDA18212",
++		.frequency_min  =  47125000,
++		.frequency_max  = 865000000,
++		.frequency_step =     62500
++	},
++	.init              = init,
++	.sleep             = sleep,
++	.set_params        = set_params,
++	.release           = release,
++	.get_frequency     = get_frequency,
++	.get_if_frequency  = get_if,
++	.get_bandwidth     = get_bandwidth,
++	.get_rf_strength   = get_rf_strength,
++};
++
++struct dvb_frontend *tda18212dd_attach(struct dvb_frontend *fe,
++				       struct i2c_adapter *i2c, u8 adr)
++{
++	struct tda_state *state;
++	int stat;
++
++	state = kzalloc(sizeof(struct tda_state), GFP_KERNEL);
++	if (!state)
++		return NULL;
++	state->adr = adr;
++	state->i2c = i2c;
++	memcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));
++	init_state(state);
++
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 1);
++	stat = attach_init(state);
++	if (fe->ops.i2c_gate_ctrl)
++		fe->ops.i2c_gate_ctrl(fe, 0);
++	if (stat < 0) {
++		kfree(state);
++		return 0;
++	}
++	fe->tuner_priv = state;
++	return fe;
++}
++
++EXPORT_SYMBOL_GPL(tda18212dd_attach);
++MODULE_DESCRIPTION("TDA18212 driver");
++MODULE_AUTHOR("DD");
++MODULE_LICENSE("GPL");
++
++/*
++ * Local variables:
++ * c-basic-offset: 8
++ * End:
++ */
+diff --git a/drivers/media/dvb-frontends/tda18212dd.h b/drivers/media/dvb-frontends/tda18212dd.h
+new file mode 100644
+index 0000000..687fab4
+--- /dev/null
++++ b/drivers/media/dvb-frontends/tda18212dd.h
+@@ -0,0 +1,5 @@
++#ifndef _TDA18212DD_H_
++#define _TDA18212DD_H_
++struct dvb_frontend *tda18212dd_attach(struct dvb_frontend *fe,
++				       struct i2c_adapter *i2c, u8 adr);
++#endif
+diff --git a/drivers/media/pci/ddbridge/Kconfig b/drivers/media/pci/ddbridge/Kconfig
+index 44e5dc1..0a4ae75 100644
+--- a/drivers/media/pci/ddbridge/Kconfig
++++ b/drivers/media/pci/ddbridge/Kconfig
+@@ -1,11 +1,14 @@
+ config DVB_DDBRIDGE
+ 	tristate "Digital Devices bridge support"
+ 	depends on DVB_CORE && PCI && I2C
+-	select DVB_LNBP21 if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_STV6110x if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_STV090x if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_DRXK if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_TDA18271C2DD if MEDIA_SUBDRV_AUTOSELECT
++	select DVB_CXD2099
++	select DVB_LNBP21 if !DVB_FE_CUSTOMISE
++	select DVB_STV6110x if !DVB_FE_CUSTOMISE
++	select DVB_STV090x if !DVB_FE_CUSTOMISE
++	select DVB_DRXK if !DVB_FE_CUSTOMISE
++	select DVB_TDA18271C2DD if !DVB_FE_CUSTOMISE
++	select DVB_STV0367DD if !DVB_FE_CUSTOMISE
++	select DVB_TDA18212DD if !DVB_FE_CUSTOMISE
+ 	---help---
+ 	  Support for cards with the Digital Devices PCI express bridge:
+ 	  - Octopus PCIe Bridge
+@@ -14,5 +17,6 @@ config DVB_DDBRIDGE
+ 	  - DuoFlex S2 Octopus
+ 	  - DuoFlex CT Octopus
+ 	  - cineS2(v6)
++	  - cineCT(v6)
+ 
+ 	  Say Y if you own such a card and want to use it.
+diff --git a/drivers/media/pci/ddbridge/ddbridge-core.c b/drivers/media/pci/ddbridge/ddbridge-core.c
+index 36e3452..adff8cd 100644
+--- a/drivers/media/pci/ddbridge/ddbridge-core.c
++++ b/drivers/media/pci/ddbridge/ddbridge-core.c
+@@ -31,11 +31,11 @@
+ #include <linux/pci.h>
+ #include <linux/pci_ids.h>
+ #include <linux/timer.h>
++#include <linux/version.h>
+ #include <linux/i2c.h>
+ #include <linux/swab.h>
+ #include <linux/vmalloc.h>
+ #include "ddbridge.h"
+-
+ #include "ddbridge-regs.h"
+ 
+ #include "tda18271c2dd.h"
+@@ -43,14 +43,60 @@
+ #include "stv090x.h"
+ #include "lnbh24.h"
+ #include "drxk.h"
++#if 0
++#include "stv0367.h"
++#else
++#include "stv0367dd.h"
++#endif
++#if 0
++#include "tda18212.h"
++#else
++#include "tda18212dd.h"
++#endif
++
++static int adapter_alloc;
++module_param(adapter_alloc, int, 0444);
++MODULE_PARM_DESC(adapter_alloc, "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
++
++static int ts_loop = -1;
++module_param(ts_loop, int, 0444);
++MODULE_PARM_DESC(ts_loop, "TS in/out on port ts_loop");
+ 
+ DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+ 
++static struct ddb *ddbs[32];
++
+ /* MSI had problems with lost interrupts, fixed but needs testing */
+-#undef CONFIG_PCI_MSI
++/* #undef CONFIG_PCI_MSI */
++
++/******************************************************************************/
++
++static inline void ddbwritel(struct ddb *dev, u32 val, u32 adr)
++{
++	writel(val, (char *) (dev->regs+(adr)));
++}
++
++static inline u32 ddbreadl(struct ddb *dev, u32 adr)
++{
++	return readl((char *) (dev->regs+(adr)));
++}
++
++#define ddbcpyto(_dev, _adr, _src, _count)   memcpy_toio((char *) \
++					(_dev->regs + (_adr)), (_src), (_count))
++
++#define ddbcpyfrom(_dev, _dst, _adr, _count) memcpy_fromio((_dst), (char *) \
++					(_dev->regs + (_adr)), (_count))
++
+ 
+ /******************************************************************************/
+ 
++static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
++{
++	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};
++
++	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
++}
++
+ static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
+ {
+ 	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
+@@ -58,10 +104,31 @@ static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
+ 	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
+ }
+ 
++static int i2c_read_regs(struct i2c_adapter *adapter,
++			 u8 adr, u8 reg, u8 *val, u8 len)
++{
++	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
++				   .buf  = &reg, .len   = 1},
++				  {.addr = adr,  .flags = I2C_M_RD,
++				   .buf  = val,  .len   = len } };
++	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
++}
++
++static int i2c_read_regs16(struct i2c_adapter *adapter,
++			   u8 adr, u16 reg, u8 *val, u8 len)
++{
++	u8 reg16[2] = { reg >> 8, reg };
++	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
++				   .buf  = (u8 *)&reg16, .len   = 2},
++				  {.addr = adr,  .flags = I2C_M_RD,
++				   .buf  = val,  .len   = len } };
++	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
++}
++
+ static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
+ {
+ 	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+-				   .buf  = &reg, .len   = 1 },
++				   .buf  = &reg, .len   = 1},
+ 				  {.addr = adr,  .flags = I2C_M_RD,
+ 				   .buf  = val,  .len   = 1 } };
+ 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+@@ -70,14 +137,22 @@ static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
+ static int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
+ 			  u16 reg, u8 *val)
+ {
+-	u8 msg[2] = {reg>>8, reg&0xff};
++	u8 msg[2] = {reg >> 8, reg & 0xff};
+ 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+ 				   .buf  = msg, .len   = 2},
+ 				  {.addr = adr, .flags = I2C_M_RD,
+-				   .buf  = val, .len   = 1} };
++				   .buf  = val, .len   = 1 } };
+ 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+ }
+ 
++static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr,
++			   u16 reg, u8 val)
++{
++	u8 msg[3] = {reg >> 8, reg & 0xff, val};
++
++	return i2c_write(adap, adr, msg, 3);
++}
++
+ static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
+ {
+ 	struct ddb *dev = i2c->dev;
+@@ -85,18 +160,18 @@ static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
+ 	u32 val;
+ 
+ 	i2c->done = 0;
+-	ddbwritel((adr << 9) | cmd, i2c->regs + I2C_COMMAND);
++	ddbwritel(dev, (adr << 9) | cmd, i2c->regs + I2C_COMMAND);
+ 	stat = wait_event_timeout(i2c->wq, i2c->done == 1, HZ);
+ 	if (stat <= 0) {
+ 		printk(KERN_ERR "I2C timeout\n");
+ 		{ /* MSI debugging*/
+-			u32 istat = ddbreadl(INTERRUPT_STATUS);
++			u32 istat = ddbreadl(dev, INTERRUPT_STATUS);
+ 			printk(KERN_ERR "IRS %08x\n", istat);
+-			ddbwritel(istat, INTERRUPT_ACK);
++			ddbwritel(dev, istat, INTERRUPT_ACK);
+ 		}
+ 		return -EIO;
+ 	}
+-	val = ddbreadl(i2c->regs+I2C_COMMAND);
++	val = ddbreadl(dev, i2c->regs+I2C_COMMAND);
+ 	if (val & 0x70000)
+ 		return -EIO;
+ 	return 0;
+@@ -105,7 +180,7 @@ static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
+ static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
+ 			       struct i2c_msg msg[], int num)
+ {
+-	struct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);
++	struct ddb_i2c *i2c = (struct ddb_i2c *) i2c_get_adapdata(adapter);
+ 	struct ddb *dev = i2c->dev;
+ 	u8 addr = 0;
+ 
+@@ -116,8 +191,8 @@ static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
+ 	    !(msg[0].flags & I2C_M_RD)) {
+ 		memcpy_toio(dev->regs + I2C_TASKMEM_BASE + i2c->wbuf,
+ 			    msg[0].buf, msg[0].len);
+-		ddbwritel(msg[0].len|(msg[1].len << 16),
+-			  i2c->regs+I2C_TASKLENGTH);
++		ddbwritel(dev, msg[0].len|(msg[1].len << 16),
++			  i2c->regs + I2C_TASKLENGTH);
+ 		if (!ddb_i2c_cmd(i2c, addr, 1)) {
+ 			memcpy_fromio(msg[1].buf,
+ 				      dev->regs + I2C_TASKMEM_BASE + i2c->rbuf,
+@@ -125,17 +200,16 @@ static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
+ 			return num;
+ 		}
+ 	}
+-
+ 	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
+-		ddbcpyto(I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
+-		ddbwritel(msg[0].len, i2c->regs + I2C_TASKLENGTH);
++		ddbcpyto(dev, I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
++		ddbwritel(dev, msg[0].len, i2c->regs + I2C_TASKLENGTH);
+ 		if (!ddb_i2c_cmd(i2c, addr, 2))
+ 			return num;
+ 	}
+ 	if (num == 1 && (msg[0].flags & I2C_M_RD)) {
+-		ddbwritel(msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
++		ddbwritel(dev, msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
+ 		if (!ddb_i2c_cmd(i2c, addr, 3)) {
+-			ddbcpyfrom(msg[0].buf,
++			ddbcpyfrom(dev, msg[0].buf,
+ 				   I2C_TASKMEM_BASE + i2c->rbuf, msg[0].len);
+ 			return num;
+ 		}
+@@ -160,7 +234,7 @@ static void ddb_i2c_release(struct ddb *dev)
+ 	struct ddb_i2c *i2c;
+ 	struct i2c_adapter *adap;
+ 
+-	for (i = 0; i < dev->info->port_num; i++) {
++	for (i = 0; i < dev->info->i2c_num; i++) {
+ 		i2c = &dev->i2c[i];
+ 		adap = &i2c->adap;
+ 		i2c_del_adapter(adap);
+@@ -173,15 +247,15 @@ static int ddb_i2c_init(struct ddb *dev)
+ 	struct ddb_i2c *i2c;
+ 	struct i2c_adapter *adap;
+ 
+-	for (i = 0; i < dev->info->port_num; i++) {
++	for (i = 0; i < dev->info->i2c_num; i++) {
+ 		i2c = &dev->i2c[i];
+ 		i2c->dev = dev;
+ 		i2c->nr = i;
+ 		i2c->wbuf = i * (I2C_TASKMEM_SIZE / 4);
+ 		i2c->rbuf = i2c->wbuf + (I2C_TASKMEM_SIZE / 8);
+ 		i2c->regs = 0x80 + i * 0x20;
+-		ddbwritel(I2C_SPEED_100, i2c->regs + I2C_TIMING);
+-		ddbwritel((i2c->rbuf << 16) | i2c->wbuf,
++		ddbwritel(dev, I2C_SPEED_100, i2c->regs + I2C_TIMING);
++		ddbwritel(dev, (i2c->rbuf << 16) | i2c->wbuf,
+ 			  i2c->regs + I2C_TASKADDRESS);
+ 		init_waitqueue_head(&i2c->wq);
+ 
+@@ -216,69 +290,94 @@ static int ddb_i2c_init(struct ddb *dev)
+ /******************************************************************************/
+ /******************************************************************************/
+ 
+-#if 0
+-static void set_table(struct ddb *dev, u32 off,
+-		      dma_addr_t *pbuf, u32 num)
++static void ddb_set_dma_table(struct ddb *dev, struct ddb_dma *dma)
+ {
+ 	u32 i, base;
+ 	u64 mem;
+ 
+-	base = DMA_BASE_ADDRESS_TABLE + off;
+-	for (i = 0; i < num; i++) {
+-		mem = pbuf[i];
+-		ddbwritel(mem & 0xffffffff, base + i * 8);
+-		ddbwritel(mem >> 32, base + i * 8 + 4);
++	if (!dma)
++		return;
++	base = DMA_BASE_ADDRESS_TABLE + dma->nr * 0x100;
++	for (i = 0; i < dma->num; i++) {
++		mem = dma->pbuf[i];
++		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
++		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
+ 	}
++	dma->bufreg = (dma->div << 16) |
++		((dma->num & 0x1f) << 11) |
++		((dma->size >> 7) & 0x7ff);
+ }
+-#endif
+ 
+-static void ddb_address_table(struct ddb *dev)
++static void ddb_set_dma_tables(struct ddb *dev)
+ {
+-	u32 i, j, base;
+-	u64 mem;
+-	dma_addr_t *pbuf;
++	u32 i;
+ 
+-	for (i = 0; i < dev->info->port_num * 2; i++) {
+-		base = DMA_BASE_ADDRESS_TABLE + i * 0x100;
+-		pbuf = dev->input[i].pbuf;
+-		for (j = 0; j < dev->input[i].dma_buf_num; j++) {
+-			mem = pbuf[j];
+-			ddbwritel(mem & 0xffffffff, base + j * 8);
+-			ddbwritel(mem >> 32, base + j * 8 + 4);
+-		}
+-	}
+-	for (i = 0; i < dev->info->port_num; i++) {
+-		base = DMA_BASE_ADDRESS_TABLE + 0x800 + i * 0x100;
+-		pbuf = dev->output[i].pbuf;
+-		for (j = 0; j < dev->output[i].dma_buf_num; j++) {
+-			mem = pbuf[j];
+-			ddbwritel(mem & 0xffffffff, base + j * 8);
+-			ddbwritel(mem >> 32, base + j * 8 + 4);
+-		}
+-	}
++	for (i = 0; i < dev->info->port_num * 2; i++)
++		ddb_set_dma_table(dev, dev->input[i].dma);
++	for (i = 0; i < dev->info->port_num; i++)
++		ddb_set_dma_table(dev, dev->output[i].dma);
+ }
+ 
+-static void io_free(struct pci_dev *pdev, u8 **vbuf,
+-		    dma_addr_t *pbuf, u32 size, int num)
++static void dma_free(struct pci_dev *pdev, struct ddb_dma *dma)
+ {
+ 	int i;
+ 
+-	for (i = 0; i < num; i++) {
+-		if (vbuf[i]) {
+-			pci_free_consistent(pdev, size, vbuf[i], pbuf[i]);
+-			vbuf[i] = 0;
++	if (!dma)
++		return;
++	for (i = 0; i < dma->num; i++) {
++		if (dma->vbuf[i]) {
++			pci_free_consistent(pdev, dma->size,
++					    dma->vbuf[i], dma->pbuf[i]);
++			dma->vbuf[i] = 0;
+ 		}
+ 	}
+ }
+ 
+-static int io_alloc(struct pci_dev *pdev, u8 **vbuf,
+-		    dma_addr_t *pbuf, u32 size, int num)
++static void ddb_redirect_dma(struct ddb *dev,
++			     struct ddb_dma *sdma,
++			     struct ddb_dma *ddma)
++{
++	u32 i, base;
++	u64 mem;
++
++	sdma->bufreg = ddma->bufreg;
++	base = DMA_BASE_ADDRESS_TABLE + sdma->nr * 0x100;
++	for (i = 0; i < ddma->num; i++) {
++		mem = ddma->pbuf[i];
++		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
++		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
++	}
++}
++
++static void ddb_unredirect(struct ddb_port *port)
++{
++	struct ddb_input *ored, *ired;
++
++	ored = port->output->redirect;
++	ired = port->input[0]->redirect;
++
++	if (!ored || !ired)
++		return;
++	if (ired->port->output->redirect == port->input[0]) {
++		ired->port->output->redirect = ored;
++		ddb_set_dma_table(port->dev, port->input[0]->dma);
++		ddb_redirect_dma(ored->port->dev, ored->dma, ired->port->output->dma);
++	} else
++		ddb_set_dma_table(ored->port->dev, ored->dma);
++	ored->redirect = ired;
++	port->input[0]->redirect = 0;
++	port->output->redirect = 0;
++}
++
++static int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma)
+ {
+ 	int i;
+ 
+-	for (i = 0; i < num; i++) {
+-		vbuf[i] = pci_alloc_consistent(pdev, size, &pbuf[i]);
+-		if (!vbuf[i])
++	if (!dma)
++		return 0;
++	for (i = 0; i < dma->num; i++) {
++		dma->vbuf[i] = pci_alloc_consistent(pdev, dma->size, &dma->pbuf[i]);
++		if (!dma->vbuf[i])
+ 			return -ENOMEM;
+ 	}
+ 	return 0;
+@@ -293,34 +392,23 @@ static int ddb_buffers_alloc(struct ddb *dev)
+ 		port = &dev->port[i];
+ 		switch (port->class) {
+ 		case DDB_PORT_TUNER:
+-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
+-				     port->input[0]->pbuf,
+-				     port->input[0]->dma_buf_size,
+-				     port->input[0]->dma_buf_num) < 0)
++			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
+ 				return -1;
+-			if (io_alloc(dev->pdev, port->input[1]->vbuf,
+-				     port->input[1]->pbuf,
+-				     port->input[1]->dma_buf_size,
+-				     port->input[1]->dma_buf_num) < 0)
++			if (dma_alloc(dev->pdev, port->input[1]->dma) < 0)
+ 				return -1;
+ 			break;
+ 		case DDB_PORT_CI:
+-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
+-				     port->input[0]->pbuf,
+-				     port->input[0]->dma_buf_size,
+-				     port->input[0]->dma_buf_num) < 0)
++		case DDB_PORT_LOOP:
++			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
+ 				return -1;
+-			if (io_alloc(dev->pdev, port->output->vbuf,
+-				     port->output->pbuf,
+-				     port->output->dma_buf_size,
+-				     port->output->dma_buf_num) < 0)
++			if (dma_alloc(dev->pdev, port->output->dma) < 0)
+ 				return -1;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+-	ddb_address_table(dev);
++	ddb_set_dma_tables(dev);
+ 	return 0;
+ }
+ 
+@@ -331,18 +419,11 @@ static void ddb_buffers_free(struct ddb *dev)
+ 
+ 	for (i = 0; i < dev->info->port_num; i++) {
+ 		port = &dev->port[i];
+-		io_free(dev->pdev, port->input[0]->vbuf,
+-			port->input[0]->pbuf,
+-			port->input[0]->dma_buf_size,
+-			port->input[0]->dma_buf_num);
+-		io_free(dev->pdev, port->input[1]->vbuf,
+-			port->input[1]->pbuf,
+-			port->input[1]->dma_buf_size,
+-			port->input[1]->dma_buf_num);
+-		io_free(dev->pdev, port->output->vbuf,
+-			port->output->pbuf,
+-			port->output->dma_buf_size,
+-			port->output->dma_buf_num);
++
++		ddb_unredirect(port);
++		dma_free(dev->pdev, port->input[0]->dma);
++		dma_free(dev->pdev, port->input[1]->dma);
++		dma_free(dev->pdev, port->output->dma);
+ 	}
+ }
+ 
+@@ -350,90 +431,116 @@ static void ddb_input_start(struct ddb_input *input)
+ {
+ 	struct ddb *dev = input->port->dev;
+ 
+-	spin_lock_irq(&input->lock);
+-	input->cbuf = 0;
+-	input->coff = 0;
++	spin_lock_irq(&input->dma->lock);
++	input->dma->cbuf = 0;
++	input->dma->coff = 0;
+ 
+ 	/* reset */
+-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+-	ddbwritel(2, TS_INPUT_CONTROL(input->nr));
+-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
++	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
++	ddbwritel(dev, 2, TS_INPUT_CONTROL(input->nr));
++	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
+ 
+-	ddbwritel((1 << 16) |
+-		  (input->dma_buf_num << 11) |
+-		  (input->dma_buf_size >> 7),
+-		  DMA_BUFFER_SIZE(input->nr));
+-	ddbwritel(0, DMA_BUFFER_ACK(input->nr));
++	ddbwritel(dev, input->dma->bufreg, DMA_BUFFER_SIZE(input->dma->nr));
++	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
+ 
+-	ddbwritel(1, DMA_BASE_WRITE);
+-	ddbwritel(3, DMA_BUFFER_CONTROL(input->nr));
+-	ddbwritel(9, TS_INPUT_CONTROL(input->nr));
+-	input->running = 1;
+-	spin_unlock_irq(&input->lock);
++	ddbwritel(dev, 1, DMA_BASE_WRITE);
++	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(input->dma->nr));
++	ddbwritel(dev, 9, TS_INPUT_CONTROL(input->nr));
++	input->dma->running = 1;
++	spin_unlock_irq(&input->dma->lock);
++	/* printk(KERN_INFO "input_start %d\n", input->nr); */
+ }
+ 
+ static void ddb_input_stop(struct ddb_input *input)
+ {
+ 	struct ddb *dev = input->port->dev;
+ 
+-	spin_lock_irq(&input->lock);
+-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+-	ddbwritel(0, DMA_BUFFER_CONTROL(input->nr));
+-	input->running = 0;
+-	spin_unlock_irq(&input->lock);
++	spin_lock_irq(&input->dma->lock);
++	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
++	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma->nr));
++	input->dma->running = 0;
++	spin_unlock_irq(&input->dma->lock);
+ }
+ 
+ static void ddb_output_start(struct ddb_output *output)
+ {
+ 	struct ddb *dev = output->port->dev;
+ 
+-	spin_lock_irq(&output->lock);
+-	output->cbuf = 0;
+-	output->coff = 0;
+-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+-	ddbwritel(2, TS_OUTPUT_CONTROL(output->nr));
+-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+-	ddbwritel(0x3c, TS_OUTPUT_CONTROL(output->nr));
+-	ddbwritel((1 << 16) |
+-		  (output->dma_buf_num << 11) |
+-		  (output->dma_buf_size >> 7),
+-		  DMA_BUFFER_SIZE(output->nr + 8));
+-	ddbwritel(0, DMA_BUFFER_ACK(output->nr + 8));
+-
+-	ddbwritel(1, DMA_BASE_READ);
+-	ddbwritel(3, DMA_BUFFER_CONTROL(output->nr + 8));
+-	/* ddbwritel(0xbd, TS_OUTPUT_CONTROL(output->nr)); */
+-	ddbwritel(0x1d, TS_OUTPUT_CONTROL(output->nr));
+-	output->running = 1;
+-	spin_unlock_irq(&output->lock);
++	spin_lock_irq(&output->dma->lock);
++	output->dma->cbuf = 0;
++	output->dma->coff = 0;
++	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
++	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(output->nr));
++	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
++	ddbwritel(dev, 0x3c, TS_OUTPUT_CONTROL(output->nr));
++	ddbwritel(dev, output->dma->bufreg, DMA_BUFFER_SIZE(output->dma->nr));
++	ddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma->nr));
++
++	ddbwritel(dev, 1, DMA_BASE_READ);
++	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(output->dma->nr));
++	if (output->port->input[0]->port->class == DDB_PORT_LOOP)
++		ddbwritel(dev, 0x05, TS_OUTPUT_CONTROL(output->nr));
++	else
++		ddbwritel(dev, 0x1d, TS_OUTPUT_CONTROL(output->nr));
++	output->dma->running = 1;
++	spin_unlock_irq(&output->dma->lock);
++	/* printk(KERN_INFO "output_start %d\n", output->nr); */
++}
++
++#if 0
++static void ddb_input_start_all(struct ddb_input *input)
++{
++	struct ddb_input *next;
++
++	ddb_input_start(input);
++	while ((next = input->redirect) &&
++	       next != input) {
++		ddb_input_start(next);
++		ddb_output_start(next->port->output);
++	}
+ }
++#endif
+ 
+ static void ddb_output_stop(struct ddb_output *output)
+ {
+ 	struct ddb *dev = output->port->dev;
+ 
+-	spin_lock_irq(&output->lock);
+-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
+-	ddbwritel(0, DMA_BUFFER_CONTROL(output->nr + 8));
+-	output->running = 0;
+-	spin_unlock_irq(&output->lock);
++	spin_lock_irq(&output->dma->lock);
++	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
++	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma->nr));
++	output->dma->running = 0;
++	spin_unlock_irq(&output->dma->lock);
++}
++
++#if 0
++static void ddb_input_stop_all(struct ddb_input *input)
++{
++	struct ddb_input *next;
++
++	ddb_input_stop(input);
++	while ((next = input->redirect) &&
++	       next != input) {
++		ddb_input_stop(next);
++		ddb_output_stop(next->port->output);
++	}
+ }
++#endif
+ 
+ static u32 ddb_output_free(struct ddb_output *output)
+ {
+-	u32 idx, off, stat = output->stat;
++	u32 idx, off, stat = output->dma->stat;
+ 	s32 diff;
+ 
+ 	idx = (stat >> 11) & 0x1f;
+ 	off = (stat & 0x7ff) << 7;
+ 
+-	if (output->cbuf != idx) {
+-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
+-		    (output->dma_buf_size - output->coff <= 188))
++	if (output->dma->cbuf != idx) {
++		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
++		    (output->dma->size - output->dma->coff <= 188))
+ 			return 0;
+ 		return 188;
+ 	}
+-	diff = off - output->coff;
++	diff = off - output->dma->coff;
+ 	if (diff <= 0 || diff > 188)
+ 		return 188;
+ 	return 0;
+@@ -443,24 +550,24 @@ static ssize_t ddb_output_write(struct ddb_output *output,
+ 				const u8 *buf, size_t count)
+ {
+ 	struct ddb *dev = output->port->dev;
+-	u32 idx, off, stat = output->stat;
++	u32 idx, off, stat = output->dma->stat;
+ 	u32 left = count, len;
+ 
+ 	idx = (stat >> 11) & 0x1f;
+ 	off = (stat & 0x7ff) << 7;
+ 
+ 	while (left) {
+-		len = output->dma_buf_size - output->coff;
+-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
++		len = output->dma->size - output->dma->coff;
++		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
+ 		    (off == 0)) {
+ 			if (len <= 188)
+ 				break;
+ 			len -= 188;
+ 		}
+-		if (output->cbuf == idx) {
+-			if (off > output->coff) {
++		if (output->dma->cbuf == idx) {
++			if (off > output->dma->coff) {
+ #if 1
+-				len = off - output->coff;
++				len = off - output->dma->coff;
+ 				len -= (len % 188);
+ 				if (len <= 188)
+ 
+@@ -471,68 +578,146 @@ static ssize_t ddb_output_write(struct ddb_output *output,
+ 		}
+ 		if (len > left)
+ 			len = left;
+-		if (copy_from_user(output->vbuf[output->cbuf] + output->coff,
++		if (copy_from_user(output->dma->vbuf[output->dma->cbuf] +
++				   output->dma->coff,
+ 				   buf, len))
+ 			return -EIO;
++		/* printk("cfu %d  %d %d\n", len, output->cbuf, output->coff); */
+ 		left -= len;
+ 		buf += len;
+-		output->coff += len;
+-		if (output->coff == output->dma_buf_size) {
+-			output->coff = 0;
+-			output->cbuf = ((output->cbuf + 1) % output->dma_buf_num);
++		output->dma->coff += len;
++		if (output->dma->coff == output->dma->size) {
++			output->dma->coff = 0;
++			output->dma->cbuf = ((output->dma->cbuf + 1) %
++					     output->dma->num);
+ 		}
+-		ddbwritel((output->cbuf << 11) | (output->coff >> 7),
+-			  DMA_BUFFER_ACK(output->nr + 8));
++		ddbwritel(dev, (output->dma->cbuf << 11) | (output->dma->coff >> 7),
++			  DMA_BUFFER_ACK(output->dma->nr));
+ 	}
+ 	return count - left;
+ }
+ 
++#if 0
++static u32 ddb_input_free_bytes(struct ddb_input *input)
++{
++	struct ddb *dev = input->port->dev;
++	u32 idx, off, stat = input->dma->stat;
++	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
++
++	idx = (stat >> 11) & 0x1f;
++	off = (stat & 0x7ff) << 7;
++
++	if (ctrl & 4)
++		return 0;
++	if (input->dma->cbuf != idx)
++		return 1;
++	return 0;
++}
++
++static s32 ddb_output_used_bufs(struct ddb_output *output)
++{
++	u32 idx, off, stat, ctrl;
++	s32 diff;
++
++	spin_lock_irq(&output->dma->lock);
++	stat = output->dma->stat;
++	ctrl = output->dma->ctrl;
++	spin_unlock_irq(&output->dma->lock);
++
++	idx = (stat >> 11) & 0x1f;
++	off = (stat & 0x7ff) << 7;
++
++	if (ctrl & 4)
++		return 0;
++	diff = output->dma->cbuf - idx;
++	if (diff == 0 && off < output->dma->coff)
++		return 0;
++	if (diff <= 0)
++		diff += output->dma->num;
++	return diff;
++}
++
++static s32 ddb_input_free_bufs(struct ddb_input *input)
++{
++	u32 idx, off, stat, ctrl;
++	s32 free;
++
++	spin_lock_irq(&input->dma->lock);
++	ctrl = input->dma->ctrl;
++	stat = input->dma->stat;
++	spin_unlock_irq(&input->dma->lock);
++	if (ctrl & 4)
++		return 0;
++	idx = (stat >> 11) & 0x1f;
++	off = (stat & 0x7ff) << 7;
++	free = input->dma->cbuf - idx;
++	if (free == 0 && off < input->dma->coff)
++		return 0;
++	if (free <= 0)
++		free += input->dma->num;
++	return free - 1;
++}
++
++static u32 ddb_output_ok(struct ddb_output *output)
++{
++	struct ddb_input *input = output->port->input[0];
++	s32 diff;
++
++	diff = ddb_input_free_bufs(input) - ddb_output_used_bufs(output);
++	if (diff > 0)
++		return 1;
++	return 0;
++}
++#endif
++
+ static u32 ddb_input_avail(struct ddb_input *input)
+ {
+ 	struct ddb *dev = input->port->dev;
+-	u32 idx, off, stat = input->stat;
+-	u32 ctrl = ddbreadl(DMA_BUFFER_CONTROL(input->nr));
++	u32 idx, off, stat = input->dma->stat;
++	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
+ 
+ 	idx = (stat >> 11) & 0x1f;
+ 	off = (stat & 0x7ff) << 7;
+ 
+ 	if (ctrl & 4) {
+ 		printk(KERN_ERR "IA %d %d %08x\n", idx, off, ctrl);
+-		ddbwritel(input->stat, DMA_BUFFER_ACK(input->nr));
++		ddbwritel(dev, stat, DMA_BUFFER_ACK(input->dma->nr));
+ 		return 0;
+ 	}
+-	if (input->cbuf != idx)
++	if (input->dma->cbuf != idx || off < input->dma->coff)
+ 		return 188;
+ 	return 0;
+ }
+ 
+-static ssize_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
++static size_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
+ {
+ 	struct ddb *dev = input->port->dev;
+ 	u32 left = count;
+-	u32 idx, free, stat = input->stat;
++	u32 idx, off, free, stat = input->dma->stat;
+ 	int ret;
+ 
+ 	idx = (stat >> 11) & 0x1f;
++	off = (stat & 0x7ff) << 7;
+ 
+ 	while (left) {
+-		if (input->cbuf == idx)
++		if (input->dma->cbuf == idx)
+ 			return count - left;
+-		free = input->dma_buf_size - input->coff;
++		free = input->dma->size - input->dma->coff;
+ 		if (free > left)
+ 			free = left;
+-		ret = copy_to_user(buf, input->vbuf[input->cbuf] +
+-				   input->coff, free);
++		ret = copy_to_user(buf, input->dma->vbuf[input->dma->cbuf] +
++				   input->dma->coff, free);
+ 		if (ret)
+ 			return -EFAULT;
+-		input->coff += free;
+-		if (input->coff == input->dma_buf_size) {
+-			input->coff = 0;
+-			input->cbuf = (input->cbuf+1) % input->dma_buf_num;
++		input->dma->coff += free;
++		if (input->dma->coff == input->dma->size) {
++			input->dma->coff = 0;
++			input->dma->cbuf = (input->dma->cbuf+1) %
++				input->dma->num;
+ 		}
+ 		left -= free;
+-		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
+-			  DMA_BUFFER_ACK(input->nr));
++		ddbwritel(dev, (input->dma->cbuf << 11) | (input->dma->coff >> 7),
++			  DMA_BUFFER_ACK(input->dma->nr));
+ 	}
+ 	return count;
+ }
+@@ -554,7 +739,7 @@ static struct ddb_input *fe2input(struct ddb *dev, struct dvb_frontend *fe)
+ }
+ #endif
+ 
+-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
++static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
+ {
+ 	struct ddb_input *input = fe->sec_priv;
+ 	struct ddb_port *port = input->port;
+@@ -562,9 +747,9 @@ static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
+ 
+ 	if (enable) {
+ 		mutex_lock(&port->i2c_gate_lock);
+-		status = input->gate_ctrl(fe, 1);
++		status = input->dvb.gate_ctrl(fe, 1);
+ 	} else {
+-		status = input->gate_ctrl(fe, 0);
++		status = input->dvb.gate_ctrl(fe, 0);
+ 		mutex_unlock(&port->i2c_gate_lock);
+ 	}
+ 	return status;
+@@ -577,18 +762,88 @@ static int demod_attach_drxk(struct ddb_input *input)
+ 	struct drxk_config config;
+ 
+ 	memset(&config, 0, sizeof(config));
+-	config.microcode_name = "drxk_a3.mc";
+-	config.qam_demod_parameter_count = 4;
+ 	config.adr = 0x29 + (input->nr & 1);
++	config.microcode_name = "drxk_a3.mc";
+ 
+-	fe = input->fe = dvb_attach(drxk_attach, &config, i2c);
+-	if (!input->fe) {
++#ifdef USE_API3
++	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c, &input->dvb.fe2);
++#else
++	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c);
++#endif
++	if (!input->dvb.fe) {
+ 		printk(KERN_ERR "No DRXK found!\n");
+ 		return -ENODEV;
+ 	}
+ 	fe->sec_priv = input;
+-	input->gate_ctrl = fe->ops.i2c_gate_ctrl;
+-	fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
++	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
++	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
++	return 0;
++}
++
++#if 0
++struct stv0367_config stv0367_0 = {
++	.demod_address = 0x1f,
++	.xtal = 27000000,
++	.if_khz = 5000,
++	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
++	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
++	.clk_pol = STV0367_RISINGEDGE_CLOCK,
++};
++
++struct stv0367_config stv0367_1 = {
++	.demod_address = 0x1e,
++	.xtal = 27000000,
++	.if_khz = 5000,
++	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
++	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
++	.clk_pol = STV0367_RISINGEDGE_CLOCK,
++};
++
++
++static int demod_attach_stv0367(struct ddb_input *input)
++{
++	struct i2c_adapter *i2c = &input->port->i2c->adap;
++	struct dvb_frontend *fe;
++
++	fe = input->dvb.fe = dvb_attach(stv0367ter_attach,
++				    (input->nr & 1) ? &stv0367_1 : &stv0367_0,
++				    i2c);
++	if (!input->dvb.fe) {
++		printk(KERN_ERR "No stv0367 found!\n");
++		return -ENODEV;
++	}
++	fe->sec_priv = input;
++	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
++	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
++	return 0;
++}
++#endif
++
++struct stv0367_cfg stv0367dd_0 = {
++	.adr = 0x1f,
++	.xtal = 27000000,
++};
++
++struct stv0367_cfg stv0367dd_1 = {
++	.adr = 0x1e,
++	.xtal = 27000000,
++};
++
++static int demod_attach_stv0367dd(struct ddb_input *input)
++{
++	struct i2c_adapter *i2c = &input->port->i2c->adap;
++	struct dvb_frontend *fe;
++
++	fe = input->dvb.fe = dvb_attach(stv0367_attach, i2c,
++				    (input->nr & 1) ? &stv0367dd_1 : &stv0367dd_0,
++				    &input->dvb.fe2);
++	if (!input->dvb.fe) {
++		printk(KERN_ERR "No stv0367 found!\n");
++		return -ENODEV;
++	}
++	fe->sec_priv = input;
++	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
++	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+ 	return 0;
+ }
+ 
+@@ -597,18 +852,57 @@ static int tuner_attach_tda18271(struct ddb_input *input)
+ 	struct i2c_adapter *i2c = &input->port->i2c->adap;
+ 	struct dvb_frontend *fe;
+ 
+-	if (input->fe->ops.i2c_gate_ctrl)
+-		input->fe->ops.i2c_gate_ctrl(input->fe, 1);
+-	fe = dvb_attach(tda18271c2dd_attach, input->fe, i2c, 0x60);
++	if (input->dvb.fe->ops.i2c_gate_ctrl)
++		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 1);
++	fe = dvb_attach(tda18271c2dd_attach, input->dvb.fe, i2c, 0x60);
++	if (input->dvb.fe->ops.i2c_gate_ctrl)
++		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 0);
+ 	if (!fe) {
+ 		printk(KERN_ERR "No TDA18271 found!\n");
+ 		return -ENODEV;
+ 	}
+-	if (input->fe->ops.i2c_gate_ctrl)
+-		input->fe->ops.i2c_gate_ctrl(input->fe, 0);
+ 	return 0;
+ }
+ 
++static int tuner_attach_tda18212dd(struct ddb_input *input)
++{
++	struct i2c_adapter *i2c = &input->port->i2c->adap;
++	struct dvb_frontend *fe;
++
++	fe = dvb_attach(tda18212dd_attach, input->dvb.fe, i2c,
++			(input->nr & 1) ? 0x63 : 0x60);
++	if (!fe) {
++		printk(KERN_ERR "No TDA18212 found!\n");
++		return -ENODEV;
++	}
++	return 0;
++}
++
++#if 0
++struct tda18212_config tda18212_0 = {
++	.i2c_address = 0x60,
++};
++
++struct tda18212_config tda18212_1 = {
++	.i2c_address = 0x63,
++};
++
++static int tuner_attach_tda18212(struct ddb_input *input)
++{
++	struct i2c_adapter *i2c = &input->port->i2c->adap;
++	struct dvb_frontend *fe;
++	struct tda18212_config *cfg;
++
++	cfg = (input->nr & 1) ? &tda18212_1 : &tda18212_0;
++	fe = dvb_attach(tda18212_attach, input->dvb.fe, i2c, cfg);
++	if (!fe) {
++		printk(KERN_ERR "No TDA18212 found!\n");
++		return -ENODEV;
++	}
++	return 0;
++}
++#endif
++
+ /******************************************************************************/
+ /******************************************************************************/
+ /******************************************************************************/
+@@ -668,14 +962,14 @@ static int demod_attach_stv0900(struct ddb_input *input, int type)
+ 	struct i2c_adapter *i2c = &input->port->i2c->adap;
+ 	struct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;
+ 
+-	input->fe = dvb_attach(stv090x_attach, feconf, i2c,
++	input->dvb.fe = dvb_attach(stv090x_attach, feconf, i2c,
+ 			       (input->nr & 1) ? STV090x_DEMODULATOR_1
+ 			       : STV090x_DEMODULATOR_0);
+-	if (!input->fe) {
++	if (!input->dvb.fe) {
+ 		printk(KERN_ERR "No STV0900 found!\n");
+ 		return -ENODEV;
+ 	}
+-	if (!dvb_attach(lnbh24_attach, input->fe, i2c, 0,
++	if (!dvb_attach(lnbh24_attach, input->dvb.fe, i2c, 0,
+ 			0, (input->nr & 1) ?
+ 			(0x09 - type) : (0x0b - type))) {
+ 		printk(KERN_ERR "No LNBH24 found!\n");
+@@ -692,7 +986,7 @@ static int tuner_attach_stv6110(struct ddb_input *input, int type)
+ 		&stv6110b : &stv6110a;
+ 	struct stv6110x_devctl *ctl;
+ 
+-	ctl = dvb_attach(stv6110x_attach, input->fe, tunerconf, i2c);
++	ctl = dvb_attach(stv6110x_attach, input->dvb.fe, tunerconf, i2c);
+ 	if (!ctl) {
+ 		printk(KERN_ERR "No STV6110X found!\n");
+ 		return -ENODEV;
+@@ -760,10 +1054,10 @@ static int start_feed(struct dvb_demux_feed *dvbdmxfeed)
+ 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
+ 	struct ddb_input *input = dvbdmx->priv;
+ 
+-	if (!input->users)
++	if (!input->dvb.users)
+ 		ddb_input_start(input);
+ 
+-	return ++input->users;
++	return ++input->dvb.users;
+ }
+ 
+ static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+@@ -771,8 +1065,8 @@ static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+ 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
+ 	struct ddb_input *input = dvbdmx->priv;
+ 
+-	if (--input->users)
+-		return input->users;
++	if (--input->dvb.users)
++		return input->dvb.users;
+ 
+ 	ddb_input_stop(input);
+ 	return 0;
+@@ -781,116 +1075,200 @@ static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+ 
+ static void dvb_input_detach(struct ddb_input *input)
+ {
+-	struct dvb_adapter *adap = &input->adap;
+-	struct dvb_demux *dvbdemux = &input->demux;
++	struct dvb_demux *dvbdemux = &input->dvb.demux;
+ 
+-	switch (input->attached) {
++	switch (input->dvb.attached) {
++	case 6:
++		if (input->dvb.fe2)
++			dvb_unregister_frontend(input->dvb.fe2);
++		if (input->dvb.fe)
++			dvb_unregister_frontend(input->dvb.fe);
+ 	case 5:
+-		if (input->fe2)
+-			dvb_unregister_frontend(input->fe2);
+-		if (input->fe) {
+-			dvb_unregister_frontend(input->fe);
+-			dvb_frontend_detach(input->fe);
+-			input->fe = NULL;
+-		}
++		dvb_frontend_detach(input->dvb.fe);
++		input->dvb.fe = NULL;
+ 	case 4:
+-		dvb_net_release(&input->dvbnet);
+-
++		dvb_net_release(&input->dvb.dvbnet);
+ 	case 3:
+ 		dvbdemux->dmx.close(&dvbdemux->dmx);
+ 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
+-					      &input->hw_frontend);
++					      &input->dvb.hw_frontend);
+ 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
+-					      &input->mem_frontend);
+-		dvb_dmxdev_release(&input->dmxdev);
+-
++					      &input->dvb.mem_frontend);
++		dvb_dmxdev_release(&input->dvb.dmxdev);
+ 	case 2:
+-		dvb_dmx_release(&input->demux);
+-
++		dvb_dmx_release(&input->dvb.demux);
+ 	case 1:
+-		dvb_unregister_adapter(adap);
++		break;
+ 	}
+-	input->attached = 0;
++	input->dvb.attached = 0;
+ }
+ 
++static int dvb_register_adapters(struct ddb *dev)
++{
++	int i, ret = 0;
++	struct ddb_port *port;
++	struct dvb_adapter *adap;
++
++	if (adapter_alloc == 3) {
++		port = &dev->port[0];
++		adap = port->input[0]->dvb.adap;
++		ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
++					   &port->dev->pdev->dev,
++					   adapter_nr);
++		if (ret < 0)
++			return ret;
++		port->input[0]->dvb.adap_registered = 1;
++		for (i = 0; i < dev->info->port_num; i++) {
++			port = &dev->port[i];
++			port->input[0]->dvb.adap = adap;
++			port->input[1]->dvb.adap = adap;
++		}
++		return 0;
++	}
++
++	for (i = 0; i < dev->info->port_num; i++) {
++		port = &dev->port[i];
++		switch (port->class) {
++		case DDB_PORT_TUNER:
++			adap = port->input[0]->dvb.adap;
++			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
++						   &port->dev->pdev->dev,
++						   adapter_nr);
++			if (ret < 0)
++				return ret;
++			port->input[0]->dvb.adap_registered = 1;
++
++			if (adapter_alloc > 0) {
++				port->input[1]->dvb.adap = port->input[0]->dvb.adap;
++				break;
++			}
++			adap = port->input[1]->dvb.adap;
++			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
++						   &port->dev->pdev->dev,
++						   adapter_nr);
++			if (ret < 0)
++				return ret;
++			port->input[1]->dvb.adap_registered = 1;
++			break;
++
++		case DDB_PORT_CI:
++		case DDB_PORT_LOOP:
++			adap = port->input[0]->dvb.adap;
++			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
++						   &port->dev->pdev->dev,
++						   adapter_nr);
++			if (ret < 0)
++				return ret;
++			port->input[0]->dvb.adap_registered = 1;
++			break;
++		default:
++			if (adapter_alloc < 2)
++				break;
++			adap = port->input[0]->dvb.adap;
++			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
++						   &port->dev->pdev->dev,
++						   adapter_nr);
++			if (ret < 0)
++				return ret;
++			port->input[0]->dvb.adap_registered = 1;
++			break;
++		}
++	}
++	return ret;
++}
++
++static void dvb_unregister_adapters(struct ddb *dev)
++{
++	int i;
++	struct ddb_port *port;
++	struct ddb_input *input;
++
++	for (i = 0; i < dev->info->port_num; i++) {
++		port = &dev->port[i];
++
++		input = port->input[0];
++		if (input->dvb.adap_registered)
++			dvb_unregister_adapter(input->dvb.adap);
++		input->dvb.adap_registered = 0;
++
++		input = port->input[1];
++		if (input->dvb.adap_registered)
++			dvb_unregister_adapter(input->dvb.adap);
++		input->dvb.adap_registered = 0;
++	}
++}
++
++
+ static int dvb_input_attach(struct ddb_input *input)
+ {
+-	int ret;
++	int ret = 0;
+ 	struct ddb_port *port = input->port;
+-	struct dvb_adapter *adap = &input->adap;
+-	struct dvb_demux *dvbdemux = &input->demux;
+-
+-	ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+-				   &input->port->dev->pdev->dev,
+-				   adapter_nr);
+-	if (ret < 0) {
+-		printk(KERN_ERR "ddbridge: Could not register adapter."
+-		       "Check if you enabled enough adapters in dvb-core!\n");
+-		return ret;
+-	}
+-	input->attached = 1;
++	struct dvb_adapter *adap = input->dvb.adap;
++	struct dvb_demux *dvbdemux = &input->dvb.demux;
++
++	input->dvb.attached = 1;
+ 
+ 	ret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",
+ 				      start_feed,
+ 				      stop_feed, input);
+ 	if (ret < 0)
+ 		return ret;
+-	input->attached = 2;
++	input->dvb.attached = 2;
+ 
+-	ret = my_dvb_dmxdev_ts_card_init(&input->dmxdev, &input->demux,
+-					 &input->hw_frontend,
+-					 &input->mem_frontend, adap);
++	ret = my_dvb_dmxdev_ts_card_init(&input->dvb.dmxdev,
++					 &input->dvb.demux,
++					 &input->dvb.hw_frontend,
++					 &input->dvb.mem_frontend, adap);
+ 	if (ret < 0)
+ 		return ret;
+-	input->attached = 3;
++	input->dvb.attached = 3;
+ 
+-	ret = dvb_net_init(adap, &input->dvbnet, input->dmxdev.demux);
++	ret = dvb_net_init(adap, &input->dvb.dvbnet, input->dvb.dmxdev.demux);
+ 	if (ret < 0)
+ 		return ret;
+-	input->attached = 4;
++	input->dvb.attached = 4;
+ 
+-	input->fe = 0;
++	input->dvb.fe = 0;
+ 	switch (port->type) {
+ 	case DDB_TUNER_DVBS_ST:
+ 		if (demod_attach_stv0900(input, 0) < 0)
+ 			return -ENODEV;
+ 		if (tuner_attach_stv6110(input, 0) < 0)
+ 			return -ENODEV;
+-		if (input->fe) {
+-			if (dvb_register_frontend(adap, input->fe) < 0)
+-				return -ENODEV;
+-		}
+ 		break;
+ 	case DDB_TUNER_DVBS_ST_AA:
+ 		if (demod_attach_stv0900(input, 1) < 0)
+ 			return -ENODEV;
+ 		if (tuner_attach_stv6110(input, 1) < 0)
+ 			return -ENODEV;
+-		if (input->fe) {
+-			if (dvb_register_frontend(adap, input->fe) < 0)
+-				return -ENODEV;
+-		}
+ 		break;
+ 	case DDB_TUNER_DVBCT_TR:
+ 		if (demod_attach_drxk(input) < 0)
+ 			return -ENODEV;
+ 		if (tuner_attach_tda18271(input) < 0)
+ 			return -ENODEV;
+-		if (input->fe) {
+-			if (dvb_register_frontend(adap, input->fe) < 0)
+-				return -ENODEV;
+-		}
+-		if (input->fe2) {
+-			if (dvb_register_frontend(adap, input->fe2) < 0)
+-				return -ENODEV;
+-			input->fe2->tuner_priv = input->fe->tuner_priv;
+-			memcpy(&input->fe2->ops.tuner_ops,
+-			       &input->fe->ops.tuner_ops,
+-			       sizeof(struct dvb_tuner_ops));
+-		}
+ 		break;
++	case DDB_TUNER_DVBCT_ST:
++		if (demod_attach_stv0367dd(input) < 0)
++			return -ENODEV;
++		if (tuner_attach_tda18212dd(input) < 0)
++			return -ENODEV;
++		break;
++	}
++	input->dvb.attached = 5;
++	if (input->dvb.fe) {
++		if (dvb_register_frontend(adap, input->dvb.fe) < 0)
++			return -ENODEV;
+ 	}
+-	input->attached = 5;
++	if (input->dvb.fe2) {
++		if (dvb_register_frontend(adap, input->dvb.fe2) < 0)
++			return -ENODEV;
++		input->dvb.fe2->tuner_priv = input->dvb.fe->tuner_priv;
++		memcpy(&input->dvb.fe2->ops.tuner_ops,
++		       &input->dvb.fe->ops.tuner_ops,
++		       sizeof(struct dvb_tuner_ops));
++	}
++	input->dvb.attached = 6;
+ 	return 0;
+ }
+ 
+@@ -910,7 +1288,8 @@ static ssize_t ts_write(struct file *file, const char *buf,
+ 			if (file->f_flags & O_NONBLOCK)
+ 				break;
+ 			if (wait_event_interruptible(
+-				    output->wq, ddb_output_free(output) >= 188) < 0)
++				    output->dma->wq,
++				    ddb_output_free(output) >= 188) < 0)
+ 				break;
+ 		}
+ 		stat = ddb_output_write(output, buf, left);
+@@ -937,7 +1316,7 @@ static ssize_t ts_read(struct file *file, char *buf,
+ 			if (file->f_flags & O_NONBLOCK)
+ 				break;
+ 			if (wait_event_interruptible(
+-				    input->wq, ddb_input_avail(input) >= 188) < 0)
++				    input->dma->wq, ddb_input_avail(input) >= 188) < 0)
+ 				break;
+ 		}
+ 		read = ddb_input_read(input, buf, left);
+@@ -970,21 +1349,53 @@ static unsigned int ts_poll(struct file *file, poll_table *wait)
+ 	return mask;
+ }
+ 
+-static const struct file_operations ci_fops = {
+-	.owner   = THIS_MODULE,
+-	.read    = ts_read,
+-	.write   = ts_write,
+-	.open    = dvb_generic_open,
+-	.release = dvb_generic_release,
+-	.poll    = ts_poll,
+-	.mmap    = 0,
+-};
+-
++#if 0
++static int ts_release(struct inode *inode, struct file *file)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ddb_output *output = dvbdev->priv;
++	struct ddb_input *input = output->port->input[0];
++
++
++	return dvb_generic_release(inode, file);
++}
++
++static unsigned int ts_open(struct inode *inode, struct file *file)
++{
++	int err;
++	struct dvb_device *dvbdev = file->private_data;
++	struct ddb_output *output = dvbdev->priv;
++	struct ddb_input *input = output->port->input[0];
++
++	err = dvb_generic_open(inode, file);
++	if (err < 0)
++		return err;
++
++#if 0
++	if ((file->f_flags & O_ACCMODE) == O_RDONLY)
++		ddb_input_start(input);
++	else
++		ddb_output_start(output);
++#endif
++	return err;
++}
++#endif
++
++static const struct file_operations ci_fops = {
++	.owner   = THIS_MODULE,
++	.read    = ts_read,
++	.write   = ts_write,
++	.open    = dvb_generic_open,
++	.release = dvb_generic_release,
++	.poll    = ts_poll,
++	.mmap    = 0,
++};
++
+ static struct dvb_device dvbdev_ci = {
+ 	.priv    = 0,
+-	.readers = -1,
+-	.writers = -1,
+-	.users   = -1,
++	.readers = 1,
++	.writers = 1,
++	.users   = 2,
+ 	.fops    = &ci_fops,
+ };
+ 
+@@ -992,53 +1403,297 @@ static struct dvb_device dvbdev_ci = {
+ /****************************************************************************/
+ /****************************************************************************/
+ 
++static int set_redirect(u32 i, u32 p)
++{
++	struct ddb *idev = ddbs[(i >> 4) & 0x1f];
++	struct ddb_input *input;
++	struct ddb *pdev = ddbs[(p >> 4) & 0x1f];
++	struct ddb_port *port;
++
++	if (!idev || !pdev)
++		return -EINVAL;
++
++	port = &pdev->port[p & 3];
++	if (port->class != DDB_PORT_CI && port->class != DDB_PORT_LOOP)
++		return -EINVAL;
++
++	ddb_unredirect(port);
++	if (i == 8)
++		return 0;
++	input = &idev->input[i & 7];
++	if (input->port->class != DDB_PORT_TUNER)
++		port->input[0]->redirect = input->redirect;
++	else
++		port->input[0]->redirect = input;
++	input->redirect = port->input[0];
++	port->output->redirect = input;
++
++	ddb_redirect_dma(input->port->dev, input->dma, port->output->dma);
++	return 0;
++}
++
++static void input_write_output(struct ddb_input *input,
++			       struct ddb_output *output)
++{
++	ddbwritel(output->port->dev,
++		  input->dma->stat, DMA_BUFFER_ACK(output->dma->nr));
++}
++
++static void output_ack_input(struct ddb_output *output,
++			     struct ddb_input *input)
++{
++	ddbwritel(input->port->dev,
++		  output->dma->stat, DMA_BUFFER_ACK(input->dma->nr));
++}
++
++static void input_write_dvb(struct ddb_input *input, struct ddb_dvb *dvb)
++{
++	struct ddb_dma *dma = input->dma;
++	struct ddb *dev = input->port->dev;
++
++	if (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))
++		printk(KERN_ERR "Overflow dma %d\n", dma->nr);
++	while (dma->cbuf != ((dma->stat >> 11) & 0x1f)
++	       || (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))) {
++		dvb_dmx_swfilter_packets(&dvb->demux,
++					 dma->vbuf[dma->cbuf],
++					 dma->size / 188);
++		dma->cbuf = (dma->cbuf + 1) % dma->num;
++		ddbwritel(dev, (dma->cbuf << 11),  DMA_BUFFER_ACK(dma->nr));
++		dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
++	}
++}
++
+ static void input_tasklet(unsigned long data)
+ {
+ 	struct ddb_input *input = (struct ddb_input *) data;
++	struct ddb_dma *dma = input->dma;
+ 	struct ddb *dev = input->port->dev;
+ 
+-	spin_lock(&input->lock);
+-	if (!input->running) {
+-		spin_unlock(&input->lock);
++	spin_lock(&dma->lock);
++	if (!dma->running) {
++		spin_unlock(&dma->lock);
+ 		return;
+ 	}
+-	input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
++	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+ 
+ 	if (input->port->class == DDB_PORT_TUNER) {
+-		if (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))
+-			printk(KERN_ERR "Overflow input %d\n", input->nr);
+-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
+-		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
+-			dvb_dmx_swfilter_packets(&input->demux,
+-						 input->vbuf[input->cbuf],
+-						 input->dma_buf_size / 188);
+-
+-			input->cbuf = (input->cbuf + 1) % input->dma_buf_num;
+-			ddbwritel((input->cbuf << 11),
+-				  DMA_BUFFER_ACK(input->nr));
+-			input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
+-		       }
++		if (input->redirect)
++			input_write_output(input,
++					   input->redirect->port->output);
++		else
++			input_write_dvb(input, &input->dvb);
++	}
++	if (input->port->class == DDB_PORT_CI ||
++	    input->port->class == DDB_PORT_LOOP) {
++		if (input->redirect) {
++			if (input->redirect->port->class == DDB_PORT_TUNER)
++				input_write_dvb(input, &input->redirect->dvb);
++			else
++				input_write_output(input,
++						   input->redirect->port->output);
++		} else
++			wake_up(&dma->wq);
+ 	}
+-	if (input->port->class == DDB_PORT_CI)
+-		wake_up(&input->wq);
+-	spin_unlock(&input->lock);
++	spin_unlock(&dma->lock);
+ }
+ 
+ static void output_tasklet(unsigned long data)
+ {
+ 	struct ddb_output *output = (struct ddb_output *) data;
++	struct ddb_dma *dma = output->dma;
+ 	struct ddb *dev = output->port->dev;
+ 
+-	spin_lock(&output->lock);
+-	if (!output->running) {
+-		spin_unlock(&output->lock);
++	spin_lock(&dma->lock);
++	if (!dma->running) {
++		spin_unlock(&dma->lock);
+ 		return;
+ 	}
+-	output->stat = ddbreadl(DMA_BUFFER_CURRENT(output->nr + 8));
+-	wake_up(&output->wq);
+-	spin_unlock(&output->lock);
++	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
++	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
++	if (output->redirect)
++		output_ack_input(output, output->redirect);
++	wake_up(&dma->wq);
++	spin_unlock(&dma->lock);
++}
++
++#if 0
++static void io_tasklet(unsigned long data)
++{
++	struct ddb_dma *dma = (struct ddb_dma *) data;
++
++	spin_lock(&dma->lock);
++	if (!dma->running) {
++		spin_unlock(&dma->lock);
++		return;
++	}
++	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
++	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
++	if (dma->nr & 8)
++		handle_output((struct ddb_output *) dma->io);
++	else
++		handle_input((struct ddb_input *) dma->io);
++	wake_up(&dma->wq);
++	spin_unlock(&dma->lock);
++}
++#endif
++
++/****************************************************************************/
++/****************************************************************************/
++/****************************************************************************/
++
++static int wait_ci_ready(struct ddb_ci *ci)
++{
++	u32 count = 100;
++
++	do {
++		if (ddbreadl(ci->port->dev,
++			     CI_CONTROL(ci->nr)) & CI_READY)
++			break;
++		msleep(1);
++		if ((--count) == 0)
++			return -1;
++	} while (1);
++	return 0;
++}
++
++static int read_attribute_mem(struct dvb_ca_en50221 *ca,
++			      int slot, int address)
++{
++	struct ddb_ci *ci = ca->data;
++	u32 val, off = (address >> 1) & (CI_BUFFER_SIZE-1);
++
++	if (address > CI_BUFFER_SIZE)
++		return -1;
++	ddbwritel(ci->port->dev, CI_READ_CMD | (1 << 16) | address,
++		  CI_DO_READ_ATTRIBUTES(ci->nr));
++	wait_ci_ready(ci);
++	val = 0xff & ddbreadl(ci->port->dev, CI_BUFFER(ci->nr) + off);
++	/* printk("%04x: %02x\n", address, val); */
++	return val;
++}
++
++static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
++			       int address, u8 value)
++{
++	struct ddb_ci *ci = ca->data;
++
++	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
++		  CI_DO_ATTRIBUTE_RW(ci->nr));
++	wait_ci_ready(ci);
++	return 0;
++}
++
++static int read_cam_control(struct dvb_ca_en50221 *ca,
++			    int slot, u8 address)
++{
++	u32 count = 100;
++	struct ddb_ci *ci = ca->data;
++	u32 res;
++
++	ddbwritel(ci->port->dev, CI_READ_CMD | address,
++		  CI_DO_IO_RW(ci->nr));
++	do {
++		res = ddbreadl(ci->port->dev, CI_READDATA(ci->nr));
++		if (res & CI_READY)
++			break;
++		msleep(1);
++		if ((--count) == 0)
++			return -1;
++	} while (1);
++	return 0xff & res;
++}
++
++static int write_cam_control(struct dvb_ca_en50221 *ca, int slot,
++			     u8 address, u8 value)
++{
++	struct ddb_ci *ci = ca->data;
++
++	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
++		  CI_DO_IO_RW(ci->nr));
++	wait_ci_ready(ci);
++	return 0;
++}
++
++static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
++{
++	struct ddb_ci *ci = ca->data;
++
++	printk(KERN_INFO "slot reset %d\n", ci->nr);
++	ddbwritel(ci->port->dev, CI_POWER_ON,
++		  CI_CONTROL(ci->nr));
++	msleep(300);
++	ddbwritel(ci->port->dev, CI_POWER_ON | CI_RESET_CAM,
++		  CI_CONTROL(ci->nr));
++	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON | CI_RESET_CAM,
++		  CI_CONTROL(ci->nr));
++	udelay(20);
++	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON,
++		  CI_CONTROL(ci->nr));
++	return 0;
++}
++
++static int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
++{
++	struct ddb_ci *ci = ca->data;
++
++	printk(KERN_INFO "slot shutdown\n");
++	ddbwritel(ci->port->dev, 0, CI_CONTROL(ci->nr));
++	return 0;
++}
++
++static int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
++{
++	struct ddb_ci *ci = ca->data;
++	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
++
++	ddbwritel(ci->port->dev, val | CI_BYPASS_DISABLE,
++		  CI_CONTROL(ci->nr));
++	return 0;
++}
++
++static int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)
++{
++	struct ddb_ci *ci = ca->data;
++	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
++	int stat = 0;
++
++	if (val & CI_CAM_DETECT)
++		stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
++	if (val & CI_CAM_READY)
++		stat |= DVB_CA_EN50221_POLL_CAM_READY;
++	return stat;
+ }
+ 
++static struct dvb_ca_en50221 en_templ = {
++	.read_attribute_mem  = read_attribute_mem,
++	.write_attribute_mem = write_attribute_mem,
++	.read_cam_control    = read_cam_control,
++	.write_cam_control   = write_cam_control,
++	.slot_reset          = slot_reset,
++	.slot_shutdown       = slot_shutdown,
++	.slot_ts_enable      = slot_ts_enable,
++	.poll_slot_status    = poll_slot_status,
++};
++
++static void ci_attach(struct ddb_port *port)
++{
++	struct ddb_ci *ci = 0;
++
++	ci = kzalloc(sizeof(*ci), GFP_KERNEL);
++	if (!ci)
++		return;
++	memcpy(&ci->en, &en_templ, sizeof(en_templ));
++	ci->en.data = ci;
++	port->en = &ci->en;
++	ci->port = port;
++	ci->nr = port->nr - 2;
++}
++
++/****************************************************************************/
++/****************************************************************************/
++/****************************************************************************/
++
+ 
+ struct cxd2099_cfg cxd_cfg = {
+ 	.bitrate =  62000,
+@@ -1049,28 +1704,22 @@ struct cxd2099_cfg cxd_cfg = {
+ 
+ static int ddb_ci_attach(struct ddb_port *port)
+ {
+-	int ret;
+-
+-	ret = dvb_register_adapter(&port->output->adap,
+-				   "DDBridge",
+-				   THIS_MODULE,
+-				   &port->dev->pdev->dev,
+-				   adapter_nr);
+-	if (ret < 0)
+-		return ret;
+-	port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
+-	if (!port->en) {
+-		dvb_unregister_adapter(&port->output->adap);
+-		return -ENODEV;
++	if (port->type == DDB_CI_EXTERNAL_SONY) {
++		port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
++		if (!port->en)
++			return -ENODEV;
++		dvb_ca_en50221_init(port->input[0]->dvb.adap,
++				    port->en, 0, 1);
+ 	}
+-	ddb_input_start(port->input[0]);
+-	ddb_output_start(port->output);
+-	dvb_ca_en50221_init(&port->output->adap,
+-			    port->en, 0, 1);
+-	ret = dvb_register_device(&port->output->adap, &port->output->dev,
+-				  &dvbdev_ci, (void *) port->output,
+-				  DVB_DEVICE_SEC);
+-	return ret;
++#if 1
++	if (port->type == DDB_CI_INTERNAL) {
++		ci_attach(port);
++		if (!port->en)
++			return -ENODEV;
++		dvb_ca_en50221_init(port->input[0]->dvb.adap, port->en, 0, 1);
++	}
++#endif
++	return 0;
+ }
+ 
+ static int ddb_port_attach(struct ddb_port *port)
+@@ -1086,6 +1735,15 @@ static int ddb_port_attach(struct ddb_port *port)
+ 		break;
+ 	case DDB_PORT_CI:
+ 		ret = ddb_ci_attach(port);
++		if (ret < 0)
++			break;
++	case DDB_PORT_LOOP:
++		ddb_input_start(port->input[0]);
++		ddb_output_start(port->output);
++		ret = dvb_register_device(port->input[0]->dvb.adap,
++					  &port->input[0]->dvb.dev,
++					  &dvbdev_ci, (void *) port->output,
++					  DVB_DEVICE_SEC);
+ 		break;
+ 	default:
+ 		break;
+@@ -1100,6 +1758,10 @@ static int ddb_ports_attach(struct ddb *dev)
+ 	int i, ret = 0;
+ 	struct ddb_port *port;
+ 
++	ret = dvb_register_adapters(dev);
++	if (ret < 0)
++		return ret;
++
+ 	for (i = 0; i < dev->info->port_num; i++) {
+ 		port = &dev->port[i];
+ 		ret = ddb_port_attach(port);
+@@ -1122,25 +1784,26 @@ static void ddb_ports_detach(struct ddb *dev)
+ 			dvb_input_detach(port->input[1]);
+ 			break;
+ 		case DDB_PORT_CI:
+-			if (port->output->dev)
+-				dvb_unregister_device(port->output->dev);
++		case DDB_PORT_LOOP:
++			if (port->input[0]->dvb.dev)
++				dvb_unregister_device(port->input[0]->dvb.dev);
++			ddb_input_stop(port->input[0]);
++			ddb_output_stop(port->output);
+ 			if (port->en) {
+-				ddb_input_stop(port->input[0]);
+-				ddb_output_stop(port->output);
+ 				dvb_ca_en50221_release(port->en);
+ 				kfree(port->en);
+ 				port->en = 0;
+-				dvb_unregister_adapter(&port->output->adap);
+ 			}
+ 			break;
+ 		}
+ 	}
++	dvb_unregister_adapters(dev);
+ }
+ 
+ /****************************************************************************/
+ /****************************************************************************/
+ 
+-static int port_has_ci(struct ddb_port *port)
++static int port_has_cxd(struct ddb_port *port)
+ {
+ 	u8 val;
+ 	return i2c_read_reg(&port->i2c->adap, 0x40, 0, &val) ? 0 : 1;
+@@ -1172,6 +1835,21 @@ static int port_has_drxks(struct ddb_port *port)
+ 	return 1;
+ }
+ 
++static int port_has_stv0367(struct ddb_port *port)
++{
++	u8 val;
++
++	if (i2c_read_reg16(&port->i2c->adap, 0x1e, 0xf000, &val) < 0)
++		return 0;
++	if (val != 0x60)
++		return 0;
++	if (i2c_read_reg16(&port->i2c->adap, 0x1f, 0xf000, &val) < 0)
++		return 0;
++	if (val != 0x60)
++		return 0;
++	return 1;
++}
++
+ static void ddb_port_probe(struct ddb_port *port)
+ {
+ 	struct ddb *dev = port->dev;
+@@ -1179,62 +1857,92 @@ static void ddb_port_probe(struct ddb_port *port)
+ 
+ 	port->class = DDB_PORT_NONE;
+ 
+-	if (port_has_ci(port)) {
++	if (port->nr > 1 && dev->info->type == DDB_OCTOPUS_CI) {
++		modname = "CI internal";
++		port->class = DDB_PORT_CI;
++		port->type = DDB_CI_INTERNAL;
++	} else if (port_has_cxd(port)) {
+ 		modname = "CI";
+ 		port->class = DDB_PORT_CI;
+-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
++		port->type = DDB_CI_EXTERNAL_SONY;
++		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+ 	} else if (port_has_stv0900(port)) {
+ 		modname = "DUAL DVB-S2";
+ 		port->class = DDB_PORT_TUNER;
+ 		port->type = DDB_TUNER_DVBS_ST;
+-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
++		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+ 	} else if (port_has_stv0900_aa(port)) {
+ 		modname = "DUAL DVB-S2";
+ 		port->class = DDB_PORT_TUNER;
+ 		port->type = DDB_TUNER_DVBS_ST_AA;
+-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
++		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+ 	} else if (port_has_drxks(port)) {
+ 		modname = "DUAL DVB-C/T";
+ 		port->class = DDB_PORT_TUNER;
+ 		port->type = DDB_TUNER_DVBCT_TR;
+-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
++		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
++	} else if (port_has_stv0367(port)) {
++		modname = "DUAL DVB-C/T";
++		port->class = DDB_PORT_TUNER;
++		port->type = DDB_TUNER_DVBCT_ST;
++		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
++	} else if (port->nr == ts_loop) {
++		modname = "TS LOOP";
++		port->class = DDB_PORT_LOOP;
+ 	}
+-	printk(KERN_INFO "Port %d (TAB %d): %s\n",
+-			 port->nr, port->nr+1, modname);
++	printk(KERN_INFO "Port %d (TAB %d): %s\n", port->nr, port->nr+1, modname);
+ }
+ 
+-static void ddb_input_init(struct ddb_port *port, int nr)
++static void ddb_dma_init(struct ddb_dma *dma, int nr, void *io)
++{
++	unsigned long priv = (unsigned long) io;
++
++	dma->io = io;
++	dma->nr = nr;
++	spin_lock_init(&dma->lock);
++	init_waitqueue_head(&dma->wq);
++	if (nr & 8) {
++		tasklet_init(&dma->tasklet, output_tasklet, priv);
++		dma->num = OUTPUT_DMA_BUFS;
++		dma->size = OUTPUT_DMA_SIZE;
++		dma->div = OUTPUT_DMA_IRQ_DIV;
++	} else {
++		tasklet_init(&dma->tasklet, input_tasklet, priv);
++		dma->num = INPUT_DMA_BUFS;
++		dma->size = INPUT_DMA_SIZE;
++		dma->div = INPUT_DMA_IRQ_DIV;
++	}
++}
++
++static void ddb_input_init(struct ddb_port *port, int nr, int pnr)
+ {
+ 	struct ddb *dev = port->dev;
+ 	struct ddb_input *input = &dev->input[nr];
+ 
++	port->input[pnr] = input;
+ 	input->nr = nr;
+ 	input->port = port;
+-	input->dma_buf_num = INPUT_DMA_BUFS;
+-	input->dma_buf_size = INPUT_DMA_SIZE;
+-	ddbwritel(0, TS_INPUT_CONTROL(nr));
+-	ddbwritel(2, TS_INPUT_CONTROL(nr));
+-	ddbwritel(0, TS_INPUT_CONTROL(nr));
+-	ddbwritel(0, DMA_BUFFER_ACK(nr));
+-	tasklet_init(&input->tasklet, input_tasklet, (unsigned long) input);
+-	spin_lock_init(&input->lock);
+-	init_waitqueue_head(&input->wq);
++	input->dma = &dev->dma[nr];
++	ddb_dma_init(input->dma, nr, (void *) input);
++	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
++	ddbwritel(dev, 2, TS_INPUT_CONTROL(nr));
++	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
++	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
++	input->dvb.adap = &dev->adap[input->nr];
+ }
+ 
+ static void ddb_output_init(struct ddb_port *port, int nr)
+ {
+ 	struct ddb *dev = port->dev;
+ 	struct ddb_output *output = &dev->output[nr];
++	port->output = output;
+ 	output->nr = nr;
+ 	output->port = port;
+-	output->dma_buf_num = OUTPUT_DMA_BUFS;
+-	output->dma_buf_size = OUTPUT_DMA_SIZE;
+-
+-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
+-	ddbwritel(2, TS_OUTPUT_CONTROL(nr));
+-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
+-	tasklet_init(&output->tasklet, output_tasklet, (unsigned long) output);
+-	init_waitqueue_head(&output->wq);
++	output->dma = &dev->dma[nr + 8];
++	ddb_dma_init(output->dma, nr + 8, (void *) output);
++	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
++	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(nr));
++	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
+ }
+ 
+ static void ddb_ports_init(struct ddb *dev)
+@@ -1247,14 +1955,16 @@ static void ddb_ports_init(struct ddb *dev)
+ 		port->dev = dev;
+ 		port->nr = i;
+ 		port->i2c = &dev->i2c[i];
+-		port->input[0] = &dev->input[2 * i];
+-		port->input[1] = &dev->input[2 * i + 1];
+-		port->output = &dev->output[i];
+ 
+ 		mutex_init(&port->i2c_gate_lock);
+ 		ddb_port_probe(port);
+-		ddb_input_init(port, 2 * i);
+-		ddb_input_init(port, 2 * i + 1);
++		if (i >= 2 && dev->info->type == DDB_OCTOPUS_CI) {
++			ddb_input_init(port, 2 + i, 0);
++			ddb_input_init(port, 4 + i, 1);
++		} else {
++			ddb_input_init(port, 2 * i, 0);
++			ddb_input_init(port, 2 * i + 1, 1);
++		}
+ 		ddb_output_init(port, i);
+ 	}
+ }
+@@ -1267,9 +1977,12 @@ static void ddb_ports_release(struct ddb *dev)
+ 	for (i = 0; i < dev->info->port_num; i++) {
+ 		port = &dev->port[i];
+ 		port->dev = dev;
+-		tasklet_kill(&port->input[0]->tasklet);
+-		tasklet_kill(&port->input[1]->tasklet);
+-		tasklet_kill(&port->output->tasklet);
++		if (port->input[0])
++			tasklet_kill(&port->input[0]->dma->tasklet);
++		if (port->input[1])
++			tasklet_kill(&port->input[1]->dma->tasklet);
++		if (port->output)
++			tasklet_kill(&port->output->dma->tasklet);
+ 	}
+ }
+ 
+@@ -1288,13 +2001,18 @@ static void irq_handle_i2c(struct ddb *dev, int n)
+ static irqreturn_t irq_handler(int irq, void *dev_id)
+ {
+ 	struct ddb *dev = (struct ddb *) dev_id;
+-	u32 s = ddbreadl(INTERRUPT_STATUS);
++	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
+ 
+ 	if (!s)
+ 		return IRQ_NONE;
+ 
+ 	do {
+-		ddbwritel(s, INTERRUPT_ACK);
++		ddbwritel(dev, s, INTERRUPT_ACK);
++
++		if (s & 0x0000000f)
++			dev->i2c_irq++;
++		if (s & 0x000fff00)
++			dev->ts_irq++;
+ 
+ 		if (s & 0x00000001)
+ 			irq_handle_i2c(dev, 0);
+@@ -1306,33 +2024,32 @@ static irqreturn_t irq_handler(int irq, void *dev_id)
+ 			irq_handle_i2c(dev, 3);
+ 
+ 		if (s & 0x00000100)
+-			tasklet_schedule(&dev->input[0].tasklet);
++			tasklet_schedule(&dev->dma[0].tasklet);
+ 		if (s & 0x00000200)
+-			tasklet_schedule(&dev->input[1].tasklet);
++			tasklet_schedule(&dev->dma[1].tasklet);
+ 		if (s & 0x00000400)
+-			tasklet_schedule(&dev->input[2].tasklet);
++			tasklet_schedule(&dev->dma[2].tasklet);
+ 		if (s & 0x00000800)
+-			tasklet_schedule(&dev->input[3].tasklet);
++			tasklet_schedule(&dev->dma[3].tasklet);
+ 		if (s & 0x00001000)
+-			tasklet_schedule(&dev->input[4].tasklet);
++			tasklet_schedule(&dev->dma[4].tasklet);
+ 		if (s & 0x00002000)
+-			tasklet_schedule(&dev->input[5].tasklet);
++			tasklet_schedule(&dev->dma[5].tasklet);
+ 		if (s & 0x00004000)
+-			tasklet_schedule(&dev->input[6].tasklet);
++			tasklet_schedule(&dev->dma[6].tasklet);
+ 		if (s & 0x00008000)
+-			tasklet_schedule(&dev->input[7].tasklet);
+-
++			tasklet_schedule(&dev->dma[7].tasklet);
+ 		if (s & 0x00010000)
+-			tasklet_schedule(&dev->output[0].tasklet);
++			tasklet_schedule(&dev->dma[8].tasklet);
+ 		if (s & 0x00020000)
+-			tasklet_schedule(&dev->output[1].tasklet);
++			tasklet_schedule(&dev->dma[9].tasklet);
+ 		if (s & 0x00040000)
+-			tasklet_schedule(&dev->output[2].tasklet);
++			tasklet_schedule(&dev->dma[10].tasklet);
+ 		if (s & 0x00080000)
+-			tasklet_schedule(&dev->output[3].tasklet);
++			tasklet_schedule(&dev->dma[11].tasklet);
+ 
+-		/* if (s & 0x000f0000)	printk(KERN_DEBUG "%08x\n", istat); */
+-	} while ((s = ddbreadl(INTERRUPT_STATUS)));
++		/* if (s & 0x000f0000)	printk("%08x\n", istat); */
++	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
+ 
+ 	return IRQ_HANDLED;
+ }
+@@ -1346,21 +2063,21 @@ static int flashio(struct ddb *dev, u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)
+ 	u32 data, shift;
+ 
+ 	if (wlen > 4)
+-		ddbwritel(1, SPI_CONTROL);
++		ddbwritel(dev, 1, SPI_CONTROL);
+ 	while (wlen > 4) {
+ 		/* FIXME: check for big-endian */
+ 		data = swab32(*(u32 *)wbuf);
+ 		wbuf += 4;
+ 		wlen -= 4;
+-		ddbwritel(data, SPI_DATA);
+-		while (ddbreadl(SPI_CONTROL) & 0x0004)
++		ddbwritel(dev, data, SPI_DATA);
++		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+ 			;
+ 	}
+ 
+ 	if (rlen)
+-		ddbwritel(0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
++		ddbwritel(dev, 0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+ 	else
+-		ddbwritel(0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
++		ddbwritel(dev, 0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+ 
+ 	data = 0;
+ 	shift = ((4 - wlen) * 8);
+@@ -1372,33 +2089,33 @@ static int flashio(struct ddb *dev, u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)
+ 	}
+ 	if (shift)
+ 		data <<= shift;
+-	ddbwritel(data, SPI_DATA);
+-	while (ddbreadl(SPI_CONTROL) & 0x0004)
++	ddbwritel(dev, data, SPI_DATA);
++	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+ 		;
+ 
+ 	if (!rlen) {
+-		ddbwritel(0, SPI_CONTROL);
++		ddbwritel(dev, 0, SPI_CONTROL);
+ 		return 0;
+ 	}
+ 	if (rlen > 4)
+-		ddbwritel(1, SPI_CONTROL);
++		ddbwritel(dev, 1, SPI_CONTROL);
+ 
+ 	while (rlen > 4) {
+-		ddbwritel(0xffffffff, SPI_DATA);
+-		while (ddbreadl(SPI_CONTROL) & 0x0004)
++		ddbwritel(dev, 0xffffffff, SPI_DATA);
++		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+ 			;
+-		data = ddbreadl(SPI_DATA);
++		data = ddbreadl(dev, SPI_DATA);
+ 		*(u32 *) rbuf = swab32(data);
+ 		rbuf += 4;
+ 		rlen -= 4;
+ 	}
+-	ddbwritel(0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
+-	ddbwritel(0xffffffff, SPI_DATA);
+-	while (ddbreadl(SPI_CONTROL) & 0x0004)
++	ddbwritel(dev, 0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
++	ddbwritel(dev, 0xffffffff, SPI_DATA);
++	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
+ 		;
+ 
+-	data = ddbreadl(SPI_DATA);
+-	ddbwritel(0, SPI_CONTROL);
++	data = ddbreadl(dev, SPI_DATA);
++	ddbwritel(dev, 0, SPI_CONTROL);
+ 
+ 	if (rlen < 4)
+ 		data <<= ((4 - rlen) * 8);
+@@ -1421,14 +2138,21 @@ struct ddb_flashio {
+ 	__u32 read_len;
+ };
+ 
++struct ddb_gpio {
++	__u32 mask;
++	__u32 data;
++};
++
++
+ #define IOCTL_DDB_FLASHIO  _IOWR(DDB_MAGIC, 0x00, struct ddb_flashio)
++#define IOCTL_DDB_GPIO_IN  _IOWR(DDB_MAGIC, 0x01, struct ddb_gpio)
++#define IOCTL_DDB_GPIO_OUT _IOWR(DDB_MAGIC, 0x02, struct ddb_gpio)
+ 
+ #define DDB_NAME "ddbridge"
+ 
+ static u32 ddb_num;
+-static struct ddb *ddbs[32];
+-static struct class *ddb_class;
+ static int ddb_major;
++static DEFINE_MUTEX(ddb_mutex);
+ 
+ static int ddb_open(struct inode *inode, struct file *file)
+ {
+@@ -1470,6 +2194,16 @@ static long ddb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ 			return -EFAULT;
+ 		break;
+ 	}
++	case IOCTL_DDB_GPIO_OUT:
++	{
++		struct ddb_gpio gpio;
++		if (copy_from_user(&gpio, parg, sizeof(gpio)))
++			break;
++		ddbwritel(dev, gpio.mask, GPIO_DIRECTION);
++		ddbwritel(dev, gpio.data, GPIO_OUTPUT);
++		res = 0;
++		break;
++	}
+ 	default:
+ 		return -ENOTTY;
+ 	}
+@@ -1481,52 +2215,336 @@ static const struct file_operations ddb_fops = {
+ 	.open           = ddb_open,
+ };
+ 
+-static char *ddb_devnode(struct device *device, umode_t *mode)
++static char *ddb_devnode(struct device *device, mode_t *mode)
+ {
+ 	struct ddb *dev = dev_get_drvdata(device);
+ 
+ 	return kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);
+ }
+ 
++static ssize_t ports_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++
++	return sprintf(buf, "%d\n", dev->info->port_num);
++}
++
++static ssize_t ts_irq_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++
++	return sprintf(buf, "%d\n", dev->ts_irq);
++}
++
++static ssize_t i2c_irq_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++
++	return sprintf(buf, "%d\n", dev->i2c_irq);
++}
++
++static char *class_name[] = {
++	"NONE", "CI", "TUNER", "LOOP"
++};
++
++static char *type_name[] = {
++	"NONE", "DVBS_ST", "DVBS_ST_AA", "DVBCT_TR", "DVBCT_ST", "INTERNAL", "CXD2099",
++};
++
++static ssize_t fan_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	u32 val;
++
++	val = ddbreadl(dev, GPIO_OUTPUT) & 1;
++	return sprintf(buf, "%d\n", val);
++}
++
++static ssize_t fan_store(struct device *device, struct device_attribute *d,
++			 const char *buf, size_t count)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	unsigned val;
++
++	if (sscanf(buf, "%u\n", &val) != 1)
++		return -EINVAL;
++	ddbwritel(dev, 1, GPIO_DIRECTION);
++	ddbwritel(dev, val & 1, GPIO_OUTPUT);
++	return count;
++}
++
++static ssize_t temp_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	int temp;
++	u8 tmp[2];
++
++	if (!dev->info->temp_num)
++		return sprintf(buf, "no sensor\n");
++	if (i2c_read_regs(&dev->i2c[0].adap, 0x48, 0, tmp, 2) < 0)
++		return sprintf(buf, "read_error\n");
++	temp = (tmp[0] << 3) | (tmp[1] >> 5);
++	temp *= 125;
++	return sprintf(buf, "%d\n", temp);
++}
++
++static ssize_t mod_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	int num = attr->attr.name[3] - 0x30;
++
++	return sprintf(buf, "%s:%s\n",
++		       class_name[dev->port[num].class],
++		       type_name[dev->port[num].type]);
++}
++
++static ssize_t led_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	int num = attr->attr.name[3] - 0x30;
++
++	return sprintf(buf, "%d\n", dev->leds & (1 << num) ? 1 : 0);
++}
++
++
++static void ddb_set_led(struct ddb *dev, int num, int val)
++{
++	if (!dev->info->led_num)
++		return;
++	switch (dev->port[num].class) {
++	case DDB_PORT_TUNER:
++		switch (dev->port[num].type) {
++		case DDB_TUNER_DVBS_ST:
++			printk(KERN_INFO "LED %d %d\n", num, val);
++			i2c_write_reg16(&dev->i2c[num].adap,
++					0x69, 0xf14c, val ? 2 : 0);
++			break;
++		case DDB_TUNER_DVBCT_ST:
++			printk(KERN_INFO "LED %d %d\n", num, val);
++			i2c_write_reg16(&dev->i2c[num].adap,
++					0x1f, 0xf00e, 0);
++			i2c_write_reg16(&dev->i2c[num].adap,
++					0x1f, 0xf00f, val ? 1 : 0);
++			break;
++		}
++		break;
++	default:
++		break;
++	}
++}
++
++static ssize_t led_store(struct device *device, struct device_attribute *attr,
++			 const char *buf, size_t count)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	int num = attr->attr.name[3] - 0x30;
++	unsigned val;
++
++	if (sscanf(buf, "%u\n", &val) != 1)
++		return -EINVAL;
++	if (val)
++		dev->leds |= (1 << num);
++	else
++		dev->leds &= ~(1 << num);
++	ddb_set_led(dev, num, val);
++	return count;
++}
++
++static ssize_t snr_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	char snr[32];
++	int num = attr->attr.name[3] - 0x30;
++
++	/* serial number at 0x100-0x11f */
++	if (i2c_read_regs16(&dev->i2c[num].adap, 0x57, 0x100, snr, 32) < 0)
++		return sprintf(buf, "NO SNR\n");
++	snr[31] = 0; /* in case it is not terminated on EEPROM */
++	return sprintf(buf, "%s\n", snr);
++}
++
++
++static ssize_t snr_store(struct device *device, struct device_attribute *attr,
++			 const char *buf, size_t count)
++{
++	struct ddb *dev = dev_get_drvdata(device);
++	int num = attr->attr.name[3] - 0x30;
++	u8 snr[34] = { 0x01, 0x00 };
++
++	if (count > 31)
++		return -EINVAL;
++	memcpy(snr + 2, buf, count);
++	i2c_write(&dev->i2c[num].adap, 0x57, snr, 34);
++	return count;
++}
++
++static ssize_t redirect_show(struct device *device, struct device_attribute *attr, char *buf)
++{
++	return 0;
++}
++
++static ssize_t redirect_store(struct device *device, struct device_attribute *attr,
++			      const char *buf, size_t count)
++{
++	unsigned int i, p;
++	int res;
++
++	if (sscanf(buf, "%x %x\n", &i, &p) != 2)
++		return -EINVAL;
++	printk(KERN_INFO "redirect: %02x, %02x\n", i, p);
++	res = set_redirect(i, p);
++	if (res < 0)
++		return res;
++	return count;
++}
++
++#define __ATTR_MRO(_name, _show) {				\
++	.attr	= { .name = __stringify(_name), .mode = 0444 },	\
++	.show	= _show,					\
++}
++
++struct device_attribute ddb_attrs[] = {
++	__ATTR_RO(ports),
++	__ATTR_RO(ts_irq),
++	__ATTR_RO(i2c_irq),
++	__ATTR(redirect, 0666, redirect_show, redirect_store),
++	__ATTR_NULL
++};
++
++static struct device_attribute ddb_mod[] = {
++	__ATTR_MRO(mod0, mod_show),
++	__ATTR_MRO(mod1, mod_show),
++	__ATTR_MRO(mod2, mod_show),
++	__ATTR_MRO(mod3, mod_show),
++};
++
++static struct device_attribute ddb_temp =
++	__ATTR_RO(temp);
++
++static struct device_attribute ddb_fan =
++	__ATTR(fan, 0666, fan_show, fan_store);
++
++static struct device_attribute ddb_led[] = {
++	__ATTR(led0, 0666, led_show, led_store),
++	__ATTR(led1, 0666, led_show, led_store),
++	__ATTR(led2, 0666, led_show, led_store),
++	__ATTR(led3, 0666, led_show, led_store),
++};
++
++static struct device_attribute ddb_snr[] = {
++	__ATTR(snr0, 0666, snr_show, snr_store),
++	__ATTR(snr1, 0666, snr_show, snr_store),
++	__ATTR(snr2, 0666, snr_show, snr_store),
++	__ATTR(snr3, 0666, snr_show, snr_store),
++};
++
++static struct class ddb_class = {
++	.name		= "ddbridge",
++	.owner          = THIS_MODULE,
++	.dev_attrs	= ddb_attrs,
++	.devnode        = ddb_devnode,
++};
++
+ static int ddb_class_create(void)
+ {
+ 	ddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);
+ 	if (ddb_major < 0)
+ 		return ddb_major;
+-
+-	ddb_class = class_create(THIS_MODULE, DDB_NAME);
+-	if (IS_ERR(ddb_class)) {
+-		unregister_chrdev(ddb_major, DDB_NAME);
+-		return PTR_ERR(ddb_class);
+-	}
+-	ddb_class->devnode = ddb_devnode;
++	if (class_register(&ddb_class) < 0)
++		return -1;
+ 	return 0;
+ }
+ 
+ static void ddb_class_destroy(void)
+ {
+-	class_destroy(ddb_class);
++	class_unregister(&ddb_class);
+ 	unregister_chrdev(ddb_major, DDB_NAME);
+ }
+ 
++static int ddb_device_files_create(struct ddb *dev)
++{
++	int i, error = 0;
++
++	if (dev->info->temp_num > 0)
++		error = device_create_file(dev->ddb_dev, &ddb_temp);
++
++	if (!error && dev->info->fan_num > 0)
++		error = device_create_file(dev->ddb_dev, &ddb_fan);
++
++	for (i = 0; !error && (i < dev->info->led_num); i++)
++		error = device_create_file(dev->ddb_dev, &ddb_led[i]);
++
++	for (i = 0; !error && (i < dev->info->port_num); i++)
++		error = device_create_file(dev->ddb_dev, &ddb_mod[i]);
++
++	for (i = 0; !error && (i < dev->info->i2c_num); i++)
++		error = device_create_file(dev->ddb_dev, &ddb_snr[i]);
++
++	return error;
++}
++
++static void ddb_device_files_delete(struct ddb *dev)
++{
++	int i;
++
++	if (dev->info->temp_num > 0)
++		device_remove_file(dev->ddb_dev, &ddb_temp);
++
++	if (dev->info->fan_num > 0)
++		device_remove_file(dev->ddb_dev, &ddb_fan);
++
++	for (i = 0; i < dev->info->led_num; i++)
++		device_remove_file(dev->ddb_dev, &ddb_led[i]);
++
++	for (i = 0; i < dev->info->port_num; i++)
++		device_remove_file(dev->ddb_dev, &ddb_mod[i]);
++
++	for (i = 0; i < dev->info->i2c_num; i++)
++		device_remove_file(dev->ddb_dev, &ddb_snr[i]);
++}
++
+ static int ddb_device_create(struct ddb *dev)
+ {
++	int error = -1;
++
++	mutex_lock(&ddb_mutex);
+ 	dev->nr = ddb_num++;
+-	dev->ddb_dev = device_create(ddb_class, NULL,
++	ddbs[dev->nr] = dev;
++	mutex_unlock(&ddb_mutex);
++	dev->ddb_dev = device_create(&ddb_class, &dev->pdev->dev,
+ 				     MKDEV(ddb_major, dev->nr),
+ 				     dev, "ddbridge%d", dev->nr);
+-	ddbs[dev->nr] = dev;
+-	if (IS_ERR(dev->ddb_dev))
+-		return -1;
++	if (IS_ERR(dev->ddb_dev)) {
++		printk(KERN_ERR ": Could not create ddbridge device\n");
++		goto fail1;
++	}
++	error = ddb_device_files_create(dev);
++	if (error) {
++		printk(KERN_ERR ": Could not create ddbridge sysfs files\n");
++		goto fail2;
++	}
++
+ 	return 0;
++
++fail2:
++	ddb_device_files_delete(dev);
++	device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
++
++fail1:
++	mutex_lock(&ddb_mutex);
++	ddb_num--;
++	ddbs[dev->nr] = NULL;
++	mutex_unlock(&ddb_mutex);
++
++	return error;
+ }
+ 
+ static void ddb_device_destroy(struct ddb *dev)
+ {
+-	ddb_num--;
+ 	if (IS_ERR(dev->ddb_dev))
+ 		return;
+-	device_destroy(ddb_class, MKDEV(ddb_major, 0));
++	ddb_device_files_delete(dev);
++	device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
+ }
+ 
+ 
+@@ -1549,7 +2567,7 @@ static void ddb_remove(struct pci_dev *pdev)
+ 	ddb_ports_detach(dev);
+ 	ddb_i2c_release(dev);
+ 
+-	ddbwritel(0, INTERRUPT_ENABLE);
++	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+ 	free_irq(dev->pdev->irq, dev);
+ #ifdef CONFIG_PCI_MSI
+ 	if (dev->msi)
+@@ -1564,7 +2582,6 @@ static void ddb_remove(struct pci_dev *pdev)
+ 	pci_disable_device(pdev);
+ }
+ 
+-
+ static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ {
+ 	struct ddb *dev;
+@@ -1574,10 +2591,9 @@ static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ 	if (pci_enable_device(pdev) < 0)
+ 		return -ENODEV;
+ 
+-	dev = vmalloc(sizeof(struct ddb));
++	dev = vzalloc(sizeof(struct ddb));
+ 	if (dev == NULL)
+ 		return -ENOMEM;
+-	memset(dev, 0, sizeof(struct ddb));
+ 
+ 	dev->pdev = pdev;
+ 	pci_set_drvdata(pdev, dev);
+@@ -1590,7 +2606,8 @@ static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ 		stat = -ENOMEM;
+ 		goto fail;
+ 	}
+-	printk(KERN_INFO "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
++	printk(KERN_INFO "HW %08x REG %08x\n",
++	       ddbreadl(dev, 0), ddbreadl(dev, 4));
+ 
+ #ifdef CONFIG_PCI_MSI
+ 	if (pci_msi_enabled())
+@@ -1606,11 +2623,11 @@ static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ 			   irq_flag, "DDBridge", (void *) dev);
+ 	if (stat < 0)
+ 		goto fail1;
+-	ddbwritel(0, DMA_BASE_WRITE);
+-	ddbwritel(0, DMA_BASE_READ);
+-	ddbwritel(0xffffffff, INTERRUPT_ACK);
+-	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
+-	ddbwritel(0, MSI1_ENABLE);
++	ddbwritel(dev, 0, DMA_BASE_WRITE);
++	ddbwritel(dev, 0, DMA_BASE_READ);
++	ddbwritel(dev, 0xffffffff, INTERRUPT_ACK);
++	ddbwritel(dev, 0x000fff0f, INTERRUPT_ENABLE);
++	ddbwritel(dev, 0, MSI1_ENABLE);
+ 
+ 	if (ddb_i2c_init(dev) < 0)
+ 		goto fail1;
+@@ -1621,7 +2638,14 @@ static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+ 	}
+ 	if (ddb_ports_attach(dev) < 0)
+ 		goto fail3;
+-	ddb_device_create(dev);
++
++	if (ddb_device_create(dev) < 0)
++		goto fail3;
++
++	if (dev->info->fan_num)	{
++		ddbwritel(dev, 1, GPIO_DIRECTION);
++		ddbwritel(dev, 1, GPIO_OUTPUT);
++	}
+ 	return 0;
+ 
+ fail3:
+@@ -1631,11 +2655,14 @@ fail3:
+ fail2:
+ 	printk(KERN_ERR "fail2\n");
+ 	ddb_buffers_free(dev);
++	ddb_i2c_release(dev);
+ fail1:
+ 	printk(KERN_ERR "fail1\n");
++	free_irq(dev->pdev->irq, dev);
++#ifdef CONFIG_PCI_MSI
+ 	if (dev->msi)
+ 		pci_disable_msi(dev->pdev);
+-	free_irq(dev->pdev->irq, dev);
++#endif
+ fail:
+ 	printk(KERN_ERR "fail\n");
+ 	ddb_unmap(dev);
+@@ -1657,23 +2684,78 @@ static struct ddb_info ddb_octopus = {
+ 	.type     = DDB_OCTOPUS,
+ 	.name     = "Digital Devices Octopus DVB adapter",
+ 	.port_num = 4,
++	.i2c_num  = 4,
+ };
+ 
+ static struct ddb_info ddb_octopus_le = {
+ 	.type     = DDB_OCTOPUS,
+ 	.name     = "Digital Devices Octopus LE DVB adapter",
+ 	.port_num = 2,
++	.i2c_num  = 2,
++};
++
++static struct ddb_info ddb_octopus_oem = {
++	.type     = DDB_OCTOPUS,
++	.name     = "Digital Devices Octopus OEM",
++	.port_num = 4,
++	.i2c_num  = 4,
++	.led_num  = 1,
++	.fan_num  = 1,
++	.temp_num = 1,
++};
++
++static struct ddb_info ddb_octopus_mini = {
++	.type     = DDB_OCTOPUS,
++	.name     = "Digital Devices Octopus Mini",
++	.port_num = 4,
++	.i2c_num  = 4,
+ };
+ 
+ static struct ddb_info ddb_v6 = {
+ 	.type     = DDB_OCTOPUS,
+ 	.name     = "Digital Devices Cine S2 V6 DVB adapter",
+ 	.port_num = 3,
++	.i2c_num  = 3,
++};
++
++static struct ddb_info ddb_v6_5 = {
++	.type     = DDB_OCTOPUS,
++	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
++	.port_num = 4,
++	.i2c_num  = 4,
++};
++
++static struct ddb_info ddb_dvbct = {
++	.type     = DDB_OCTOPUS,
++	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
++	.port_num = 3,
++	.i2c_num  = 3,
++};
++
++static struct ddb_info ddb_satixS2v3 = {
++	.type     = DDB_OCTOPUS,
++	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
++	.port_num = 3,
++	.i2c_num  = 3,
++};
++
++static struct ddb_info ddb_ci = {
++	.type     = DDB_OCTOPUS_CI,
++	.name     = "Digital Devices Octopus CI",
++	.port_num = 4,
++	.i2c_num  = 2,
++};
++
++static struct ddb_info ddb_cis = {
++	.type     = DDB_OCTOPUS_CI,
++	.name     = "Digital Devices Octopus CI single",
++	.port_num = 3,
++	.i2c_num  = 2,
+ };
+ 
+ #define DDVID 0xdd01 /* Digital Devices Vendor ID */
+ 
+-#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
++#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) { \
+ 	.vendor      = _vend,    .device    = _dev, \
+ 	.subvendor   = _subvend, .subdevice = _subdev, \
+ 	.driver_data = (unsigned long)&_driverdata }
+@@ -1682,8 +2764,15 @@ static const struct pci_device_id ddb_id_tbl[] = {
+ 	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
+ 	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
+ 	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
+-	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus),
++	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
++	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
+ 	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
++	DDB_ID(DDVID, 0x0003, DDVID, 0x0021, ddb_v6_5),
++	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
++	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
++	DDB_ID(DDVID, 0x0005, DDVID, 0x0004, ddb_octopus),
++	DDB_ID(DDVID, 0x0011, DDVID, 0x0040, ddb_ci),
++	DDB_ID(DDVID, 0x0011, DDVID, 0x0041, ddb_cis),
+ 	/* in case sub-ids got deleted in flash */
+ 	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+ 	{0}
+@@ -1700,18 +2789,16 @@ static struct pci_driver ddb_pci_driver = {
+ 
+ static __init int module_init_ddbridge(void)
+ {
+-	int ret;
++	int stat;
+ 
+ 	printk(KERN_INFO "Digital Devices PCIE bridge driver, "
+ 	       "Copyright (C) 2010-11 Digital Devices GmbH\n");
+-
+-	ret = ddb_class_create();
+-	if (ret < 0)
+-		return ret;
+-	ret = pci_register_driver(&ddb_pci_driver);
+-	if (ret < 0)
++	if (ddb_class_create())
++		return -1;
++	stat = pci_register_driver(&ddb_pci_driver);
++	if (stat < 0)
+ 		ddb_class_destroy();
+-	return ret;
++	return stat;
+ }
+ 
+ static __exit void module_exit_ddbridge(void)
+@@ -1726,4 +2813,4 @@ module_exit(module_exit_ddbridge);
+ MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
+ MODULE_AUTHOR("Ralph Metzler");
+ MODULE_LICENSE("GPL");
+-MODULE_VERSION("0.5");
++MODULE_VERSION("0.8");
+diff --git a/drivers/media/pci/ddbridge/ddbridge-regs.h b/drivers/media/pci/ddbridge/ddbridge-regs.h
+index a3ccb31..46e8a21 100644
+--- a/drivers/media/pci/ddbridge/ddbridge-regs.h
++++ b/drivers/media/pci/ddbridge/ddbridge-regs.h
+@@ -21,11 +21,12 @@
+  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+  */
+ 
+-/* DD-DVBBridgeV1.h 273 2010-09-17 05:03:16Z manfred */
++/* DD-DVBBridgeV1.h 388 2011-07-13 20:47:08Z manfred */
+ 
+ /* Register Definitions */
+ 
+-#define CUR_REGISTERMAP_VERSION 0x10000
++#define CUR_REGISTERMAP_VERSION     0x10003
++#define CUR_REGISTERMAP_VERSION_CI  0x10000
+ 
+ #define HARDWARE_VERSION       0x00
+ #define REGISTERMAP_VERSION    0x04
+@@ -36,8 +37,14 @@
+ #define SPI_CONTROL     0x10
+ #define SPI_DATA        0x14
+ 
+-/* ------------------------------------------------------------------------- */
++/* -------------------------------------------------------------------------- */
++/* GPIO */
++
++#define GPIO_OUTPUT      0x20
++#define GPIO_INPUT       0x24
++#define GPIO_DIRECTION   0x28
+ 
++/* -------------------------------------------------------------------------- */
+ /* Interrupt controller                                     */
+ /* How many MSI's are available depends on HW (Min 2 max 8) */
+ /* How many are usable also depends on Host platform        */
+@@ -149,3 +156,46 @@
+ #define DMA_BASE_ADDRESS_TABLE  (0x2000)
+ #define DMA_BASE_ADDRESS_TABLE_ENTRIES (512)
+ 
++/* -------------------------------------------------------------------------- */
++/* CI Interface (only CI-Bridge) */
++
++#define CI_BASE                     (0x400)
++#define CI_CONTROL(i)               (CI_BASE + (i) * 32 + 0x00)
++
++#define CI_DO_ATTRIBUTE_RW(i)       (CI_BASE + (i) * 32 + 0x04)
++#define CI_DO_IO_RW(i)              (CI_BASE + (i) * 32 + 0x08)
++#define CI_READDATA(i)              (CI_BASE + (i) * 32 + 0x0c)
++#define CI_DO_READ_ATTRIBUTES(i)    (CI_BASE + (i) * 32 + 0x10)
++
++#define CI_RESET_CAM                    (0x00000001)
++#define CI_POWER_ON                     (0x00000002)
++#define CI_ENABLE                       (0x00000004)
++#define CI_BLOCKIO_ENABLE               (0x00000008)
++#define CI_BYPASS_DISABLE               (0x00000010)
++#define CI_DISABLE_AUTO_OFF             (0x00000020)
++
++#define CI_CAM_READY                    (0x00010000)
++#define CI_CAM_DETECT                   (0x00020000)
++#define CI_READY                        (0x80000000)
++#define CI_BLOCKIO_ACTIVE               (0x40000000)
++#define CI_BLOCKIO_RCVDATA              (0x20000000)
++#define CI_BLOCKIO_SEND_PENDING         (0x10000000)
++#define CI_BLOCKIO_SEND_COMPLETE        (0x08000000)
++
++#define CI_READ_CMD                     (0x40000000)
++#define CI_WRITE_CMD                    (0x80000000)
++
++#define CI_BLOCKIO_SEND(i)              (CI_BASE + (i) * 32 + 0x14)
++#define CI_BLOCKIO_RECEIVE(i)           (CI_BASE + (i) * 32 + 0x18)
++
++#define CI_BLOCKIO_SEND_COMMAND         (0x80000000)
++#define CI_BLOCKIO_SEND_COMPLETE_ACK    (0x40000000)
++#define CI_BLOCKIO_RCVDATA_ACK          (0x40000000)
++
++#define CI_BUFFER_BASE                  (0x3000)
++#define CI_BUFFER_SIZE                  (0x0800)
++#define CI_BLOCKIO_BUFFER_SIZE          (CI_BUFFER_SIZE/2)
++
++#define CI_BUFFER(i)                    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
++#define CI_BLOCKIO_RECEIVE_BUFFER(i)    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
++#define CI_BLOCKIO_SEND_BUFFER(i)       (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE + CI_BLOCKIO_BUFFER_SIZE)
+diff --git a/drivers/media/pci/ddbridge/ddbridge.h b/drivers/media/pci/ddbridge/ddbridge.h
+index 8b1b41d..ce2df00 100644
+--- a/drivers/media/pci/ddbridge/ddbridge.h
++++ b/drivers/media/pci/ddbridge/ddbridge.h
+@@ -32,7 +32,10 @@
+ #include <asm/dma.h>
+ #include <linux/dvb/frontend.h>
+ #include <linux/dvb/ca.h>
++#include <linux/dvb/video.h>
++#include <linux/dvb/audio.h>
+ #include <linux/socket.h>
++#include <linux/device.h>
+ 
+ #include "dmxdev.h"
+ #include "dvbdev.h"
+@@ -52,43 +55,53 @@ struct ddb_info {
+ 	int   type;
+ #define DDB_NONE         0
+ #define DDB_OCTOPUS      1
++#define DDB_OCTOPUS_CI   2
+ 	char *name;
+ 	int   port_num;
+-	u32   port_type[DDB_MAX_PORT];
++	int   i2c_num;
++	int   led_num;
++	int   fan_num;
++	int   temp_num;
+ };
+ 
+ /* DMA_SIZE MUST be divisible by 188 and 128 !!! */
+ 
+-#define INPUT_DMA_MAX_BUFS 32      /* hardware table limit */
++#define DMA_MAX_BUFS 32      /* hardware table limit */
++
+ #define INPUT_DMA_BUFS 8
+ #define INPUT_DMA_SIZE (128*47*21)
++#define INPUT_DMA_IRQ_DIV 1
+ 
+-#define OUTPUT_DMA_MAX_BUFS 32
+ #define OUTPUT_DMA_BUFS 8
+ #define OUTPUT_DMA_SIZE (128*47*21)
++#define OUTPUT_DMA_IRQ_DIV 1
+ 
+ struct ddb;
+ struct ddb_port;
+ 
+-struct ddb_input {
+-	struct ddb_port       *port;
++struct ddb_dma {
++	void                  *io;
+ 	u32                    nr;
+-	int                    attached;
+-
+-	dma_addr_t             pbuf[INPUT_DMA_MAX_BUFS];
+-	u8                    *vbuf[INPUT_DMA_MAX_BUFS];
+-	u32                    dma_buf_num;
+-	u32                    dma_buf_size;
++	dma_addr_t             pbuf[DMA_MAX_BUFS];
++	u8                    *vbuf[DMA_MAX_BUFS];
++	u32                    num;
++	u32                    size;
++	u32                    div;
++	u32                    bufreg;
+ 
+ 	struct tasklet_struct  tasklet;
+ 	spinlock_t             lock;
+ 	wait_queue_head_t      wq;
+ 	int                    running;
+ 	u32                    stat;
++	u32                    ctrl;
+ 	u32                    cbuf;
+ 	u32                    coff;
++};
+ 
+-	struct dvb_adapter     adap;
++struct ddb_dvb {
++	struct dvb_adapter    *adap;
++	int                    adap_registered;
+ 	struct dvb_device     *dev;
+ 	struct dvb_frontend   *fe;
+ 	struct dvb_frontend   *fe2;
+@@ -99,32 +112,36 @@ struct ddb_input {
+ 	struct dmx_frontend    mem_frontend;
+ 	int                    users;
+ 	int (*gate_ctrl)(struct dvb_frontend *, int);
++	int                    attached;
+ };
+ 
+-struct ddb_output {
++struct ddb_ci {
++	struct dvb_ca_en50221  en;
+ 	struct ddb_port       *port;
+ 	u32                    nr;
+-	dma_addr_t             pbuf[OUTPUT_DMA_MAX_BUFS];
+-	u8                    *vbuf[OUTPUT_DMA_MAX_BUFS];
+-	u32                    dma_buf_num;
+-	u32                    dma_buf_size;
+-	struct tasklet_struct  tasklet;
+-	spinlock_t             lock;
+-	wait_queue_head_t      wq;
+-	int                    running;
+-	u32                    stat;
+-	u32                    cbuf;
+-	u32                    coff;
++};
+ 
+-	struct dvb_adapter     adap;
+-	struct dvb_device     *dev;
++
++struct ddb_input {
++	struct ddb_port       *port;
++	u32                    nr;
++	struct ddb_dma        *dma;
++	struct ddb_input      *redirect;
++
++	struct ddb_dvb         dvb;
++};
++
++struct ddb_output {
++	struct ddb_port       *port;
++	u32                    nr;
++	struct ddb_dma        *dma;
++	struct ddb_input      *redirect;
+ };
+ 
+ struct ddb_i2c {
+ 	struct ddb            *dev;
+ 	u32                    nr;
+ 	struct i2c_adapter     adap;
+-	struct i2c_adapter     adap2;
+ 	u32                    regs;
+ 	u32                    rbuf;
+ 	u32                    wbuf;
+@@ -141,12 +158,15 @@ struct ddb_port {
+ #define DDB_PORT_NONE           0
+ #define DDB_PORT_CI             1
+ #define DDB_PORT_TUNER          2
++#define DDB_PORT_LOOP           3
+ 	u32                    type;
+ #define DDB_TUNER_NONE          0
+ #define DDB_TUNER_DVBS_ST       1
+ #define DDB_TUNER_DVBS_ST_AA    2
+-#define DDB_TUNER_DVBCT_TR     16
+-#define DDB_TUNER_DVBCT_ST     17
++#define DDB_TUNER_DVBCT_TR      3
++#define DDB_TUNER_DVBCT_ST      4
++#define DDB_CI_INTERNAL         5
++#define DDB_CI_EXTERNAL_SONY    6
+ 	u32                    adr;
+ 
+ 	struct ddb_input      *input[2];
+@@ -161,25 +181,20 @@ struct ddb {
+ 	struct ddb_i2c         i2c[DDB_MAX_I2C];
+ 	struct ddb_input       input[DDB_MAX_INPUT];
+ 	struct ddb_output      output[DDB_MAX_OUTPUT];
++	struct dvb_adapter     adap[DDB_MAX_INPUT];
++	struct ddb_dma         dma[DDB_MAX_INPUT + DDB_MAX_OUTPUT];
+ 
+ 	struct device         *ddb_dev;
+-	int                    nr;
++	u32                    nr;
+ 	u8                     iobuf[1028];
+ 
+ 	struct ddb_info       *info;
+ 	int                    msi;
+-};
+-
+-/****************************************************************************/
+ 
+-#define ddbwritel(_val, _adr)        writel((_val), \
+-				     (char *) (dev->regs+(_adr)))
+-#define ddbreadl(_adr)               readl((char *) (dev->regs+(_adr)))
+-#define ddbcpyto(_adr, _src, _count) memcpy_toio((char *)	\
+-				     (dev->regs+(_adr)), (_src), (_count))
+-#define ddbcpyfrom(_dst, _adr, _count) memcpy_fromio((_dst), (char *) \
+-				       (dev->regs+(_adr)), (_count))
++	u8                     leds;
+ 
+-/****************************************************************************/
++	u32                    ts_irq;
++	u32                    i2c_irq;
++};
+ 
+ #endif
+diff --git a/drivers/media/pci/ngene/Kconfig b/drivers/media/pci/ngene/Kconfig
+index 637d506..14975c7 100644
+--- a/drivers/media/pci/ngene/Kconfig
++++ b/drivers/media/pci/ngene/Kconfig
+@@ -1,13 +1,16 @@
+ config DVB_NGENE
+ 	tristate "Micronas nGene support"
+ 	depends on DVB_CORE && PCI && I2C
+-	select DVB_LNBP21 if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_STV6110x if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_STV090x if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_LGDT330X if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_DRXK if MEDIA_SUBDRV_AUTOSELECT
+-	select DVB_TDA18271C2DD if MEDIA_SUBDRV_AUTOSELECT
+-	select MEDIA_TUNER_MT2131 if MEDIA_SUBDRV_AUTOSELECT
++	select DVB_CXD2099
++	select DVB_LNBP21 if !DVB_FE_CUSTOMISE
++	select DVB_STV6110x if !DVB_FE_CUSTOMISE
++	select DVB_STV090x if !DVB_FE_CUSTOMISE
++	select DVB_LGDT330X if !DVB_FE_CUSTOMISE
++	select DVB_DRXK if !DVB_FE_CUSTOMISE
++	select DVB_TDA18271C2DD if !DVB_FE_CUSTOMISE
++	select DVB_STV0367DD if !DVB_FE_CUSTOMISE
++	select DVB_TDA18212DD if !DVB_FE_CUSTOMISE
++	select MEDIA_TUNER_MT2131 if !MEDIA_TUNER_CUSTOMISE
+ 	---help---
+ 	  Support for Micronas PCI express cards with nGene bridge.
+ 
+diff --git a/drivers/media/pci/ngene/Makefile b/drivers/media/pci/ngene/Makefile
+index 5c0b5d6..42c036a 100644
+--- a/drivers/media/pci/ngene/Makefile
++++ b/drivers/media/pci/ngene/Makefile
+@@ -2,7 +2,8 @@
+ # Makefile for the nGene device driver
+ #
+ 
+-ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-dvb.o
++ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-av.o \
++	ngene-eeprom.o ngene-dvb.o
+ 
+ obj-$(CONFIG_DVB_NGENE) += ngene.o
+ 
+diff --git a/drivers/media/pci/ngene/ngene-av.c b/drivers/media/pci/ngene/ngene-av.c
+new file mode 100644
+index 0000000..a86459e
+--- /dev/null
++++ b/drivers/media/pci/ngene/ngene-av.c
+@@ -0,0 +1,348 @@
++/*
++ * ngene-av.c: nGene PCIe bridge driver - DVB video/audio support
++ *
++ * Copyright (C) 2005-2007 Micronas
++ *
++ * Copyright (C) 2008-2009 Ralph Metzler <rjkm@metzlerbros.de>
++ *                         Modifications for new nGene firmware,
++ *                         support for EEPROM-copying,
++ *                         support for new dual DVB-S2 card prototype
++ *
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 only, as published by the Free Software Foundation.
++ *
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301, USA
++ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
++ */
++
++/* This file provides the support functions for DVB audio/video devices
++   (/dev/dvb/adapter0/[video|audio]), not to be confused with V4L2 support */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/slab.h>
++#include <linux/poll.h>
++#include <linux/io.h>
++#include <asm/div64.h>
++#include <linux/pci.h>
++#include <linux/timer.h>
++#include <linux/version.h>
++#include <linux/byteorder/generic.h>
++#include <linux/firmware.h>
++#include <linux/vmalloc.h>
++
++#include "ngene.h"
++
++#if 0
++
++static void *ain_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
++{
++	struct ngene_channel *chan = priv;
++	struct ngene *dev = chan->dev;
++
++	if (dvb_ringbuffer_free(&dev->ain_rbuf) >= len) {
++		dvb_ringbuffer_write(&dev->ain_rbuf, buf, len);
++		wake_up_interruptible(&dev->ain_rbuf.queue);
++	} else
++		printk(KERN_INFO DEVICE_NAME ": Dropped ain packet.\n");
++
++	return 0;
++}
++
++static void *vcap_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
++{
++
++	struct ngene_channel *chan = priv;
++	struct ngene *dev = chan->dev;
++
++	if (len >= 1920 * 1080)
++		len = 1920 * 1080;
++	if (dvb_ringbuffer_free(&dev->vin_rbuf) >= len) {
++		dvb_ringbuffer_write(&dev->vin_rbuf, buf, len);
++		wake_up_interruptible(&dev->vin_rbuf.queue);
++	} else {
++		;/*printk(KERN_INFO DEVICE_NAME ": Dropped vcap packet.\n"); */
++	}
++	return 0;
++}
++
++static ssize_t audio_write(struct file *file,
++			   const char *buf, size_t count, loff_t *ppos)
++{
++	return -EINVAL;
++}
++
++ssize_t audio_read(struct file *file, char *buf, size_t count, loff_t *ppos)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int left;
++	int avail;
++
++	left = count;
++	while (left) {
++		if (wait_event_interruptible(
++				dev->ain_rbuf.queue,
++				dvb_ringbuffer_avail(&dev->ain_rbuf) > 0) < 0)
++			return -EAGAIN;
++		avail = dvb_ringbuffer_avail(&dev->ain_rbuf);
++		if (avail > left)
++			avail = left;
++		dvb_ringbuffer_read_user(&dev->ain_rbuf, buf, avail);
++		left -= avail;
++		buf += avail;
++	}
++	return count;
++}
++
++static int audio_open(struct inode *inode, struct file *file)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	struct ngene_channel *chan2 = &chan->dev->channel[2];
++	int ret;
++
++	ret = dvb_generic_open(inode, file);
++	if (ret < 0)
++		return ret;
++	dvb_ringbuffer_flush(&dev->ain_rbuf);
++
++	chan2->Capture1Length = MAX_AUDIO_BUFFER_SIZE;
++	chan2->pBufferExchange = ain_exchange;
++	ngene_command_stream_control(chan2->dev, chan2->number, 0x80,
++				     SMODE_AUDIO_CAPTURE, 0);
++	return ret;
++}
++
++static int audio_release(struct inode *inode, struct file *file)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	struct ngene_channel *chan2 = &chan->dev->channel[2];
++
++	ngene_command_stream_control(dev, 2, 0, 0, 0);
++	chan2->pBufferExchange = 0;
++
++	return dvb_generic_release(inode, file);
++}
++
++static const struct file_operations audio_fops = {
++	.owner   = THIS_MODULE,
++	.read    = audio_read,
++	.write   = audio_write,
++	.open    = audio_open,
++	.release = audio_release,
++};
++
++static struct dvb_device dvbdev_audio = {
++	.priv    = 0,
++	.readers = -1,
++	.writers = 1,
++	.users   = 1,
++	.fops    = &audio_fops,
++};
++
++static int video_open(struct inode *inode, struct file *file)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	struct ngene_channel *chan0 = &chan->dev->channel[0];
++	int ret;
++
++	ret = dvb_generic_open(inode, file);
++	if (ret < 0)
++		return ret;
++	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
++		return ret;
++	dvb_ringbuffer_flush(&dev->vin_rbuf);
++
++	chan0->nBytesPerLine = 1920 * 2;
++	chan0->nLines = 540;
++	chan0->Capture1Length = 1920 * 2 * 540;
++	chan0->pBufferExchange = vcap_exchange;
++	chan0->itumode = 2;
++	ngene_command_stream_control(chan0->dev, chan0->number,
++				     0x80, SMODE_VIDEO_CAPTURE, 0);
++	return ret;
++}
++
++static int video_release(struct inode *inode, struct file *file)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	struct ngene_channel *chan0 = &chan->dev->channel[0];
++
++	ngene_command_stream_control(dev, 0, 0, 0, 0);
++	chan0->pBufferExchange = 0;
++
++	return dvb_generic_release(inode, file);
++}
++
++static ssize_t video_write(struct file *file,
++			   const char *buf, size_t count, loff_t *ppos)
++{
++	return -EINVAL;
++}
++
++ssize_t video_read(struct file *file, char *buf, size_t count, loff_t *ppos)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int left, avail;
++
++	left = count;
++	while (left) {
++		if (wait_event_interruptible(
++				dev->vin_rbuf.queue,
++				dvb_ringbuffer_avail(&dev->vin_rbuf) > 0) < 0)
++			return -EAGAIN;
++		avail = dvb_ringbuffer_avail(&dev->vin_rbuf);
++		if (avail > left)
++			avail = left;
++		dvb_ringbuffer_read_user(&dev->vin_rbuf, buf, avail);
++		left -= avail;
++		buf += avail;
++	}
++	return count;
++}
++
++/* Why is this not exported from dvb_core ?!?! */
++
++static int dvb_usercopy2(struct inode *inode, struct file *file,
++			 unsigned int cmd, unsigned long arg,
++			 int (*func)(struct inode *inode, struct file *file,
++				     unsigned int cmd, void *arg))
++{
++	char sbuf[128];
++	void *mbuf = NULL;
++	void *parg = NULL;
++	int  err   = -EINVAL;
++
++	/*  Copy arguments into temp kernel buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_NONE:
++		/*
++		 * For this command, the pointer is actually an integer
++		 * argument.
++		 */
++		parg = (void *)arg;
++		break;
++	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
++	case _IOC_WRITE:
++	case (_IOC_WRITE | _IOC_READ):
++		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
++			parg = sbuf;
++		} else {
++			/* too big to allocate from stack */
++			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
++			if (NULL == mbuf)
++				return -ENOMEM;
++			parg = mbuf;
++		}
++
++		err = -EFAULT;
++		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
++			goto out;
++		break;
++	}
++
++	/* call driver */
++	err = func(inode, file, cmd, parg);
++	if (err == -ENOIOCTLCMD)
++		err = -EINVAL;
++
++	if (err < 0)
++		goto out;
++
++	/*  Copy results into user buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_READ:
++	case (_IOC_WRITE | _IOC_READ):
++		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
++			err = -EFAULT;
++		break;
++	}
++
++out:
++	kfree(mbuf);
++	return err;
++}
++
++static int video_do_ioctl(struct inode *inode, struct file *file,
++			  unsigned int cmd, void *parg)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int ret = 0;
++	unsigned long arg = (unsigned long)parg;
++
++	switch (cmd) {
++	case VIDEO_SET_STREAMTYPE:
++		switch (arg) {
++		case VIDEO_CAP_MPEG2:
++			/* printk(KERN_INFO DEVICE_NAME ": setting MPEG2\n"); */
++			send_cli(dev, "vdec mpeg2\n");
++			break;
++		case VIDEO_CAP_AVC:
++			/* printk(KERN_INFO DEVICE_NAME ": setting H264\n"); */
++			send_cli(dev, "vdec h264\n");
++			break;
++		case VIDEO_CAP_VC1:
++			/* printk(KERN_INFO DEVICE_NAME ": setting VC1\n"); */
++			send_cli(dev, "vdec vc1\n");
++			break;
++		default:
++			ret = -EINVAL;
++			break;
++		}
++		break;
++	default:
++		ret = -ENOIOCTLCMD;
++		return -EINVAL;
++	}
++	return ret;
++}
++
++static int video_ioctl(struct inode *inode, struct file *file,
++		       unsigned int cmd, unsigned long arg)
++{
++	return dvb_usercopy2(inode, file, cmd, arg, video_do_ioctl);
++}
++
++static const struct file_operations video_fops = {
++	.owner   = THIS_MODULE,
++	.read    = video_read,
++	.write   = video_write,
++	.open    = video_open,
++	.release = video_release,
++	.ioctl   = video_ioctl,
++};
++
++static struct dvb_device dvbdev_video = {
++	.priv    = 0,
++	.readers = -1,
++	.writers = 1,
++	.users   = -1,
++	.fops    = &video_fops,
++};
++#endif
+diff --git a/drivers/media/pci/ngene/ngene-cards.c b/drivers/media/pci/ngene/ngene-cards.c
+index 9e82d21..c9b1bd4 100644
+--- a/drivers/media/pci/ngene/ngene-cards.c
++++ b/drivers/media/pci/ngene/ngene-cards.c
+@@ -42,8 +42,8 @@
+ #include "mt2131.h"
+ #include "tda18271c2dd.h"
+ #include "drxk.h"
+-#include "drxd.h"
+-#include "dvb-pll.h"
++#include "tda18212dd.h"
++#include "stv0367dd.h"
+ 
+ 
+ /****************************************************************************/
+@@ -86,8 +86,98 @@
+ 	return 0;
+ }
+ 
++#if 0
++static int tuner_attach_mt2060(struct ngene_channel *chan)
++{
++	struct ngene *dev = chan->dev;
++	void *tconf = dev->card_info->tuner_config[chan->number];
++	u8 drxa = dev->card_info->demoda[chan->number];
++	struct dvb_frontend *fe = chan->fe, *fe2;
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++	fe->misc_priv = chan;
++#else
++	fe->sec_priv = chan;
++#endif
++	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
++
++	dev->card_info->gate_ctrl(fe, 1);
++	fe2 = mt2060_attach(fe, &chan->i2c_adapter, tconf, 1220);
++	dev->card_info->gate_ctrl(fe, 0);
++
++	i2c_write_register(&chan->i2c_adapter, drxa, 3, 4);
++	write_demod(&chan->i2c_adapter, drxa, 0x1012, 15);
++	write_demod(&chan->i2c_adapter, drxa, 0x1007, 0xc27);
++	write_demod(&chan->i2c_adapter, drxa, 0x0020, 0x003);
++
++	return fe2 ? 0 : -ENODEV;
++}
++
++static int tuner_attach_xc3028(struct ngene_channel *chan)
++{
++	struct ngene *dev = chan->dev;
++	void *tconf = dev->card_info->tuner_config[chan->number];
++	struct dvb_frontend *fe = chan->fe, *fe2;
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++	fe->misc_priv = chan;
++#else
++	fe->sec_priv = chan;
++#endif
++	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
++
++	dev->card_info->gate_ctrl(fe, 1);
++	fe2 = xc3028_attach(fe, &chan->i2c_adapter, tconf);
++	dev->card_info->gate_ctrl(fe, 0);
++
++	/*chan->fe->ops.tuner_ops.set_frequency(chan->fe,231250000);*/
++
++	return fe2 ? 0 : -ENODEV;
++}
++
++static int demod_attach_drxd(struct ngene_channel *chan)
++{
++	void *feconf = chan->dev->card_info->fe_config[chan->number];
++
++	chan->fe = drxd_attach(feconf,
++			       chan, &chan->i2c_adapter,
++			       &chan->dev->pci_dev->dev);
++	return (chan->fe) ? 0 : -ENODEV;
++}
++
++static int demod_attach_drxh(struct ngene_channel *chan)
++{
++	void *feconf = chan->dev->card_info->fe_config[chan->number];
++
++	chan->fe = drxh_attach(feconf, chan,
++			       &chan->i2c_adapter, &chan->dev->pci_dev->dev);
++	return (chan->fe) ? 0 : -ENODEV;
++}
++
++static int demod_attach_stb0899(struct ngene_channel *chan)
++{
++	void *feconf = chan->dev->card_info->fe_config[chan->number];
++
++	chan->fe = stb0899_attach(feconf,
++				  chan, &chan->i2c_adapter,
++				  &chan->dev->pci_dev->dev);
++	if (chan->fe) {
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
++		chan->set_tone = chan->fe->ops->set_tone;
++		chan->fe->ops->set_tone = lnbh21_set_tone;
++		chan->fe->ops->set_voltage = lnbh21_set_voltage;
++#else
++		chan->set_tone = chan->fe->ops.set_tone;
++		chan->fe->ops.set_tone = lnbh21_set_tone;
++		chan->fe->ops.set_voltage = lnbh21_set_voltage;
++#endif
++	}
+ 
+-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
++	return (chan->fe) ? 0 : -ENODEV;
++}
++#endif
++
++static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
+ {
+ 	struct ngene_channel *chan = fe->sec_priv;
+ 	int status;
+@@ -121,12 +211,29 @@
+ 	return 0;
+ }
+ 
++static int tuner_attach_tda18212dd(struct ngene_channel *chan)
++{
++	struct i2c_adapter *i2c;
++	struct dvb_frontend *fe;
++
++	i2c = &chan->dev->channel[0].i2c_adapter;
++	fe = dvb_attach(tda18212dd_attach, chan->fe, i2c,
++			(chan->number & 1) ? 0x63 : 0x60);
++	if (!fe) {
++		printk(KERN_ERR "No TDA18212 found!\n");
++		return -ENODEV;
++	}
++	return 0;
++}
++
+ static int tuner_attach_probe(struct ngene_channel *chan)
+ {
+ 	if (chan->demod_type == 0)
+ 		return tuner_attach_stv6110(chan);
+ 	if (chan->demod_type == 1)
+ 		return tuner_attach_tda18271(chan);
++	if (chan->demod_type == 2)
++		return tuner_attach_tda18212dd(chan);
+ 	return -EINVAL;
+ }
+ 
+@@ -218,18 +325,51 @@
+ 	struct drxk_config config;
+ 
+ 	memset(&config, 0, sizeof(config));
+-	config.microcode_name = "drxk_a3.mc";
+-	config.qam_demod_parameter_count = 4;
+ 	config.adr = 0x29 + (chan->number ^ 2);
++	config.microcode_name = "drxk_a3.mc";
+ 
++#ifdef USE_API3
++	chan->fe = dvb_attach(drxk_attach, &config, i2c, &chan->fe2);
++#else
+ 	chan->fe = dvb_attach(drxk_attach, &config, i2c);
++#endif
+ 	if (!chan->fe) {
+ 		printk(KERN_ERR "No DRXK found!\n");
+ 		return -ENODEV;
+ 	}
+ 	chan->fe->sec_priv = chan;
+ 	chan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;
+-	chan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
++	chan->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
++	return 0;
++}
++
++static int port_has_stv0367(struct i2c_adapter *i2c, int port)
++{
++	u8 val;
++
++	if (i2c_read_reg16(i2c, 0x1c + (port ^ 1), 0xf000, &val) < 0)
++		return 0;
++	if (val != 0x60)
++		return 0;
++	return 1;
++}
++
++static int demod_attach_stv0367dd(struct ngene_channel *chan,
++				  struct i2c_adapter *i2c)
++{
++	struct stv0367_cfg cfg;
++
++	memset(&cfg, 0, sizeof cfg);
++	cfg.adr = 0x1c + (chan->number ^ 1);
++
++	chan->fe = dvb_attach(stv0367_attach, i2c, &cfg, &chan->fe2);
++	if (!chan->fe) {
++		printk(KERN_ERR "No stv0367 found!\n");
++		return -ENODEV;
++	}
++	chan->fe->sec_priv = chan;
++	chan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;
++	chan->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+ 	return 0;
+ }
+ 
+@@ -279,6 +419,9 @@
+ 	} else if (port_has_drxk(i2c, chan->number^2)) {
+ 		chan->demod_type = 1;
+ 		demod_attach_drxk(chan, i2c);
++	} else if (port_has_stv0367(i2c, chan->number)) {
++		chan->demod_type = 2;
++		demod_attach_stv0367dd(chan, i2c);
+ 	} else {
+ 		printk(KERN_ERR "No demod found on chan %d\n", chan->number);
+ 		return -ENODEV;
+@@ -315,241 +458,140 @@
+ 	return (chan->fe) ? 0 : -ENODEV;
+ }
+ 
+-static int demod_attach_drxd(struct ngene_channel *chan)
+-{
+-	struct drxd_config *feconf;
+-
+-	feconf = chan->dev->card_info->fe_config[chan->number];
+-
+-	chan->fe = dvb_attach(drxd_attach, feconf, chan,
+-			&chan->i2c_adapter, &chan->dev->pci_dev->dev);
+-	if (!chan->fe) {
+-		pr_err("No DRXD found!\n");
+-		return -ENODEV;
+-	}
+-
+-	if (!dvb_attach(dvb_pll_attach, chan->fe, feconf->pll_address,
+-			&chan->i2c_adapter,
+-			feconf->pll_type)) {
+-		pr_err("No pll(%d) found!\n", feconf->pll_type);
+-		return -ENODEV;
+-	}
+-	return 0;
+-}
+-
+ /****************************************************************************/
+-/* EEPROM TAGS **************************************************************/
++/* Switch control (I2C gates, etc.) *****************************************/
+ /****************************************************************************/
+ 
+-#define MICNG_EE_START      0x0100
+-#define MICNG_EE_END        0x0FF0
+-
+-#define MICNG_EETAG_END0    0x0000
+-#define MICNG_EETAG_END1    0xFFFF
+-
+-/* 0x0001 - 0x000F reserved for housekeeping */
+-/* 0xFFFF - 0xFFFE reserved for housekeeping */
+-
+-/* Micronas assigned tags
+-   EEProm tags for hardware support */
+-
+-#define MICNG_EETAG_DRXD1_OSCDEVIATION  0x1000  /* 2 Bytes data */
+-#define MICNG_EETAG_DRXD2_OSCDEVIATION  0x1001  /* 2 Bytes data */
++#if 0
++static int avf_output(struct ngene_channel *chan, int state)
++{
++	if (chan->dev->card_info->avf[chan->number])
++		i2c_write_register(&chan->i2c_adapter,
++				   chan->dev->card_info->avf[chan->number],
++				   0xf2, state ? 0x89 : 0x80);
++ 	return 0;
++ }
+ 
+-#define MICNG_EETAG_MT2060_1_1STIF      0x1100  /* 2 Bytes data */
+-#define MICNG_EETAG_MT2060_2_1STIF      0x1101  /* 2 Bytes data */
++/* Viper expander: sw11,sw12,sw21,sw22,i2csw1,i2csw2,tsen1,tsen2 */
+ 
+-/* Tag range for OEMs */
++static int exp_set(struct ngene *dev)
++{
++	return i2c_write(&dev->channel[0].i2c_adapter,
++			 dev->card_info->exp, dev->exp_val);
++}
+ 
+-#define MICNG_EETAG_OEM_FIRST  0xC000
+-#define MICNG_EETAG_OEM_LAST   0xFFEF
++static int exp_init(struct ngene *dev)
++{
++	if (!dev->card_info->exp)
++		return 0;
++	dev->exp_val = dev->card_info->exp_init;
++	return exp_set(dev);
++}
+ 
+-static int i2c_write_eeprom(struct i2c_adapter *adapter,
+-			    u8 adr, u16 reg, u8 data)
++static int exp_set_bit(struct ngene *dev, int bit, int val)
+ {
+-	u8 m[3] = {(reg >> 8), (reg & 0xff), data};
+-	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m,
+-			      .len = sizeof(m)};
++	if (val)
++		set_bit(bit, &dev->exp_val);
++	else
++		clear_bit(bit, &dev->exp_val);
++	return exp_set(dev);
++}
+ 
+-	if (i2c_transfer(adapter, &msg, 1) != 1) {
+-		pr_err(DEVICE_NAME ": Error writing EEPROM!\n");
+-		return -EIO;
++static int viper_switch_ctrl(struct ngene_channel *chan, int type, int val)
++{
++	switch (type) {
++	case 0: /* I2C tuner gate on/off */
++		return exp_set_bit(chan->dev, 4 + chan->number, val);
++	case 1: /* Stream: 0=TS 1=ITU */
++		avf_output(chan, val);
++		return exp_set_bit(chan->dev, 6 + chan->number, val);
++	case 2: /* Input: 0=digital 1=analog antenna input */
++		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
++		exp_set_bit(chan->dev, 1 + chan->number * 2, val ? 1 : 0);
++		break;
+ 	}
+ 	return 0;
+ }
+ 
+-static int i2c_read_eeprom(struct i2c_adapter *adapter,
+-			   u8 adr, u16 reg, u8 *data, int len)
++static int viper_switch_ctrl2(struct ngene_channel *chan, int type, int val)
+ {
+-	u8 msg[2] = {(reg >> 8), (reg & 0xff)};
+-	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+-				   .buf = msg, .len = 2 },
+-				  {.addr = adr, .flags = I2C_M_RD,
+-				   .buf = data, .len = len} };
+-
+-	if (i2c_transfer(adapter, msgs, 2) != 2) {
+-		pr_err(DEVICE_NAME ": Error reading EEPROM\n");
+-		return -EIO;
++	switch (type) {
++	case 0: /* I2C tuner gate on/off */
++		return exp_set_bit(chan->dev, 4 + chan->number, val);
++	case 1: /* Stream: 0=TS 1=ITU */
++		avf_output(chan, val);
++		return exp_set_bit(chan->dev, 6 + chan->number, val);
++	case 2: /* Input: 0=digital 1=analog antenna input */
++		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
++		exp_set_bit(chan->dev, 1 + chan->number * 2, 0);
++		break;
+ 	}
+ 	return 0;
+ }
+ 
+-static int ReadEEProm(struct i2c_adapter *adapter,
+-		      u16 Tag, u32 MaxLen, u8 *data, u32 *pLength)
++static int viper_gate_ctrl(struct dvb_frontend *fe, int enable)
+ {
+-	int status = 0;
+-	u16 Addr = MICNG_EE_START, Length, tag = 0;
+-	u8  EETag[3];
+-
+-	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
+-		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
+-			return -1;
+-		tag = (EETag[0] << 8) | EETag[1];
+-		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
+-			return -1;
+-		if (tag == Tag)
+-			break;
+-		Addr += sizeof(u16) + 1 + EETag[2];
+-	}
+-	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
+-		pr_err(DEVICE_NAME
+-		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
+-		       tag, EETag[2]);
+-		return -1;
+-	}
+-	Length = EETag[2];
+-	if (Length > MaxLen)
+-		Length = (u16) MaxLen;
+-	if (Length > 0) {
+-		Addr += sizeof(u16) + 1;
+-		status = i2c_read_eeprom(adapter, 0x50, Addr, data, Length);
+-		if (!status) {
+-			*pLength = EETag[2];
+-#if 0
+-			if (Length < EETag[2])
+-				status = STATUS_BUFFER_OVERFLOW;
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++	struct ngene_channel *chan = fe->misc_priv;
++#else /* Why is there no misc_priv available anymore !?!?! */
++	/* Well, just abuse sec :-) */
++	struct ngene_channel *chan = fe->sec_priv;
+ #endif
+-		}
+-	}
+-	return status;
++	struct ngene *dev = chan->dev;
++
++	return dev->card_info->switch_ctrl(chan, 0, enable);
+ }
+ 
+-static int WriteEEProm(struct i2c_adapter *adapter,
+-		       u16 Tag, u32 Length, u8 *data)
++static int python_switch_ctrl(struct ngene_channel *chan, int type, int val)
+ {
+-	int status = 0;
+-	u16 Addr = MICNG_EE_START;
+-	u8 EETag[3];
+-	u16 tag = 0;
+-	int retry, i;
+-
+-	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
+-		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
+-			return -1;
+-		tag = (EETag[0] << 8) | EETag[1];
+-		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
+-			return -1;
+-		if (tag == Tag)
+-			break;
+-		Addr += sizeof(u16) + 1 + EETag[2];
+-	}
+-	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
+-		pr_err(DEVICE_NAME
+-		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
+-		       tag, EETag[2]);
+-		return -1;
+-	}
+-
+-	if (Length > EETag[2])
+-		return -EINVAL;
+-	/* Note: We write the data one byte at a time to avoid
+-	   issues with page sizes. (which are different for
+-	   each manufacture and eeprom size)
+-	 */
+-	Addr += sizeof(u16) + 1;
+-	for (i = 0; i < Length; i++, Addr++) {
+-		status = i2c_write_eeprom(adapter, 0x50, Addr, data[i]);
+-
+-		if (status)
+-			break;
+-
+-		/* Poll for finishing write cycle */
+-		retry = 10;
+-		while (retry) {
+-			u8 Tmp;
+-
+-			msleep(50);
+-			status = i2c_read_eeprom(adapter, 0x50, Addr, &Tmp, 1);
+-			if (status)
+-				break;
+-			if (Tmp != data[i])
+-				pr_err(DEVICE_NAME
+-				       "eeprom write error\n");
+-			retry -= 1;
+-		}
+-		if (status) {
+-			pr_err(DEVICE_NAME
+-			       ": Timeout polling eeprom\n");
+-			break;
+-		}
++	switch (type) {
++	case 0: /* I2C tuner gate on/off */
++		if (chan->number > 1)
++			return -EINVAL;
++		return ngene_command_gpio_set(chan->dev, 3 + chan->number, val);
++	case 1: /* Stream: 0=TS 1=ITU */
++		avf_output(chan, val);
++		return 0;
+ 	}
+-	return status;
++	return 0;
+ }
+ 
+-static int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data)
++static int viper_reset_xc(struct dvb_frontend *fe)
+ {
+-	int stat;
+-	u8 buf[2];
+-	u32 len = 0;
+-
+-	stat = ReadEEProm(adapter, tag, 2, buf, &len);
+-	if (stat)
+-		return stat;
+-	if (len != 2)
+-		return -EINVAL;
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++	struct ngene_channel *chan = fe->misc_priv;
++#else
++	struct ngene_channel *chan = fe->sec_priv;
++#endif
++	struct ngene *dev = chan->dev;
+ 
+-	*data = (buf[0] << 8) | buf[1];
+-	return 0;
+-}
++	printk(KERN_INFO DEVICE_NAME ": Reset XC3028\n");
+ 
+-static int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data)
+-{
+-	int stat;
+-	u8 buf[2];
++	if (chan->number > 1)
++		return -EINVAL;
+ 
+-	buf[0] = data >> 8;
+-	buf[1] = data & 0xff;
+-	stat = WriteEEProm(adapter, tag, 2, buf);
+-	if (stat)
+-		return stat;
++	ngene_command_gpio_set(dev, 3 + chan->number, 0);
++	msleep(150);
++	ngene_command_gpio_set(dev, 3 + chan->number, 1);
+ 	return 0;
+ }
+ 
+-static s16 osc_deviation(void *priv, s16 deviation, int flag)
++static int python_gate_ctrl(struct dvb_frontend *fe, int enable)
+ {
+-	struct ngene_channel *chan = priv;
+-	struct i2c_adapter *adap = &chan->i2c_adapter;
+-	u16 data = 0;
+-
+-	if (flag) {
+-		data = (u16) deviation;
+-		pr_info(DEVICE_NAME ": write deviation %d\n",
+-		       deviation);
+-		eeprom_write_ushort(adap, 0x1000 + chan->number, data);
+-	} else {
+-		if (eeprom_read_ushort(adap, 0x1000 + chan->number, &data))
+-			data = 0;
+-		pr_info(DEVICE_NAME ": read deviation %d\n",
+-		       (s16) data);
+-	}
++#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
++	struct ngene_channel *chan = fe->misc_priv;
++#else /* Why is there no misc_priv available anymore !?!?! */
++	struct ngene_channel *chan = fe->sec_priv;
++#endif
++	struct ngene *dev = chan->dev;
+ 
+-	return (s16) data;
++	if (chan->number == 0)
++		return ngene_command_gpio_set(dev, 3, enable);
++	if (chan->number == 1)
++		return ngene_command_gpio_set(dev, 4, enable);
++	return -EINVAL;
+ }
+-
+-/****************************************************************************/
+-/* Switch control (I2C gates, etc.) *****************************************/
+-/****************************************************************************/
+-
++#endif
+ 
+ static struct stv090x_config fe_cineS2 = {
+ 	.device         = STV0900,
+@@ -697,14 +739,18 @@
+ 	.fw_version	= 15,
+ };
+ 
++/****************************************************************************/
++
++#if 0
+ static struct drxd_config fe_terratec_dvbt_0 = {
+ 	.index          = 0,
+ 	.demod_address  = 0x70,
+ 	.demod_revision = 0xa2,
+ 	.demoda_address = 0x00,
+ 	.pll_address    = 0x60,
+-	.pll_type       = DVB_PLL_THOMSON_DTT7520X,
++	.pll_type       = DRXD_PLL_DTT7520X,
+ 	.clock          = 20000,
++	.pll_set        = ngene_pll_set_th_dtt7520x,
+ 	.osc_deviation  = osc_deviation,
+ };
+ 
+@@ -714,8 +760,9 @@
+ 	.demod_revision = 0xa2,
+ 	.demoda_address = 0x00,
+ 	.pll_address    = 0x60,
+-	.pll_type       = DVB_PLL_THOMSON_DTT7520X,
++	.pll_type       = DRXD_PLL_DTT7520X,
+ 	.clock          = 20000,
++	.pll_set        = ngene_pll_set_th_dtt7520x,
+ 	.osc_deviation  = osc_deviation,
+ };
+ 
+@@ -730,7 +777,287 @@
+ 
+ /****************************************************************************/
+ 
++static struct mt2060_config tuner_python_0 = {
++	.i2c_address    = 0x60,
++	.clock_out      = 3,
++	.input          = 0
++};
++
++static struct mt2060_config tuner_python_1 = {
++	.i2c_address    = 0x61,
++	.clock_out      = 3,
++	.input          = 1
++};
++
++static struct drxd_config fe_python_0 = {
++	.index          = 0,
++	.demod_address  = 0x71,
++	.demod_revision = 0xb1,
++	.demoda_address = 0x41,
++	.clock          = 16000,
++	.osc_deviation  = osc_deviation,
++};
++
++static struct drxd_config fe_python_1 = {
++	.index          = 1,
++	.demod_address  = 0x70,
++	.demod_revision = 0xb1,
++	.demoda_address = 0x45,
++	.clock          = 16000,
++	.osc_deviation  = osc_deviation,
++};
++
++static struct ngene_info ngene_info_python = {
++	.type           = NGENE_PYTHON,
++	.name           = "Micronas MicPython/Hedgehog Dual DVB-T",
++	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_AIN, NGENE_IO_AIN},
++	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
++	.tuner_attach   = {tuner_attach_mt2060, tuner_attach_mt2060},
++	.fe_config      = {&fe_python_0, &fe_python_1},
++	.tuner_config   = {&tuner_python_0, &tuner_python_1},
++	.avf            = {0x43, 0x47},
++	.msp            = {0x40, 0x42},
++	.demoda         = {0x41, 0x45},
++	.gate_ctrl      = python_gate_ctrl,
++	.switch_ctrl    = python_switch_ctrl,
++};
++
++/****************************************************************************/
++
++static struct drxd_config fe_appb_dvbt_0 = {
++	.index          = 0,
++	.demod_address  = 0x71,
++	.demod_revision = 0xa2,
++	.demoda_address = 0x41,
++	.pll_address    = 0x63,
++	.pll_type       = DRXD_PLL_MT3X0823,
++	.clock          = 20000,
++	.pll_set        = ngene_pll_set_mt_3x0823,
++	.osc_deviation  = osc_deviation,
++};
++
++static struct drxd_config fe_appb_dvbt_1 = {
++	.index          = 1,
++	.demod_address  = 0x70,
++	.demod_revision = 0xa2,
++	.demoda_address = 0x45,
++	.pll_address    = 0x60,
++	.pll_type       = DRXD_PLL_MT3X0823,
++	.clock          = 20000,
++	.pll_set        = ngene_pll_set_mt_3x0823,
++	.osc_deviation  = osc_deviation,
++};
++
++static struct ngene_info ngene_info_appboard = {
++	.type           = NGENE_APP,
++	.name           = "Micronas Application Board Dual DVB-T",
++	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
++	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
++	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
++	.avf            = {0x43, 0x47},
++};
++
++static struct ngene_info ngene_info_appboard_ntsc = {
++	.type           = NGENE_APP,
++	.name           = "Micronas Application Board Dual DVB-T",
++	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
++	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
++	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
++	.avf            = {0x43, 0x47},
++	.ntsc           = 1,
++};
++
++/****************************************************************************/
++
++static struct stb0899_config fe_sidewinder_0 = {
++	.demod_address  = 0x68,
++	.pll_address    = 0x63,
++};
++
++static struct stb0899_config fe_sidewinder_1 = {
++	.demod_address  = 0x6b,
++	.pll_address    = 0x60,
++};
+ 
++static struct ngene_info ngene_info_sidewinder = {
++	.type           = NGENE_SIDEWINDER,
++	.name           = "Micronas MicSquirrel/Sidewinder Dual DVB-S2",
++	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
++	.demod_attach   = {demod_attach_stb0899, demod_attach_stb0899},
++	.fe_config      = {&fe_sidewinder_0, &fe_sidewinder_1},
++	.lnb            = {0x0b, 0x08},
++};
++
++/****************************************************************************/
++/* Yet unnamed S2 card with dual DVB-S2 demod                               */
++/****************************************************************************/
++
++static struct stv0900_config fe_s2_0 = {
++	.addr           = 0x68,
++	.pll            = 0x63,
++	.pll_type       = 0,
++	.nr             = 0,
++};
++
++static struct stv0900_config fe_s2_1 = {
++	.addr           = 0x68,
++	.pll            = 0x60,
++	.pll_type       = 0,
++	.nr             = 1,
++};
++
++static struct ngene_info ngene_info_s2 = {
++	.type           = NGENE_SIDEWINDER,
++	.name           = "S2",
++	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
++			   NGENE_IO_TSIN, NGENE_IO_TSIN},
++	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
++	.fe_config      = {&fe_s2_0, &fe_s2_1},
++	.lnb            = {0x0b, 0x08},
++	.tsf            = {3, 3},
++	.fw_version     = 15,
++};
++
++static struct stv0900_config fe_s2b_0 = {
++	.addr           = 0x68,
++	.pll            = 0x60,
++	.pll_type       = 0x10,
++	.nr             = 0,
++};
++
++static struct stv0900_config fe_s2b_1 = {
++	.addr           = 0x68,
++	.pll            = 0x63,
++	.pll_type       = 0x10,
++	.nr             = 1,
++};
++
++static struct ngene_info ngene_info_s2_b = {
++	.type           = NGENE_SIDEWINDER,
++	.name           = "S2 V2",
++	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
++			   NGENE_IO_TSIN, NGENE_IO_TSIN},
++	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
++	.fe_config      = {&fe_s2b_0, &fe_s2b_1},
++	.lnb            = {0x0b, 0x08},
++	.tsf            = {3, 3},
++	.fw_version     = 17,
++};
++
++/****************************************************************************/
++
++static struct xc3028_config tuner_viper_0 = {
++	.adr            = 0x61,
++	.reset          = viper_reset_xc
++};
++
++static struct xc3028_config tuner_viper_1 = {
++	.adr            = 0x64,
++	.reset          = viper_reset_xc
++};
++
++static struct drxh_config fe_viper_h_0 = {.adr = 0x2b};
++
++static struct drxh_config fe_viper_h_1 = {.adr = 0x29};
++
++static struct drxh_config fe_viper_l_0 = {.adr = 0x2b, .type = 3931};
++
++static struct drxh_config fe_viper_l_1 = {.adr = 0x29, .type = 3931};
++
++static struct ngene_info ngene_info_viper_v1 = {
++	.type           = NGENE_VIPER,
++	.name           = "Micronas MicViper Dual ATSC DRXH",
++	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_AIN, NGENE_IO_AIN},
++	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
++	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
++	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
++	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
++	.avf            = {0x43, 0x47},
++	.msp            = {0x40, 0x42},
++	.exp            = 0x20,
++	.exp_init       = 0xf5,
++	.gate_ctrl      = viper_gate_ctrl,
++	.switch_ctrl    = viper_switch_ctrl,
++	.tsf            = {2, 2},
++};
++
++static struct ngene_info ngene_info_viper_v2 = {
++	.type           = NGENE_VIPER,
++	.name           = "Micronas MicViper Dual ATSC DRXL",
++	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_AIN, NGENE_IO_AIN},
++	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
++	.fe_config      = {&fe_viper_l_0, &fe_viper_l_1},
++	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
++	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
++	.avf            = {0x43, 0x47},
++	.msp            = {0x40, 0x42},
++	.exp            = 0x38,
++	.exp_init       = 0xf5,
++	.gate_ctrl      = viper_gate_ctrl,
++	.switch_ctrl    = viper_switch_ctrl,
++	.tsf            = {2, 2},
++};
++
++/****************************************************************************/
++
++static struct ngene_info ngene_info_vbox_v1 = {
++	.type           = NGENE_VBOX_V1,
++	.name           = "VBox Cat's Eye 164E",
++	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_AIN, NGENE_IO_AIN},
++	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
++	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
++	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
++	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
++	.avf            = {0x43, 0x47},
++	.msp            = {0x40, 0x42},
++	.exp            = 0x20,
++	.exp_init       = 0xf5,
++	.gate_ctrl      = viper_gate_ctrl,
++	.switch_ctrl    = viper_switch_ctrl,
++	.tsf            = {2, 2},
++};
++
++/****************************************************************************/
++
++static struct ngene_info ngene_info_vbox_v2 = {
++	.type           = NGENE_VBOX_V2,
++	.name           = "VBox Cat's Eye 164E",
++	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_TSIN | NGENE_IO_TV,
++			   NGENE_IO_AIN, NGENE_IO_AIN},
++	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
++	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
++	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
++	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
++	.avf            = {0x43, 0x47},
++	.msp            = {0x40, 0x42},
++	.exp            = 0x20,
++	.exp_init       = 0xf5,
++	.gate_ctrl      = viper_gate_ctrl,
++	.switch_ctrl    = viper_switch_ctrl2,
++	.tsf            = {2, 2},
++};
++
++/****************************************************************************/
++
++static struct ngene_info ngene_info_racer = {
++	.type           = NGENE_RACER,
++	.name           = "Micronas MicRacer HDTV Decoder Card",
++	.io_type        = {NGENE_IO_HDTV, NGENE_IO_NONE,
++			   NGENE_IO_AIN, NGENE_IO_NONE,
++			   NGENE_IO_TSOUT},
++	.i2s            = {0, 0, 1, 0},
++	.fw_version     = 17,
++};
++#endif
+ 
+ /****************************************************************************/
+ /* PCI Subsystem ID *********************************************************/
+@@ -744,6 +1071,8 @@
+ /****************************************************************************/
+ 
+ static const struct pci_device_id ngene_id_tbl[] = {
++	NGENE_ID(0x18c3, 0xab04, ngene_info_cineS2),
++	NGENE_ID(0x18c3, 0xab05, ngene_info_cineS2v5),
+ 	NGENE_ID(0x18c3, 0xabc3, ngene_info_cineS2),
+ 	NGENE_ID(0x18c3, 0xabc4, ngene_info_cineS2),
+ 	NGENE_ID(0x18c3, 0xdb01, ngene_info_satixS2),
+@@ -752,7 +1081,32 @@
+ 	NGENE_ID(0x18c3, 0xdd10, ngene_info_duoFlex),
+ 	NGENE_ID(0x18c3, 0xdd20, ngene_info_duoFlex),
+ 	NGENE_ID(0x1461, 0x062e, ngene_info_m780),
++#if 0 /* not (yet?) supported */
++	NGENE_ID(0x18c3, 0x0000, ngene_info_appboard),
++	NGENE_ID(0x18c3, 0x0004, ngene_info_appboard),
++	NGENE_ID(0x18c3, 0x8011, ngene_info_appboard),
++	NGENE_ID(0x18c3, 0x8015, ngene_info_appboard_ntsc),
+ 	NGENE_ID(0x153b, 0x1167, ngene_info_terratec),
++	NGENE_ID(0x18c3, 0x0030, ngene_info_python),
++	NGENE_ID(0x18c3, 0x0052, ngene_info_sidewinder),
++	NGENE_ID(0x18c3, 0x8f00, ngene_info_racer),
++	NGENE_ID(0x18c3, 0x0041, ngene_info_viper_v1),
++	NGENE_ID(0x18c3, 0x0042, ngene_info_viper_v2),
++	NGENE_ID(0x14f3, 0x0041, ngene_info_vbox_v1),
++	NGENE_ID(0x14f3, 0x0043, ngene_info_vbox_v2),
++	NGENE_ID(0x18c3, 0xabcd, ngene_info_s2),
++	NGENE_ID(0x18c3, 0xabc2, ngene_info_s2_b),
++	NGENE_ID(0x18c3, 0xabc3, ngene_info_s2_b),
++	NGENE_ID(0x18c3, 0x0001, ngene_info_appboard),
++	NGENE_ID(0x18c3, 0x0005, ngene_info_appboard),
++	NGENE_ID(0x18c3, 0x0009, ngene_info_appboard_atsc),
++	NGENE_ID(0x18c3, 0x000b, ngene_info_appboard_atsc),
++	NGENE_ID(0x18c3, 0x0010, ngene_info_shrek_50_fp),
++	NGENE_ID(0x18c3, 0x0011, ngene_info_shrek_60_fp),
++	NGENE_ID(0x18c3, 0x0012, ngene_info_shrek_50),
++	NGENE_ID(0x18c3, 0x0013, ngene_info_shrek_60),
++	NGENE_ID(0x18c3, 0x0000, ngene_info_hognose),
++#endif
+ 	{0}
+ };
+ MODULE_DEVICE_TABLE(pci, ngene_id_tbl);
+@@ -789,7 +1143,7 @@
+ 	printk(KERN_INFO DEVICE_NAME ": resume\n");
+ }
+ 
+-static const struct pci_error_handlers ngene_errors = {
++static struct pci_error_handlers ngene_errors = {
+ 	.error_detected = ngene_error_detected,
+ 	.link_reset = ngene_link_reset,
+ 	.slot_reset = ngene_slot_reset,
+diff --git a/drivers/media/pci/ngene/ngene-core.c b/drivers/media/pci/ngene/ngene-core.c
+index 37ebc42..84510db 100644
+--- a/drivers/media/pci/ngene/ngene-core.c
++++ b/drivers/media/pci/ngene/ngene-core.c
+@@ -86,6 +86,14 @@ static void event_tasklet(unsigned long data)
+ 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
+ 			dev->RxEventNotify(dev, Event.TimeStamp,
+ 					   Event.RXCharacter);
++#if 0
++		if ((Event.GPIOStatus & 0x80) && (dev->Gpio2EventNotify))
++			dev->Gpio2EventNotify(dev, Event.TimeStamp,
++					      Event.GPIOStatus & 0x1f);
++		if ((Event.GPIOStatus & 0x40) && (dev->Gpio3EventNotify))
++			dev->Gpio3EventNotify(dev, Event.TimeStamp,
++					      Event.GPIOStatus & 0x1f);
++#endif
+ 	}
+ }
+ 
+@@ -214,6 +222,13 @@ static irqreturn_t irq_handler(int irq, void *dev_id)
+ 		u8 nextWriteIndex =
+ 			(dev->EventQueueWriteIndex + 1) &
+ 			(EVENT_QUEUE_SIZE - 1);
++#if 0
++		printk(KERN_ERR DEVICE_NAME
++		       ": Event interrupt %02x Uart = %02x Gpio = %02x\n",
++		       dev->EventBuffer->EventStatus,
++		       dev->EventBuffer->UARTStatus,
++		       dev->EventBuffer->GPIOStatus);
++#endif
+ 		if (nextWriteIndex != dev->EventQueueReadIndex) {
+ 			dev->EventQueue[dev->EventQueueWriteIndex] =
+ 				*(dev->EventBuffer);
+@@ -258,16 +273,22 @@ static void dump_command_io(struct ngene *dev)
+ 	u8 buf[8], *b;
+ 
+ 	ngcpyfrom(buf, HOST_TO_NGENE, 8);
+-	printk(KERN_ERR "host_to_ngene (%04x): %*ph\n", HOST_TO_NGENE, 8, buf);
++	printk(KERN_ERR "host_to_ngene (%04x): %02x %02x %02x %02x %02x %02x %02x %02x\n",
++		HOST_TO_NGENE, buf[0], buf[1], buf[2], buf[3],
++		buf[4], buf[5], buf[6], buf[7]);
+ 
+ 	ngcpyfrom(buf, NGENE_TO_HOST, 8);
+-	printk(KERN_ERR "ngene_to_host (%04x): %*ph\n", NGENE_TO_HOST, 8, buf);
++	printk(KERN_ERR "ngene_to_host (%04x): %02x %02x %02x %02x %02x %02x %02x %02x\n",
++		NGENE_TO_HOST, buf[0], buf[1], buf[2], buf[3],
++		buf[4], buf[5], buf[6], buf[7]);
+ 
+ 	b = dev->hosttongene;
+-	printk(KERN_ERR "dev->hosttongene (%p): %*ph\n", b, 8, b);
++	printk(KERN_ERR "dev->hosttongene (%p): %02x %02x %02x %02x %02x %02x %02x %02x\n",
++		b, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
+ 
+ 	b = dev->ngenetohost;
+-	printk(KERN_ERR "dev->ngenetohost (%p): %*ph\n", b, 8, b);
++	printk(KERN_ERR "dev->ngenetohost (%p): %02x %02x %02x %02x %02x %02x %02x %02x\n",
++		b, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
+ }
+ 
+ static int ngene_command_mutex(struct ngene *dev, struct ngene_command *com)
+@@ -316,12 +337,24 @@ static int ngene_command_mutex(struct ngene *dev, struct ngene_command *com)
+ 	ngwritel(1, FORCE_INT);
+ 
+ 	ret = wait_event_timeout(dev->cmd_wq, dev->cmd_done == 1, 2 * HZ);
++#if 0
++	if (ret < 0)
++		return ret;
++	if (!dev->cmd_done)
++		;
++#endif
+ 	if (!ret) {
+ 		/*ngwritel(0, FORCE_NMI);*/
+ 
+ 		printk(KERN_ERR DEVICE_NAME
+ 		       ": Command timeout cmd=%02x prev=%02x\n",
+ 		       com->cmd.hdr.Opcode, dev->prev_cmd);
++#if 0
++		printk(KERN_ERR DEVICE_NAME ": Icounts=%08x\n",
++		       ngreadl(NGENE_INT_COUNTS));
++		if (ngreadl(NGENE_INT_COUNTS) == 0xffffffff)
++			ngwritel(0, NGENE_INT_ENABLE);
++#endif
+ 		dump_command_io(dev);
+ 		return -1;
+ 	}
+@@ -348,6 +381,19 @@ int ngene_command(struct ngene *dev, struct ngene_command *com)
+ 	return result;
+ }
+ 
++#if 0
++int ngene_command_nop(struct ngene *dev)
++{
++	struct ngene_command com;
++
++	com.cmd.hdr.Opcode = CMD_NOP;
++	com.cmd.hdr.Length = 0;
++	com.in_len = 0;
++	com.out_len = 0;
++
++	return ngene_command(dev, &com);
++}
++#endif
+ 
+ static int ngene_command_load_firmware(struct ngene *dev,
+ 				       u8 *ngene_fw, u32 size)
+@@ -382,6 +428,83 @@ static int ngene_command_load_firmware(struct ngene *dev,
+ 	return ngene_command(dev, &com);
+ }
+ 
++#if 0
++int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type)
++{
++	struct ngene_command com;
++
++	com.cmd.hdr.Opcode = type ? CMD_SFR_READ : CMD_IRAM_READ;
++	com.cmd.hdr.Length = 1;
++	com.cmd.SfrIramRead.address = adr;
++	com.in_len = 1;
++	com.out_len = 2;
++
++	if (ngene_command(dev, &com) < 0)
++		return -EIO;
++
++	*data = com.cmd.raw8[1];
++	return 0;
++}
++
++int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type)
++{
++	struct ngene_command com;
++
++	com.cmd.hdr.Opcode = type ? CMD_SFR_WRITE : CMD_IRAM_WRITE;
++	com.cmd.hdr.Length = 2;
++	com.cmd.SfrIramWrite.address = adr;
++	com.cmd.SfrIramWrite.data = data;
++	com.in_len = 2;
++	com.out_len = 1;
++
++	if (ngene_command(dev, &com) < 0)
++		return -EIO;
++
++	return 0;
++}
++
++static int ngene_command_config_uart(struct ngene *dev, u8 config,
++				     tx_cb_t *tx_cb, rx_cb_t *rx_cb)
++{
++	struct ngene_command com;
++
++	com.cmd.hdr.Opcode = CMD_CONFIGURE_UART;
++	com.cmd.hdr.Length = sizeof(struct FW_CONFIGURE_UART) - 2;
++	com.cmd.ConfigureUart.UartControl = config;
++	com.in_len = sizeof(struct FW_CONFIGURE_UART);
++	com.out_len = 0;
++
++	if (ngene_command(dev, &com) < 0)
++		return -EIO;
++
++	dev->TxEventNotify = tx_cb;
++	dev->RxEventNotify = rx_cb;
++
++	dprintk(KERN_DEBUG DEVICE_NAME ": Set UART config %02x.\n", config);
++
++	return 0;
++}
++
++static void tx_cb(struct ngene *dev, u32 ts)
++{
++	dev->tx_busy = 0;
++	wake_up_interruptible(&dev->tx_wq);
++}
++
++static void rx_cb(struct ngene *dev, u32 ts, u8 c)
++{
++	int rp = dev->uart_rp;
++	int nwp, wp = dev->uart_wp;
++
++	/* dprintk(KERN_DEBUG DEVICE_NAME ": %c\n", c); */
++	nwp = (wp + 1) % (UART_RBUF_LEN);
++	if (nwp == rp)
++		return;
++	dev->uart_rbuf[wp] = c;
++	dev->uart_wp = nwp;
++	wake_up_interruptible(&dev->rx_wq);
++}
++#endif
+ 
+ static int ngene_command_config_buf(struct ngene *dev, u8 config)
+ {
+@@ -427,6 +550,18 @@ int ngene_command_gpio_set(struct ngene *dev, u8 select, u8 level)
+ 	return ngene_command(dev, &com);
+ }
+ 
++#if 0
++/* The reset is only wired to GPIO4 on MicRacer Revision 1.10 !
++   Also better set bootdelay to 1 in nvram or less. */
++static void ngene_reset_decypher(struct ngene *dev)
++{
++	printk(KERN_INFO DEVICE_NAME ": Resetting Decypher.\n");
++	ngene_command_gpio_set(dev, 4, 0);
++	msleep(1);
++	ngene_command_gpio_set(dev, 4, 1);
++	msleep(2000);
++}
++#endif
+ 
+ /*
+  02000640 is sample on rising edge.
+@@ -512,6 +647,17 @@ void FillTSBuffer(void *Buffer, int Length, u32 Flags)
+ 	}
+ }
+ 
++#if 0
++static void clear_tsin(struct ngene_channel *chan)
++{
++	struct SBufferHeader *Cur = chan->nextBuffer;
++
++	do {
++		memset(&Cur->ngeneBuffer.SR, 0, sizeof(Cur->ngeneBuffer.SR));
++		Cur = Cur->Next;
++	} while (Cur != chan->nextBuffer);
++}
++#endif
+ 
+ static void flush_buffers(struct ngene_channel *chan)
+ {
+@@ -732,6 +878,14 @@ void set_transfer(struct ngene_channel *chan, int state)
+ 	if (dev->card_info->switch_ctrl)
+ 		dev->card_info->switch_ctrl(chan, 1, state ^ 1);
+ 
++#if 0
++	/* Disable AVF output if present. */
++	if (dev->card_info->avf[chan->number])
++		i2c_write_register(&chan->i2c_adapter,
++				   chan->dev->card_info->avf[chan->number],
++				   0xf2, state ? 0x80 : 0x89);
++
++#endif
+ 	if (state) {
+ 		spin_lock_irq(&chan->state_lock);
+ 
+@@ -752,8 +906,8 @@ void set_transfer(struct ngene_channel *chan, int state)
+ 		if (chan->mode & NGENE_IO_TSIN)
+ 			chan->pBufferExchange = tsin_exchange;
+ 		spin_unlock_irq(&chan->state_lock);
+-	}
+-		/* else printk(KERN_INFO DEVICE_NAME ": lock=%08x\n",
++	} else
++		;/* printk(KERN_INFO DEVICE_NAME ": lock=%08x\n",
+ 			   ngreadl(0x9310)); */
+ 
+ 	ret = ngene_command_stream_control(dev, chan->number,
+@@ -771,6 +925,89 @@ void set_transfer(struct ngene_channel *chan, int state)
+ 	}
+ }
+ 
++#if 0
++/****************************************************************************/
++/* Decypher firmware loading ************************************************/
++/****************************************************************************/
++
++#define DECYPHER_FW "decypher.fw"
++
++static int dec_ts_send(struct ngene *dev, u8 *buf, u32 len)
++{
++#if 0
++	if (wait_event_interruptible(dev->tsout_rbuf.queue,
++				     dvb_ringbuffer_free
++				     (&dev->tsout_rbuf) >= len) < 0)
++		return 0;
++#else
++	while (dvb_ringbuffer_free(&dev->tsout_rbuf) < len)
++		msleep(1);
++
++#endif
++
++	dvb_ringbuffer_write(&dev->tsout_rbuf, buf, len);
++
++	return len;
++}
++
++u8 dec_fw_fill_ts[188] = { 0x47, 0x09, 0x0e, 0x10, 0xff, 0xff, 0x00, 0x00 };
++
++int dec_fw_send(struct ngene *dev, u8 *fw, u32 size)
++{
++	struct ngene_channel *chan = &dev->channel[4];
++	u32 len = 180, cc = 0;
++	u8 buf[8] = { 0x47, 0x09, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00 };
++
++	set_transfer(chan, 1);
++	msleep(100);
++	while (size) {
++		len = 180;
++		if (len > size)
++			len = size;
++		buf[3] = 0x10 | (cc & 0x0f);
++		buf[4] = (cc >> 8);
++		buf[5] = cc & 0xff;
++		buf[6] = len;
++
++		dec_ts_send(dev, buf, 8);
++		dec_ts_send(dev, fw, len);
++		if (len < 180)
++			dec_ts_send(dev, dec_fw_fill_ts + len + 8, 180 - len);
++		cc++;
++		size -= len;
++		fw += len;
++	}
++	for (len = 0; len < 512; len++)
++		dec_ts_send(dev, dec_fw_fill_ts, 188);
++	while (dvb_ringbuffer_avail(&dev->tsout_rbuf))
++		msleep(10);
++	msleep(100);
++	set_transfer(chan, 0);
++	return 0;
++}
++
++int dec_fw_boot(struct ngene *dev)
++{
++	u32 size;
++	const struct firmware *fw = NULL;
++	u8 *dec_fw;
++
++	if (request_firmware(&fw, DECYPHER_FW, &dev->pci_dev->dev) < 0) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": %s not found. Check hotplug directory.\n",
++		       DECYPHER_FW);
++		return -1;
++	}
++	printk(KERN_INFO DEVICE_NAME ": Booting decypher firmware file %s\n",
++	       DECYPHER_FW);
++
++	size = fw->size;
++	dec_fw = (u8 *)fw->data;
++	dec_fw_send(dev, dec_fw, size);
++	release_firmware(fw);
++	return 0;
++}
++#endif
+ 
+ /****************************************************************************/
+ /* nGene hardware init and release functions ********************************/
+@@ -1065,6 +1302,85 @@ static u32 Buffer2Sizes[MAX_STREAM] = {
+ 	0
+ };
+ 
++#if 0
++static int allocate_buffer(struct pci_dev *pci_dev, dma_addr_t of,
++			   struct SRingBufferDescriptor *rbuf,
++			   u32 entries, u32 size1, u32 size2)
++{
++	if (create_ring_buffer(pci_dev, rbuf, entries) < 0)
++		return -ENOMEM;
++
++	if (AllocateRingBuffers(pci_dev, of, rbuf, size1, size2) < 0)
++		return -ENOMEM;
++
++	return 0;
++}
++
++static int channel_allocate_buffers(struct ngene_channel *chan)
++{
++	struct ngene *dev = chan->dev;
++	int type = dev->card_info->io_type[chan->number];
++	int status;
++
++	chan->State = KSSTATE_STOP;
++
++	if (type & (NGENE_IO_TV | NGENE_IO_HDTV | NGENE_IO_AIN)) {
++		status = create_ring_buffer(dev->pci_dev,
++					    &chan->RingBuffer,
++					    RingBufferSizes[chan->number]);
++		if (status < 0)
++			return -ENOMEM;
++
++		if (type & (NGENE_IO_TV | NGENE_IO_AIN)) {
++			status = AllocateRingBuffers(dev->pci_dev,
++						     dev->PAOverflowBuffer,
++						     &chan->RingBuffer,
++						     Buffer1Sizes[chan->number],
++						     Buffer2Sizes[chan->
++								  number]);
++			if (status < 0)
++				return -ENOMEM;
++		} else if (type & NGENE_IO_HDTV) {
++			status = AllocateRingBuffers(dev->pci_dev,
++						     dev->PAOverflowBuffer,
++						     &chan->RingBuffer,
++						     MAX_HDTV_BUFFER_SIZE, 0);
++			if (status < 0)
++				return -ENOMEM;
++		}
++	}
++
++	if (type & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {
++
++		status = create_ring_buffer(dev->pci_dev,
++					    &chan->TSRingBuffer, RING_SIZE_TS);
++		if (status < 0)
++			return -ENOMEM;
++
++		status = AllocateRingBuffers(dev->pci_dev,
++					     dev->PAOverflowBuffer,
++					     &chan->TSRingBuffer,
++					     MAX_TS_BUFFER_SIZE, 0);
++		if (status)
++			return -ENOMEM;
++	}
++
++	if (type & NGENE_IO_TSOUT) {
++		status = create_ring_buffer(dev->pci_dev,
++					    &chan->TSIdleBuffer, 1);
++		if (status < 0)
++			return -ENOMEM;
++		status = AllocateRingBuffers(dev->pci_dev,
++					     dev->PAOverflowBuffer,
++					     &chan->TSIdleBuffer,
++					     MAX_TS_BUFFER_SIZE, 0);
++		if (status)
++			return -ENOMEM;
++		FillTSIdleBuffer(&chan->TSIdleBuffer, &chan->TSRingBuffer);
++	}
++	return 0;
++}
++#endif
+ 
+ static int AllocCommonBuffers(struct ngene *dev)
+ {
+@@ -1318,6 +1634,10 @@ static int ngene_buffer_config(struct ngene *dev)
+ 		u8 tsin12_config[6]   = { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 };
+ 		u8 tsin1234_config[6] = { 0x30, 0x30, 0x00, 0x30, 0x30, 0x00 };
+ 		u8 tsio1235_config[6] = { 0x30, 0x30, 0x00, 0x28, 0x00, 0x38 };
++#if 0
++		u8 tsin34_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x60, 0x00 };
++		u8 tsio35_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x00, 0x60 };
++#endif
+ 		u8 *bconf = tsin12_config;
+ 
+ 		if (dev->card_info->io_type[2]&NGENE_IO_TSIN &&
+@@ -1327,10 +1647,22 @@ static int ngene_buffer_config(struct ngene *dev)
+ 			    dev->ci.en)
+ 				bconf = tsio1235_config;
+ 		}
++#if 0
++		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
++			bconf = hdtv_config;
++			ngene_reset_decypher(dev);
++		}
++#endif
+ 		stat = ngene_command_config_free_buf(dev, bconf);
+ 	} else {
+ 		int bconf = BUFFER_CONFIG_4422;
+ 
++#if 0
++		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
++			bconf = BUFFER_CONFIG_8022;
++			ngene_reset_decypher(dev);
++		}
++#endif
+ 		if (dev->card_info->io_type[3] == NGENE_IO_TSIN)
+ 			bconf = BUFFER_CONFIG_3333;
+ 		stat = ngene_command_config_buf(dev, bconf);
+@@ -1403,8 +1735,10 @@ static int ngene_start(struct ngene *dev)
+ 	if (stat < 0)
+ 		goto fail;
+ 
+-	return 0;
++	if (!stat)
++		return stat;
+ 
++	/* otherwise error: fall through */
+ fail:
+ 	ngwritel(0, NGENE_INT_ENABLE);
+ 	free_irq(dev->pci_dev->irq, dev);
+@@ -1688,10 +2022,36 @@ int ngene_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)
+ 
+ 
+ 	dev->i2c_current_bus = -1;
++#if 0
++	exp_init(dev);
++
++	/* Disable analog TV decoder chips if present */
++	if (dev->card_info->msp[0])
++		i2c_write_msp_register(&dev->channel[0].i2c_adapter,
++				       dev->card_info->msp[0], 0x00, 0x0000);
++	if (dev->card_info->msp[1])
++		i2c_write_msp_register(&dev->channel[1].i2c_adapter,
++				       dev->card_info->msp[1], 0x00, 0x0000);
++	{
++		u16 data;
++		read_msp(&dev->channel[0].i2c_adapter,
++			 dev->card_info->msp[0], 0x00, &data);
++	}
++	if (dev->card_info->avf[0])
++		i2c_write_register(&dev->channel[0].i2c_adapter,
++				   dev->card_info->avf[0], 0xf2, 0x80);
++	if (dev->card_info->avf[1])
++		i2c_write_register(&dev->channel[1].i2c_adapter,
++				   dev->card_info->avf[1], 0xf2, 0x80);
++	if (copy_eeprom) {
++		i2c_copy_eeprom(&dev->channel[0].i2c_adapter, 0x50, 0x52);
++		i2c_dump_eeprom(&dev->channel[0].i2c_adapter, 0x52);
++	}
++	/*i2c_check_eeprom(&dev->i2c_adapter);*/
++#endif
+ 
+ 	/* Register DVB adapters and devices for both channels */
+-	stat = init_channels(dev);
+-	if (stat < 0)
++	if (init_channels(dev) < 0)
+ 		goto fail2;
+ 
+ 	return 0;
+diff --git a/drivers/media/pci/ngene/ngene-dvb.c b/drivers/media/pci/ngene/ngene-dvb.c
+index fcb16a6..8049e2b 100644
+--- a/drivers/media/pci/ngene/ngene-dvb.c
++++ b/drivers/media/pci/ngene/ngene-dvb.c
+@@ -42,10 +42,319 @@
+ 
+ #include "ngene.h"
+ 
++#if 0
++int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
++			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl)
++{
++	if (!(mode & SMODE_TRANSPORT_STREAM))
++		return -EINVAL;
++
++	if (lines * bpl > MAX_VIDEO_BUFFER_SIZE)
++		return -EINVAL;
++
++	if ((mode & SMODE_TRANSPORT_STREAM) && (((bpl * lines) & 0xff) != 0))
++		return -EINVAL;
++
++	if ((mode & SMODE_VIDEO_CAPTURE) && (bpl & 7) != 0)
++		return -EINVAL;
++
++	return ngene_command_stream_control(dev, stream, control, mode, 0);
++}
++#endif
+ 
+ /****************************************************************************/
+ /* COMMAND API interface ****************************************************/
+ /****************************************************************************/
++#if 0
++
++static int command_do_ioctl(struct inode *inode, struct file *file,
++			    unsigned int cmd, void *parg)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int err = 0;
++
++	switch (cmd) {
++	case IOCTL_MIC_NO_OP:
++		err = ngene_command_nop(dev);
++		break;
++
++	case IOCTL_MIC_DOWNLOAD_FIRMWARE:
++		break;
++
++	case IOCTL_MIC_I2C_READ:
++	{
++		MIC_I2C_READ *msg = parg;
++
++		err = ngene_command_i2c_read(dev, msg->I2CAddress >> 1,
++					     msg->OutData, msg->OutLength,
++					     msg->OutData, msg->InLength, 1);
++		break;
++	}
++
++	case IOCTL_MIC_I2C_WRITE:
++	{
++		MIC_I2C_WRITE *msg = parg;
++
++		err = ngene_command_i2c_write(dev, msg->I2CAddress >> 1,
++					      msg->Data, msg->Length);
++		break;
++	}
++
++	case IOCTL_MIC_TEST_GETMEM:
++	{
++		MIC_MEM *m = parg;
++
++		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
++			return -EINVAL;
++
++		/* WARNING, only use this on x86,
++		   other archs may not swallow this  */
++		err = copy_to_user(m->Data, dev->iomem + m->Start, m->Length);
++		break;
++	}
++
++	case IOCTL_MIC_TEST_SETMEM:
++	{
++		MIC_MEM *m = parg;
++
++		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
++			return -EINVAL;
++
++		err = copy_from_user(dev->iomem + m->Start, m->Data, m->Length);
++		break;
++	}
++
++	case IOCTL_MIC_SFR_READ:
++	{
++		MIC_IMEM *m = parg;
++
++		err = ngene_command_imem_read(dev, m->Address, &m->Data, 1);
++		break;
++	}
++
++	case IOCTL_MIC_SFR_WRITE:
++	{
++		MIC_IMEM *m = parg;
++
++		err = ngene_command_imem_write(dev, m->Address, m->Data, 1);
++		break;
++	}
++
++	case IOCTL_MIC_IRAM_READ:
++	{
++		MIC_IMEM *m = parg;
++
++		err = ngene_command_imem_read(dev, m->Address, &m->Data, 0);
++		break;
++	}
++
++	case IOCTL_MIC_IRAM_WRITE:
++	{
++		MIC_IMEM *m = parg;
++
++		err = ngene_command_imem_write(dev, m->Address, m->Data, 0);
++		break;
++	}
++
++	case IOCTL_MIC_STREAM_CONTROL:
++	{
++		MIC_STREAM_CONTROL *m = parg;
++
++		err = ngene_stream_control(dev, m->Stream, m->Control, m->Mode,
++					   m->nLines, m->nBytesPerLine,
++					   m->nVBILines, m->nBytesPerVBILine);
++		break;
++	}
++
++	default:
++		err = -EINVAL;
++		break;
++	}
++	return err;
++}
++
++static int command_ioctl(struct inode *inode, struct file *file,
++			 unsigned int cmd, unsigned long arg)
++{
++	void *parg = (void *)arg, *pbuf = NULL;
++	char  buf[64];
++	int   res = -EFAULT;
++
++	if (_IOC_DIR(cmd) & _IOC_WRITE) {
++		parg = buf;
++		if (_IOC_SIZE(cmd) > sizeof(buf)) {
++			pbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
++			if (!pbuf)
++				return -ENOMEM;
++			parg = pbuf;
++		}
++		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
++			goto error;
++	}
++	res = command_do_ioctl(inode, file, cmd, parg);
++	if (res < 0)
++		goto error;
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
++			res = -EFAULT;
++error:
++	kfree(pbuf);
++	return res;
++}
++
++struct page *ngene_nopage(struct vm_area_struct *vma,
++			  unsigned long address, int *type)
++{
++	return 0;
++}
++
++static int ngene_mmap(struct file *file, struct vm_area_struct *vma)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++
++	unsigned long size = vma->vm_end - vma->vm_start;
++	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
++	unsigned long padr = pci_resource_start(dev->pci_dev, 0) + off;
++	unsigned long psize = pci_resource_len(dev->pci_dev, 0) - off;
++
++	if (size > psize)
++		return -EINVAL;
++
++	if (io_remap_pfn_range(vma, vma->vm_start, padr >> PAGE_SHIFT, size,
++			       vma->vm_page_prot))
++		return -EAGAIN;
++	return 0;
++}
++
++
++static int write_uart(struct ngene *dev, u8 *data, int len)
++{
++	struct ngene_command com;
++
++	com.cmd.hdr.Opcode = CMD_WRITE_UART;
++	com.cmd.hdr.Length = len;
++	memcpy(com.cmd.WriteUart.Data, data, len);
++	com.cmd.WriteUart.Data[len] = 0;
++	com.cmd.WriteUart.Data[len + 1] = 0;
++	com.in_len = len;
++	com.out_len = 0;
++
++	if (ngene_command(dev, &com) < 0)
++		return -EIO;
++
++	return 0;
++}
++
++static int send_cli(struct ngene *dev, char *cmd)
++{
++	/* printk(KERN_INFO DEVICE_NAME ": %s", cmd); */
++	return write_uart(dev, cmd, strlen(cmd));
++}
++
++static int send_cli_val(struct ngene *dev, char *cmd, u32 val)
++{
++	char s[32];
++
++	snprintf(s, 32, "%s %d\n", cmd, val);
++	/* printk(KERN_INFO DEVICE_NAME ": %s", s); */
++	return write_uart(dev, s, strlen(s));
++}
++
++static int ngene_command_write_uart_user(struct ngene *dev,
++					 const u8 *data, int len)
++{
++	struct ngene_command com;
++
++	dev->tx_busy = 1;
++	com.cmd.hdr.Opcode = CMD_WRITE_UART;
++	com.cmd.hdr.Length = len;
++
++	if (copy_from_user(com.cmd.WriteUart.Data, data, len))
++		return -EFAULT;
++	com.in_len = len;
++	com.out_len = 0;
++
++	if (ngene_command(dev, &com) < 0)
++		return -EIO;
++
++	return 0;
++}
++
++static ssize_t uart_write(struct file *file, const char *buf,
++			  size_t count, loff_t *ppos)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int len, ret = 0;
++	size_t left = count;
++
++	while (left) {
++		len = left;
++		if (len > 250)
++			len = 250;
++		ret = wait_event_interruptible(dev->tx_wq, dev->tx_busy == 0);
++		if (ret < 0)
++			return ret;
++		ngene_command_write_uart_user(dev, buf, len);
++		left -= len;
++		buf += len;
++	}
++	return count;
++}
++
++static ssize_t uart_read(struct file *file, char *buf,
++			 size_t count, loff_t *ppos)
++{
++	struct dvb_device *dvbdev = file->private_data;
++	struct ngene_channel *chan = dvbdev->priv;
++	struct ngene *dev = chan->dev;
++	int left;
++	int wp, rp, avail, len;
++
++	if (!dev->uart_rbuf)
++		return -EINVAL;
++	if (count > 128)
++		count = 128;
++	left = count;
++	while (left) {
++		if (wait_event_interruptible(dev->rx_wq,
++					     dev->uart_wp != dev->uart_rp) < 0)
++			return -EAGAIN;
++		wp = dev->uart_wp;
++		rp = dev->uart_rp;
++		avail = (wp - rp);
++
++		if (avail < 0)
++			avail += UART_RBUF_LEN;
++		if (avail > left)
++			avail = left;
++		if (wp < rp) {
++			len = UART_RBUF_LEN - rp;
++			if (len > avail)
++				len = avail;
++			if (copy_to_user(buf, dev->uart_rbuf + rp, len))
++				return -EFAULT;
++			if (len < avail)
++				if (copy_to_user(buf + len, dev->uart_rbuf,
++						 avail - len))
++					return -EFAULT;
++		} else {
++			if (copy_to_user(buf, dev->uart_rbuf + rp, avail))
++				return -EFAULT;
++		}
++		dev->uart_rp = (rp + avail) % UART_RBUF_LEN;
++		left -= avail;
++		buf += avail;
++	}
++	return count;
++}
++
++#endif
+ 
+ static ssize_t ts_write(struct file *file, const char *buf,
+ 			size_t count, loff_t *ppos)
+@@ -133,6 +442,11 @@ void *tsin_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
+ 	struct ngene_channel *chan = priv;
+ 	struct ngene *dev = chan->dev;
+ 
++#if 0
++	printk(KERN_INFO DEVICE_NAME ": tsin %08x %02x %02x %02x %02x\n",
++	       len, ((u8 *) buf)[512 * 188], ((u8 *) buf)[0],
++	       ((u8 *) buf)[1], ((u8 *) buf)[2]);
++#endif
+ 
+ 	if (flags & DF_SWAP32)
+ 		swap_buffer(buf, len);
+@@ -191,12 +505,49 @@ void *tsout_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
+ 	return buf;
+ }
+ 
++#if 0
++static void set_dto(struct ngene_channel *chan, u32 rate)
++{
++	u64 val = rate * 0x89705f41ULL; /* times val for 2^26 Hz */
++
++	val = ((val >> 25) + 1) >> 1;
++	chan->AudioDTOValue = (u32) val;
++	/* chan->AudioDTOUpdated=1; */
++	/* printk(KERN_INFO DEVICE_NAME ": Setting DTO to %08x\n", val); */
++}
++#endif
+ 
+ 
+ int ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+ {
+ 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
+ 	struct ngene_channel *chan = dvbdmx->priv;
++#if 0
++	struct ngene *dev = chan->dev;
++
++	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
++		switch (dvbdmxfeed->pes_type) {
++		case DMX_TS_PES_VIDEO:
++			send_cli_val(dev, "vpid", dvbdmxfeed->pid);
++			send_cli(dev, "res 1080i50\n");
++			/* send_cli(dev, "vdec mpeg2\n"); */
++			break;
++
++		case DMX_TS_PES_AUDIO:
++			send_cli_val(dev, "apid", dvbdmxfeed->pid);
++			send_cli(dev, "start\n");
++			break;
++
++		case DMX_TS_PES_PCR:
++			send_cli_val(dev, "pcrpid", dvbdmxfeed->pid);
++			break;
++
++		default:
++			break;
++		}
++
++	}
++#endif
+ 
+ 	if (chan->users == 0) {
+ 		if (!chan->dev->cmd_timeout_workaround || !chan->running)
+@@ -210,6 +561,27 @@ int ngene_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+ {
+ 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
+ 	struct ngene_channel *chan = dvbdmx->priv;
++#if 0
++	struct ngene *dev = chan->dev;
++
++	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
++		switch (dvbdmxfeed->pes_type) {
++		case DMX_TS_PES_VIDEO:
++			send_cli(dev, "stop\n");
++			break;
++
++		case DMX_TS_PES_AUDIO:
++			break;
++
++		case DMX_TS_PES_PCR:
++			break;
++
++		default:
++			break;
++		}
++
++	}
++#endif
+ 
+ 	if (--chan->users)
+ 		return chan->users;
+diff --git a/drivers/media/pci/ngene/ngene-eeprom.c b/drivers/media/pci/ngene/ngene-eeprom.c
+new file mode 100644
+index 0000000..281d9f9
+--- /dev/null
++++ b/drivers/media/pci/ngene/ngene-eeprom.c
+@@ -0,0 +1,284 @@
++/*
++ * ngene-eeprom.c: nGene PCIe bridge driver - eeprom support
++ *
++ * Copyright (C) 2005-2007 Micronas
++ *
++ * Copyright (C) 2008-2009 Ralph Metzler <rjkm@metzlerbros.de>
++ *                         Modifications for new nGene firmware,
++ *                         support for EEPROM-copying,
++ *                         support for new dual DVB-S2 card prototype
++ *
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 only, as published by the Free Software Foundation.
++ *
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301, USA
++ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
++ */
++
++#if 0
++static int copy_eeprom;
++module_param(copy_eeprom, int, 0444);
++MODULE_PARM_DESC(copy_eeprom, "Copy eeprom.");
++
++#define MICNG_EE_START      0x0100
++#define MICNG_EE_END        0x0FF0
++
++#define MICNG_EETAG_END0    0x0000
++#define MICNG_EETAG_END1    0xFFFF
++
++/* 0x0001 - 0x000F reserved for housekeeping */
++/* 0xFFFF - 0xFFFE reserved for housekeeping */
++
++/* Micronas assigned tags
++   EEProm tags for hardware support */
++
++#define MICNG_EETAG_DRXD1_OSCDEVIATION  0x1000  /* 2 Bytes data */
++#define MICNG_EETAG_DRXD2_OSCDEVIATION  0x1001  /* 2 Bytes data */
++
++#define MICNG_EETAG_MT2060_1_1STIF      0x1100  /* 2 Bytes data */
++#define MICNG_EETAG_MT2060_2_1STIF      0x1101  /* 2 Bytes data */
++
++/* Tag range for OEMs */
++
++#define MICNG_EETAG_OEM_FIRST  0xC000
++#define MICNG_EETAG_OEM_LAST   0xFFEF
++
++static int i2c_write_eeprom(struct i2c_adapter *adapter,
++			    u8 adr, u16 reg, u8 data)
++{
++	u8 m[3] = {(reg >> 8), (reg & 0xff), data};
++	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m,
++			      .len = sizeof(m)};
++
++	if (i2c_transfer(adapter, &msg, 1) != 1) {
++		dprintk(KERN_ERR DEVICE_NAME ": Error writing EEPROM!\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++static int i2c_read_eeprom(struct i2c_adapter *adapter,
++			   u8 adr, u16 reg, u8 *data, int len)
++{
++	u8 msg[2] = {(reg >> 8), (reg & 0xff)};
++	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
++				   .buf = msg, .len = 2 },
++				  {.addr = adr, .flags = I2C_M_RD,
++				   .buf = data, .len = len} };
++
++	if (i2c_transfer(adapter, msgs, 2) != 2) {
++		dprintk(KERN_ERR DEVICE_NAME ": Error reading EEPROM\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++static int ReadEEProm(struct i2c_adapter *adapter,
++		      u16 Tag, u32 MaxLen, u8 *data, u32 *pLength)
++{
++	int status = 0;
++	u16 Addr = MICNG_EE_START, Length, tag = 0;
++	u8  EETag[3];
++
++	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
++		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
++			return -1;
++		tag = (EETag[0] << 8) | EETag[1];
++		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
++			return -1;
++		if (tag == Tag)
++			break;
++		Addr += sizeof(u16) + 1 + EETag[2];
++	}
++	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
++		       tag, EETag[2]);
++		return -1;
++	}
++	Length = EETag[2];
++	if (Length > MaxLen)
++		Length = (u16) MaxLen;
++	if (Length > 0) {
++		Addr += sizeof(u16) + 1;
++		status = i2c_read_eeprom(adapter, 0x50, Addr, data, Length);
++		if (!status) {
++			*pLength = EETag[2];
++			if (Length < EETag[2])
++				; /*status=STATUS_BUFFER_OVERFLOW; */
++		}
++	}
++	return status;
++}
++
++static int WriteEEProm(struct i2c_adapter *adapter,
++		       u16 Tag, u32 Length, u8 *data)
++{
++	int status = 0;
++	u16 Addr = MICNG_EE_START;
++	u8 EETag[3];
++	u16 tag = 0;
++	int retry, i;
++
++	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
++		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
++			return -1;
++		tag = (EETag[0] << 8) | EETag[1];
++		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
++			return -1;
++		if (tag == Tag)
++			break;
++		Addr += sizeof(u16) + 1 + EETag[2];
++	}
++	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
++		       tag, EETag[2]);
++		return -1;
++	}
++
++	if (Length > EETag[2])
++		return -EINVAL;
++	/* Note: We write the data one byte at a time to avoid
++	   issues with page sizes. (which are different for
++	   each manufacture and eeprom size)
++	 */
++	Addr += sizeof(u16) + 1;
++	for (i = 0; i < Length; i++, Addr++) {
++		status = i2c_write_eeprom(adapter, 0x50, Addr, data[i]);
++
++		if (status)
++			break;
++
++		/* Poll for finishing write cycle */
++		retry = 10;
++		while (retry) {
++			u8 Tmp;
++
++			msleep(50);
++			status = i2c_read_eeprom(adapter, 0x50, Addr, &Tmp, 1);
++			if (status)
++				break;
++			if (Tmp != data[i])
++				printk(KERN_ERR DEVICE_NAME
++				       "eeprom write error\n");
++			retry -= 1;
++		}
++		if (status) {
++			printk(KERN_ERR DEVICE_NAME
++			       ": Timeout polling eeprom\n");
++			break;
++		}
++	}
++	return status;
++}
++
++static void i2c_init_eeprom(struct i2c_adapter *adapter)
++{
++	u8 tags[] = {0x10, 0x00, 0x02, 0x00, 0x00,
++		     0x10, 0x01, 0x02, 0x00, 0x00,
++		     0x00, 0x00, 0x00};
++
++	int i;
++
++	for (i = 0; i < sizeof(tags); i++)
++		i2c_write_eeprom(adapter, 0x50, 0x0100 + i, tags[i]);
++}
++
++int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data)
++{
++	int stat;
++	u8 buf[2];
++	u32 len = 0;
++
++	stat = ReadEEProm(adapter, tag, 2, buf, &len);
++	if (stat)
++		return stat;
++	if (len != 2)
++		return -EINVAL;
++
++	*data = (buf[0] << 8) | buf[1];
++	return 0;
++}
++
++static int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data)
++{
++	int stat;
++	u8 buf[2];
++
++	buf[0] = data >> 8;
++	buf[1] = data & 0xff;
++	stat = WriteEEProm(adapter, tag, 2, buf);
++	if (stat)
++		return stat;
++	return 0;
++}
++
++int i2c_dump_eeprom(struct i2c_adapter *adapter, u8 adr)
++{
++	u8 buf[64];
++	int i;
++
++	if (i2c_read_eeprom(adapter, adr, 0x0000, buf, sizeof(buf))) {
++		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
++		return -1;
++	}
++	for (i = 0; i < sizeof(buf); i++) {
++		if (!(i & 15))
++			printk(KERN_DEBUG "\n");
++		printk(KERN_DEBUG "%02x ", buf[i]);
++	}
++	printk("\n");
++
++	return 0;
++}
++
++int i2c_copy_eeprom(struct i2c_adapter *adapter, u8 adr, u8 adr2)
++{
++	u8 buf[64];
++	int i;
++
++	if (i2c_read_eeprom(adapter, adr, 0x0000, buf, sizeof(buf))) {
++		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
++		return -1;
++	}
++	buf[36] = 0xc3;
++	buf[39] = 0xab;
++	for (i = 0; i < sizeof(buf); i++) {
++		i2c_write_eeprom(adapter, adr2, i, buf[i]);
++		msleep(10);
++	}
++	return 0;
++}
++
++int i2c_check_eeprom(struct i2c_adapter *adapter)
++{
++	u8 buf[13];
++
++	i2c_dump_eeprom(adapter);
++
++	if (i2c_read_eeprom(adapter, 0x50, 0x0100, buf, sizeof(buf))) {
++		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
++		return -1;
++	}
++	if (buf[0] != 0x10 || buf[1] != 0x00) {
++		printk(KERN_INFO DEVICE_NAME
++		       ": Initializing EEPROM TAG area\n");
++		i2c_init_eeprom(adapter);
++	}
++	return 0;
++}
++
++#endif
+diff --git a/drivers/media/pci/ngene/ngene-i2c.c b/drivers/media/pci/ngene/ngene-i2c.c
+index d28554f..601bea4 100644
+--- a/drivers/media/pci/ngene/ngene-i2c.c
++++ b/drivers/media/pci/ngene/ngene-i2c.c
+@@ -77,6 +77,11 @@ static int ngene_command_i2c_write(struct ngene *dev, u8 adr,
+ {
+ 	struct ngene_command com;
+ 
++#if 0
++	/* Probing by writing 0 bytes does not work */
++	if (!outlen)
++		outlen++;
++#endif
+ 
+ 	com.cmd.hdr.Opcode = CMD_I2C_WRITE;
+ 	com.cmd.hdr.Length = outlen + 1;
+@@ -148,6 +153,39 @@ done:
+ 	return num;
+ }
+ 
++#if 0
++static int ngene_i2c_algo_control(struct i2c_adapter *adap,
++				  unsigned int cmd, unsigned long arg)
++{
++	struct ngene_channel *chan =
++		(struct ngene_channel *)i2c_get_adapdata(adap);
++
++	switch (cmd) {
++	case IOCTL_MIC_TUN_RDY:
++		chan->tun_rdy = 1;
++		if (chan->dec_rdy == 1)
++			chan->tun_dec_rdy = 1;
++		break;
++
++	case IOCTL_MIC_DEC_RDY:
++		chan->dec_rdy = 1;
++		if (chan->tun_rdy == 1)
++			chan->tun_dec_rdy = 1;
++		break;
++
++	case IOCTL_MIC_TUN_DETECT:
++		{
++			int *palorbtsc = (int *)arg;
++			*palorbtsc = chan->dev->card_info->ntsc;
++			break;
++		}
++
++	default:
++		break;
++	}
++	return 0;
++}
++#endif
+ 
+ static u32 ngene_i2c_functionality(struct i2c_adapter *adap)
+ {
+@@ -174,3 +212,78 @@ int ngene_i2c_init(struct ngene *dev, int dev_nr)
+ 	return i2c_add_adapter(adap);
+ }
+ 
++#if 0
++int i2c_write(struct i2c_adapter *adapter, u8 adr, u8 data)
++{
++	u8 m[1] = {data};
++	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 1};
++
++	if (i2c_transfer(adapter, &msg, 1) != 1) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": Failed to write to I2C adr %02x!\n", adr);
++		return -1;
++	}
++	return 0;
++}
++
++static int i2c_write_register(struct i2c_adapter *adapter,
++			      u8 adr, u8 reg, u8 data)
++{
++	u8 m[2] = {reg, data};
++	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 2};
++
++	if (i2c_transfer(adapter, &msg, 1) != 1) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": Failed to write to I2C register %02x@%02x!\n",
++		       reg, adr);
++		return -1;
++	}
++	return 0;
++}
++
++static int i2c_write_read(struct i2c_adapter *adapter,
++			  u8 adr, u8 *w, u8 wlen, u8 *r, u8 rlen)
++{
++	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
++				   .buf = w, .len = wlen},
++				  {.addr = adr, .flags = I2C_M_RD,
++				   .buf = r, .len = rlen} };
++
++	if (i2c_transfer(adapter, msgs, 2) != 2) {
++		printk(KERN_ERR DEVICE_NAME ": error in i2c_write_read\n");
++		return -1;
++	}
++	return 0;
++}
++
++static int test_dec_i2c(struct i2c_adapter *adapter, int reg)
++{
++	u8 data[256] = { reg, 0x00, 0x93, 0x78, 0x43, 0x45 };
++	u8 data2[256];
++	int i;
++
++	memset(data2, 0, 256);
++	i2c_write_read(adapter, 0x66, data, 2, data2, 4);
++	for (i = 0; i < 4; i++)
++		printk(KERN_DEBUG "%02x ", data2[i]);
++	printk(KERN_DEBUG "\n");
++
++	return 0;
++}
++
++static int i2c_write_msp_register(struct i2c_adapter *adapter,
++				  u8 adr, u8 reg, u16 data)
++{
++	u8 m[3] = {reg, (data >> 8) & 0xff, data & 0xff};
++	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 3 };
++
++	if (i2c_transfer(adapter, &msg, 1) != 1) {
++		printk(KERN_ERR DEVICE_NAME
++		       ": Failed to write to I2C register %02x@%02x!\n",
++		       reg, adr);
++		return -1;
++	}
++	return 0;
++}
++
++#endif
+diff --git a/drivers/media/pci/ngene/ngene.h b/drivers/media/pci/ngene/ngene.h
+index 22c39ff..e3ae00c 100644
+--- a/drivers/media/pci/ngene/ngene.h
++++ b/drivers/media/pci/ngene/ngene.h
+@@ -653,6 +653,11 @@ struct ngene_channel {
+ 	struct dmx_frontend   mem_frontend;
+ 	int                   users;
+ 	struct video_device  *v4l_dev;
++#if 0
++	struct dvb_device    *command_dev;
++	struct dvb_device    *audio_dev;
++	struct dvb_device    *video_dev;
++#endif
+ 	struct dvb_device    *ci_dev;
+ 	struct tasklet_struct demux_tasklet;
+ 
+@@ -691,6 +696,9 @@ struct ngene_channel {
+ 	struct mychip        *mychip;
+ 	struct snd_card      *soundcard;
+ 	u8                   *evenbuffer;
++#if 0
++	u8                   *soundbuffer;
++#endif
+ 	u8                    dma_on;
+ 	int                   soundstreamon;
+ 	int                   audiomute;
+@@ -849,6 +857,10 @@ struct ngene_info {
+ 	u8    lnb[4];
+ 	int   i2c_access;
+ 	u8    ntsc;
++#if 0
++	u8    exp;
++	u8    exp_init;
++#endif
+ 	u8    tsf[4];
+ 	u8    i2s[4];
+ 
+@@ -885,6 +897,25 @@ struct ngene_buffer {
+ };
+ #endif
+ 
++#if 0
++int ngene_command_stream_control(struct ngene *dev,
++				 u8 stream, u8 control, u8 mode, u8 flags);
++int ngene_command_nop(struct ngene *dev);
++int ngene_command_i2c_read(struct ngene *dev, u8 adr,
++			   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag);
++int ngene_command_i2c_write(struct ngene *dev, u8 adr, u8 *out, u8 outlen);
++int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type);
++int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type);
++int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
++			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl);
++
++int ngene_v4l2_init(struct ngene_channel *chan);
++void ngene_v4l2_remove(struct ngene_channel *chan);
++int ngene_snd_exit(struct ngene_channel *chan);
++int ngene_snd_init(struct ngene_channel *chan);
++
++struct i2c_client *avf4910a_attach(struct i2c_adapter *adap, int addr);
++#endif
+ 
+ /* Provided by ngene-core.c */
+ int ngene_probe(struct pci_dev *pci_dev, const struct pci_device_id *id);
+@@ -914,6 +945,15 @@ int my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,
+ 			       struct dmx_frontend *mem_frontend,
+ 			       struct dvb_adapter *dvb_adapter);
+ 
++/* Provided by ngene-eeprom.c */
++#if 0
++int i2c_copy_eeprom(struct i2c_adapter *adapter, u8 adr, u8 adr2);
++int i2c_dump_eeprom(struct i2c_adapter *adapter, u8 adr);
++int i2c_check_eeprom(struct i2c_adapter *adapter);
++int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data);
++int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data);
++#endif
++
+ #endif
+ 
+ /*  LocalWords:  Endif
+diff --git a/drivers/staging/media/cxd2099/TODO b/drivers/staging/media/cxd2099/TODO
+deleted file mode 100644
+index 375bb6f..0000000
+--- a/drivers/staging/media/cxd2099/TODO
++++ /dev/null
+@@ -1,12 +0,0 @@
+-For now, data is passed through '/dev/dvb/adapterX/sec0':
+- - Encrypted data must be written to 'sec0'.
+- - Decrypted data can be read from 'sec0'.
+- - Setup the CAM using device 'ca0'.
+-
+-But this is wrong. There are some discussions about the proper way for
+-doing it, as seen at:
+-	http://www.mail-archive.com/linux-media@vger.kernel.org/msg22196.html
+-
+-While there's no proper fix for it, the driver should be kept in staging.
+-
+-Patches should be submitted to: linux-media@vger.kernel.org.
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-222-stb0899_signal_quality.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-222-stb0899_signal_quality.patch
new file mode 100644
index 0000000..fd6539d
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-222-stb0899_signal_quality.patch
@@ -0,0 +1,62 @@
+diff -Naur linux-3.7.2/drivers/media/dvb-frontends/stb0899_drv.c linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_drv.c
+--- linux-3.7.2/drivers/media/dvb-frontends/stb0899_drv.c	2013-01-11 18:19:28.000000000 +0100
++++ linux-3.7.2.patch/drivers/media/dvb-frontends/stb0899_drv.c	2013-01-16 10:33:10.323380937 +0100
+@@ -971,6 +971,16 @@
+ 
+ 				*strength = stb0899_table_lookup(stb0899_dvbsrf_tab, ARRAY_SIZE(stb0899_dvbsrf_tab) - 1, val);
+ 				*strength += 750;
++
++		            	const int MIN_STRENGTH_DVBS = 0;
++		            	const int MAX_STRENGTH_DVBS = 680;
++		            	if (*strength < MIN_STRENGTH_DVBS) 	
++		                	*strength = 0;
++		            	else if(*strength > MAX_STRENGTH_DVBS) 
++		                	*strength = 0xFFFF;
++		            	else
++				    	*strength = (*strength - MIN_STRENGTH_DVBS) * 0xFFFF / (MAX_STRENGTH_DVBS - MIN_STRENGTH_DVBS); 
++
+ 				dprintk(state->verbose, FE_DEBUG, 1, "AGCIQVALUE = 0x%02x, C = %d * 0.1 dBm",
+ 					val & 0xff, *strength);
+ 			}
+@@ -983,6 +993,7 @@
+ 
+ 			*strength = stb0899_table_lookup(stb0899_dvbs2rf_tab, ARRAY_SIZE(stb0899_dvbs2rf_tab) - 1, val);
+ 			*strength += 950;
++			*strength = *strength << 4;
+ 			dprintk(state->verbose, FE_DEBUG, 1, "IF_AGC_GAIN = 0x%04x, C = %d * 0.1 dBm",
+ 				val & 0x3fff, *strength);
+ 		}
+@@ -1016,6 +1027,16 @@
+ 				val = MAKEWORD16(buf[0], buf[1]);
+ 
+ 				*snr = stb0899_table_lookup(stb0899_cn_tab, ARRAY_SIZE(stb0899_cn_tab) - 1, val);
++
++		            	const int MIN_SNR_DVBS = 0;
++		            	const int MAX_SNR_DVBS = 200;
++		            	if (*snr < MIN_SNR_DVBS) 	
++		                	*snr = 0;
++		            	else if(*snr > MAX_SNR_DVBS) 
++		                	*snr = 0xFFFF;
++		            	else
++				    	*snr = (*snr - MIN_SNR_DVBS) * 0xFFFF / (MAX_SNR_DVBS - MIN_SNR_DVBS);
++
+ 				dprintk(state->verbose, FE_DEBUG, 1, "NIR = 0x%02x%02x = %u, C/N = %d * 0.1 dBm\n",
+ 					buf[0], buf[1], val, *snr);
+ 			}
+@@ -1040,6 +1061,16 @@
+ 				val = (quantn - estn) / 10;
+ 			}
+ 			*snr = val;
++
++	        	const int MIN_SNR_DVBS2 = 10;
++	        	const int MAX_SNR_DVBS2 = 70;
++	        	if (*snr < MIN_SNR_DVBS2) 	
++		            	*snr = 0;
++	        	else if(*snr > MAX_SNR_DVBS2) 
++        		    	*snr = 0xFFFF;
++        		else
++				*snr = (*snr - MIN_SNR_DVBS2) * 0xFFFF / (MAX_SNR_DVBS2 - MIN_SNR_DVBS2); 
++
+ 			dprintk(state->verbose, FE_DEBUG, 1, "Es/N0 quant = %d (%d) estimate = %u (%d), C/N = %d * 0.1 dBm",
+ 				quant, quantn, est, estn, val);
+ 		}
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-223-Fix-video-artifacts-with-tt-3600-s2-usb.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-223-Fix-video-artifacts-with-tt-3600-s2-usb.patch
new file mode 100644
index 0000000..7aaabc4
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-223-Fix-video-artifacts-with-tt-3600-s2-usb.patch
@@ -0,0 +1,17 @@
+diff -Naur linux-3.7.9/drivers/media/usb/dvb-usb/pctv452e.c linux-3.7.9.patch/drivers/media/usb/dvb-usb/pctv452e.c
+--- linux-3.7.9/drivers/media/usb/dvb-usb/pctv452e.c    2013-01-11 18:19:28.000000000 +0100
++++ linux-3.7.9.patch/drivers/media/usb/dvb-usb/pctv452e.c      2013-01-16 10:35:01.131342123 +0100
+@@ -995,11 +995,11 @@
+			/* parameter for the MPEG2-data transfer */
+			.stream = {
+				.type = USB_ISOC,
+-				.count = 7,
++				.count = 4,
+				.endpoint = 0x02,
+				.u = {
+					.isoc = {
+-						.framesperurb = 4,
++						.framesperurb = 64,
+						.framesize = 940,
+						.interval = 1
+					}
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-701-linksys_aes2500_brcmfmac.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-701-linksys_aes2500_brcmfmac.patch
new file mode 100644
index 0000000..639a6ab
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-701-linksys_aes2500_brcmfmac.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/wireless/brcm80211/brcmfmac/usb.c	2013-07-21 16:06:37.443909481 +0200
++++ b/drivers/net/wireless/brcm80211/brcmfmac/usb.c	2013-07-21 16:11:10.696335476 +0200
+@@ -1470,15 +1470,18 @@
+ }
+ 
+ #define BRCMF_USB_VENDOR_ID_BROADCOM	0x0a5c
++#define BRCMF_USB_VENDOR_ID_LINKSYS	0x13b1
+ #define BRCMF_USB_DEVICE_ID_43143	0xbd1e
+ #define BRCMF_USB_DEVICE_ID_43236	0xbd17
+ #define BRCMF_USB_DEVICE_ID_43242	0xbd1f
++#define BRCMF_USB_DEVICE_ID_AE2500	0x003a
+ #define BRCMF_USB_DEVICE_ID_BCMFW	0x0bdc
+ 
+ static struct usb_device_id brcmf_usb_devid_table[] = {
+ 	{ USB_DEVICE(BRCMF_USB_VENDOR_ID_BROADCOM, BRCMF_USB_DEVICE_ID_43143) },
+ 	{ USB_DEVICE(BRCMF_USB_VENDOR_ID_BROADCOM, BRCMF_USB_DEVICE_ID_43236) },
+ 	{ USB_DEVICE(BRCMF_USB_VENDOR_ID_BROADCOM, BRCMF_USB_DEVICE_ID_43242) },
++	{ USB_DEVICE(BRCMF_USB_VENDOR_ID_LINKSYS, BRCMF_USB_DEVICE_ID_AE2500) },
+ 	/* special entry for device with firmware loaded and running */
+ 	{ USB_DEVICE(BRCMF_USB_VENDOR_ID_BROADCOM, BRCMF_USB_DEVICE_ID_BCMFW) },
+ 	{ }
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-702-Support-for-cheap-Ralink-3070-WiFi-plug.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-702-Support-for-cheap-Ralink-3070-WiFi-plug.patch
new file mode 100644
index 0000000..e3dc6ca
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-702-Support-for-cheap-Ralink-3070-WiFi-plug.patch
@@ -0,0 +1,64 @@
+diff --git a/drivers/net/wireless/rt2x00/rt2800.h b/drivers/net/wireless/rt2x00/rt2800.h
+index a7630d5..9504d45 100644
+--- a/drivers/net/wireless/rt2x00/rt2800.h
++++ b/drivers/net/wireless/rt2x00/rt2800.h
+@@ -69,6 +69,7 @@
+ #define RF3320				0x000b
+ #define RF3322				0x000c
+ #define RF3053				0x000d
++#define RF3070				0x3070
+ #define RF5592				0x000f
+ #define RF3290				0x3290
+ #define RF5360				0x5360
+diff --git a/drivers/net/wireless/rt2x00/rt2800lib.c b/drivers/net/wireless/rt2x00/rt2800lib.c
+index 0d355c2..bbd5d59 100644
+--- a/drivers/net/wireless/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -2599,6 +2599,7 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 		break;
+ 	case RF5360:
+ 	case RF5370:
++	case RF3070:
+ 	case RF5372:
+ 	case RF5390:
+ 	case RF5392:
+@@ -2615,6 +2616,7 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	    rt2x00_rf(rt2x00dev, RF3322) ||
+ 	    rt2x00_rf(rt2x00dev, RF5360) ||
+ 	    rt2x00_rf(rt2x00dev, RF5370) ||
++	    rt2x00_rf(rt2x00dev, RF3070) ||
+ 	    rt2x00_rf(rt2x00dev, RF5372) ||
+ 	    rt2x00_rf(rt2x00dev, RF5390) ||
+ 	    rt2x00_rf(rt2x00dev, RF5392)) {
+@@ -3206,6 +3208,7 @@ void rt2800_vco_calibration(struct rt2x00_dev *rt2x00dev)
+ 	case RF3290:
+ 	case RF5360:
+ 	case RF5370:
++	case RF3070:
+ 	case RF5372:
+ 	case RF5390:
+ 	case RF5392:
+@@ -5524,6 +5527,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
+ 	case RF3322:
+ 	case RF5360:
+ 	case RF5370:
++	case RF3070:
+ 	case RF5372:
+ 	case RF5390:
+ 	case RF5392:
+@@ -5979,6 +5983,7 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
+ 		   rt2x00_rf(rt2x00dev, RF3322) ||
+ 		   rt2x00_rf(rt2x00dev, RF5360) ||
+ 		   rt2x00_rf(rt2x00dev, RF5370) ||
++		   rt2x00_rf(rt2x00dev, RF3070) ||
+ 		   rt2x00_rf(rt2x00dev, RF5372) ||
+ 		   rt2x00_rf(rt2x00dev, RF5390) ||
+ 		   rt2x00_rf(rt2x00dev, RF5392)) {
+@@ -6081,6 +6086,7 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
+ 	case RF3290:
+ 	case RF5360:
+ 	case RF5370:
++	case RF3070:
+ 	case RF5372:
+ 	case RF5390:
+ 	case RF5392:
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-704-Support-for-Ubiquiti-WifiStation.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-704-Support-for-Ubiquiti-WifiStation.patch
new file mode 100644
index 0000000..7932c07
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-704-Support-for-Ubiquiti-WifiStation.patch
@@ -0,0 +1,28 @@
+From 62330f8f9b6105bfe201f52b7ed86ea6ce3d5901 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sun, 8 Sep 2013 10:33:51 +0100
+Subject: [PATCH] Add Ubiquiti WifiStation USB id to ath9k wifi driver
+
+---
+ drivers/net/wireless/ath/ath9k/hif_usb.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/wireless/ath/ath9k/hif_usb.c b/drivers/net/wireless/ath/ath9k/hif_usb.c
+index 75a6376..8cb8d8d 100644
+--- a/drivers/net/wireless/ath/ath9k/hif_usb.c
++++ b/drivers/net/wireless/ath/ath9k/hif_usb.c
+@@ -37,9 +37,11 @@
+ 	{ USB_DEVICE(0x13D3, 0x3350) }, /* Azurewave */
+ 	{ USB_DEVICE(0x04CA, 0x4605) }, /* Liteon */
+ 	{ USB_DEVICE(0x040D, 0x3801) }, /* VIA */
++	{ USB_DEVICE(0x0cf3, 0xb002) }, /* Ubiquiti WifiStation */
+ 	{ USB_DEVICE(0x0cf3, 0xb003) }, /* Ubiquiti WifiStation Ext */
+ 	{ USB_DEVICE(0x0cf3, 0xb002) }, /* Ubiquiti WifiStation */
+ 	{ USB_DEVICE(0x057c, 0x8403) }, /* AVM FRITZ!WLAN 11N v2 USB */
++	{ USB_DEVICE(0x057c, 0x8403) }, /* AVM FRITZ!WLAN 11N v2 USB */
+ 
+ 	{ USB_DEVICE(0x0cf3, 0x7015),
+ 	  .driver_info = AR9287_USB },  /* Atheros */
+-- 
+1.8.4
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-705-Support-for-Buffalo-WLI-UC-G300HP-V1.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-705-Support-for-Buffalo-WLI-UC-G300HP-V1.patch
new file mode 100644
index 0000000..816af3b
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-705-Support-for-Buffalo-WLI-UC-G300HP-V1.patch
@@ -0,0 +1,10 @@
+--- a/drivers/net/wireless/rt2x00/rt2800usb.c	2013-10-08 15:14:44.844047190 +0200
++++ b/drivers/net/wireless/rt2x00/rt2800usb.c	2013-10-08 15:15:00.279904575 +0200
+@@ -976,6 +976,7 @@
+ 	{ USB_DEVICE(0x0411, 0x015d) },
+ 	{ USB_DEVICE(0x0411, 0x016f) },
+ 	{ USB_DEVICE(0x0411, 0x01a2) },
++	{ USB_DEVICE(0x0411, 0x01a8) },
+ 	{ USB_DEVICE(0x0411, 0x01ee) },
+ 	/* Corega */
+ 	{ USB_DEVICE(0x07aa, 0x002f) },
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-706-Sitecom-N300.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-706-Sitecom-N300.patch
new file mode 100644
index 0000000..9f52eeb
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-706-Sitecom-N300.patch
@@ -0,0 +1,11 @@
+diff -Naur linux-3.10.16/drivers/staging/rtl8712/usb_intf.c linux-3.10.16.patch/drivers/staging/rtl8712/usb_intf.c
+--- linux-3.10.16/drivers/staging/rtl8712/usb_intf.c	2013-10-14 01:08:56.000000000 +0200
++++ linux-3.10.16.patch/drivers/staging/rtl8712/usb_intf.c	2013-10-16 13:27:44.032951265 +0200
+@@ -92,6 +92,7 @@
+ 	{USB_DEVICE(0x0DF6, 0x005B)},
+ 	{USB_DEVICE(0x0DF6, 0x005D)},
+ 	{USB_DEVICE(0x0DF6, 0x0063)},
++	{USB_DEVICE(0x0DF6, 0x006C)},
+ 	/* Sweex */
+ 	{USB_DEVICE(0x177F, 0x0154)},
+ 	/* Thinkware */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-900-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-900-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch
new file mode 100644
index 0000000..b211efc
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-900-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch
@@ -0,0 +1,81 @@
+From a7c092a19768d6b6dbb5d4afea33136c4637d633 Mon Sep 17 00:00:00 2001
+From: Yevgeny Pats <yevgeny@perception-point.io>
+Date: Tue, 19 Jan 2016 22:09:04 +0000
+Subject: [PATCH 1/4] KEYS: Fix keyring ref leak in join_session_keyring()
+
+This fixes CVE-2016-0728.
+
+If a thread is asked to join as a session keyring the keyring that's already
+set as its session, we leak a keyring reference.
+
+This can be tested with the following program:
+
+	#include <stddef.h>
+	#include <stdio.h>
+	#include <sys/types.h>
+	#include <keyutils.h>
+
+	int main(int argc, const char *argv[])
+	{
+		int i = 0;
+		key_serial_t serial;
+
+		serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
+				"leaked-keyring");
+		if (serial < 0) {
+			perror("keyctl");
+			return -1;
+		}
+
+		if (keyctl(KEYCTL_SETPERM, serial,
+			   KEY_POS_ALL | KEY_USR_ALL) < 0) {
+			perror("keyctl");
+			return -1;
+		}
+
+		for (i = 0; i < 100; i++) {
+			serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
+					"leaked-keyring");
+			if (serial < 0) {
+				perror("keyctl");
+				return -1;
+			}
+		}
+
+		return 0;
+	}
+
+If, after the program has run, there something like the following line in
+/proc/keys:
+
+3f3d898f I--Q---   100 perm 3f3f0000     0     0 keyring   leaked-keyring: empty
+
+with a usage count of 100 * the number of times the program has been run,
+then the kernel is malfunctioning.  If leaked-keyring has zero usages or
+has been garbage collected, then the problem is fixed.
+
+Reported-by: Yevgeny Pats <yevgeny@perception-point.io>
+Signed-off-by: David Howells <dhowells@redhat.com>
+Acked-by: Don Zickus <dzickus@redhat.com>
+Acked-by: Prarit Bhargava <prarit@redhat.com>
+Acked-by: Jarod Wilson <jarod@redhat.com>
+Signed-off-by: James Morris <james.l.morris@oracle.com>
+---
+ security/keys/process_keys.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
+index 42defae..cd871dc 100644
+--- a/security/keys/process_keys.c
++++ b/security/keys/process_keys.c
+@@ -792,6 +792,7 @@ long join_session_keyring(const char *name)
+ 		ret = PTR_ERR(keyring);
+ 		goto error2;
+ 	} else if (keyring == new->session_keyring) {
++		key_put(keyring);
+ 		ret = 0;
+ 		goto error2;
+ 	}
+-- 
+2.10.1
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-901-mm-remove-gup_flags-FOLL_WRITE-games-from-__get_user.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-901-mm-remove-gup_flags-FOLL_WRITE-games-from-__get_user.patch
new file mode 100644
index 0000000..c7a0dfe
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-901-mm-remove-gup_flags-FOLL_WRITE-games-from-__get_user.patch
@@ -0,0 +1,101 @@
+From 541267fab71436c4acb361f1557a881c3908b22e Mon Sep 17 00:00:00 2001
+From: Linus Torvalds <torvalds@linux-foundation.org>
+Date: Thu, 13 Oct 2016 13:07:36 -0700
+Subject: [PATCH 2/4] mm: remove gup_flags FOLL_WRITE games from
+ __get_user_pages()
+
+commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 upstream.
+
+This is an ancient bug that was actually attempted to be fixed once
+(badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
+get_user_pages() race for write access") but that was then undone due to
+problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").
+
+In the meantime, the s390 situation has long been fixed, and we can now
+fix it by checking the pte_dirty() bit properly (and do it better).  The
+s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
+software dirty bits") which made it into v3.9.  Earlier kernels will
+have to look at the page state itself.
+
+Also, the VM has become more scalable, and what used a purely
+theoretical race back then has become easier to trigger.
+
+To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
+we already did a COW" rather than play racy games with FOLL_WRITE that
+is very fundamental, and then use the pte dirty flag to validate that
+the FOLL_COW flag is still valid.
+
+Reported-and-tested-by: Phil "not Paul" Oester <kernel@linuxace.com>
+Acked-by: Hugh Dickins <hughd@google.com>
+Reviewed-by: Michal Hocko <mhocko@suse.com>
+Cc: Andy Lutomirski <luto@kernel.org>
+Cc: Kees Cook <keescook@chromium.org>
+Cc: Oleg Nesterov <oleg@redhat.com>
+Cc: Willy Tarreau <w@1wt.eu>
+Cc: Nick Piggin <npiggin@gmail.com>
+Cc: Greg Thelen <gthelen@google.com>
+Cc: stable@vger.kernel.org
+Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
+[wt: s/gup.c/memory.c; s/follow_page_pte/follow_page_mask;
+     s/faultin_page/__get_user_page]
+Signed-off-by: Willy Tarreau <w@1wt.eu>
+---
+ include/linux/mm.h |  2 ++
+ mm/memory.c        | 14 ++++++++++++--
+ 2 files changed, 14 insertions(+), 2 deletions(-)
+
+diff --git a/include/linux/mm.h b/include/linux/mm.h
+index dbade0f..218be84 100644
+--- a/include/linux/mm.h
++++ b/include/linux/mm.h
+@@ -1723,6 +1723,8 @@ struct page *follow_page(struct vm_area_struct *, unsigned long address,
+ #define FOLL_SPLIT	0x80	/* don't return transhuge pages, split them */
+ #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
+ #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
++#define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
++#define FOLL_COW	0x4000	/* internal GUP flag */
+ 
+ typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
+ 			void *data);
+diff --git a/mm/memory.c b/mm/memory.c
+index 4395fe8..326e9cd 100644
+--- a/mm/memory.c
++++ b/mm/memory.c
+@@ -1458,6 +1458,16 @@ int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
+ }
+ EXPORT_SYMBOL_GPL(zap_vma_ptes);
+ 
++/*
++ * FOLL_FORCE can write to even unwritable pte's, but only
++ * after we've gone through a COW cycle and they are dirty.
++ */
++static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
++{
++	return pte_write(pte) ||
++		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
++}
++
+ /**
+  * follow_page - look up a page descriptor from a user-virtual address
+  * @vma: vm_area_struct mapping @address
+@@ -1544,7 +1554,7 @@ split_fallthrough:
+ 		goto no_page;
+ 	if ((flags & FOLL_NUMA) && pte_numa(pte))
+ 		goto no_page;
+-	if ((flags & FOLL_WRITE) && !pte_write(pte))
++	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
+ 		goto unlock;
+ 
+ 	page = vm_normal_page(vma, address, pte);
+@@ -1847,7 +1857,7 @@ int __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
+ 				 */
+ 				if ((ret & VM_FAULT_WRITE) &&
+ 				    !(vma->vm_flags & VM_WRITE))
+-					foll_flags &= ~FOLL_WRITE;
++					foll_flags |= FOLL_COW;
+ 
+ 				cond_resched();
+ 			}
+-- 
+2.10.1
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-902-Revert-media-mfc-use-shipped-firmware-paths.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-902-Revert-media-mfc-use-shipped-firmware-paths.patch
new file mode 100644
index 0000000..da1d417
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-902-Revert-media-mfc-use-shipped-firmware-paths.patch
@@ -0,0 +1,35 @@
+From 33ec211a483dd5fdc9c590f624ea395a237a59f1 Mon Sep 17 00:00:00 2001
+From: Kevin Mihelich <kevin@archlinuxarm.org>
+Date: Mon, 24 Oct 2016 19:33:31 -0600
+Subject: [PATCH 3/4] Revert "media/mfc: use shipped firmware paths"
+
+This reverts commit 6720e7ffffed9656b006553311b2d85abcd3f0b6.
+---
+ drivers/media/platform/s5p-mfc/s5p_mfc.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
+index 6a1cef5..0da338c 100644
+--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
++++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
+@@ -1293,7 +1293,7 @@ static struct s5p_mfc_variant mfc_drvdata_v5 = {
+ 	.buf_size	= &buf_size_v5,
+ 	.buf_align	= &mfc_buf_align_v5,
+ 	.mclk_name	= "sclk_mfc",
+-	.fw_name	= "s5p-mfc/s5p-mfc.fw",
++	.fw_name	= "s5p-mfc.fw",
+ };
+ 
+ struct s5p_mfc_buf_size_v6 mfc_buf_size_v6 = {
+@@ -1320,7 +1320,7 @@ static struct s5p_mfc_variant mfc_drvdata_v6 = {
+ 	.buf_size	= &buf_size_v6,
+ 	.buf_align	= &mfc_buf_align_v6,
+ 	.mclk_name      = "aclk_333",
+-	.fw_name        = "s5p-mfc/s5p-mfc-v6.fw",
++	.fw_name        = "s5p-mfc-v6.fw",
+ };
+ 
+ static struct platform_device_id mfc_driver_ids[] = {
+-- 
+2.10.1
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-903-Allow-mac-address-to-be-set-in-smsc95xx.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-903-Allow-mac-address-to-be-set-in-smsc95xx.patch
new file mode 100644
index 0000000..f1b29a0
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-903-Allow-mac-address-to-be-set-in-smsc95xx.patch
@@ -0,0 +1,96 @@
+From 9610e2bda9ccee379887600bac748aeb13a61cbe Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Tue, 26 Mar 2013 17:26:38 +0000
+Subject: [PATCH 4/4] Allow mac address to be set in smsc95xx
+
+Signed-off-by: popcornmix <popcornmix@gmail.com>
+---
+ drivers/net/usb/smsc95xx.c | 56 ++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 56 insertions(+)
+
+diff --git a/drivers/net/usb/smsc95xx.c b/drivers/net/usb/smsc95xx.c
+index 19a8db7..fdde874 100644
+--- a/drivers/net/usb/smsc95xx.c
++++ b/drivers/net/usb/smsc95xx.c
+@@ -54,6 +54,7 @@
+ #define FEATURE_8_WAKEUP_FILTERS	(0x01)
+ #define FEATURE_PHY_NLP_CROSSOVER	(0x02)
+ #define FEATURE_AUTOSUSPEND		(0x04)
++#define MAC_ADDR_LEN                    (6)
+ 
+ struct smsc95xx_priv {
+ 	u32 mac_cr;
+@@ -129,6 +130,10 @@ int smsc95xx_read_mac_addr(unsigned char *mac)
+ }
+ #endif  
+ 
++static char *macaddr = ":";
++module_param(macaddr, charp, 0);
++MODULE_PARM_DESC(macaddr, "MAC address");
++
+ static int __must_check __smsc95xx_read_reg(struct usbnet *dev, u32 index,
+ 					    u32 *data, int in_pm)
+ {
+@@ -836,8 +841,59 @@ static int smsc95xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+ 	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
+ }
+ 
++/* Check the macaddr module parameter for a MAC address */
++static int smsc95xx_is_macaddr_param(struct usbnet *dev, u8 *dev_mac)
++{
++       int i, j, got_num, num;
++       u8 mtbl[MAC_ADDR_LEN];
++
++       if (macaddr[0] == ':')
++               return 0;
++
++       i = 0;
++       j = 0;
++       num = 0;
++       got_num = 0;
++       while (j < MAC_ADDR_LEN) {
++               if (macaddr[i] && macaddr[i] != ':') {
++                       got_num++;
++                       if ('0' <= macaddr[i] && macaddr[i] <= '9')
++                               num = num * 16 + macaddr[i] - '0';
++                       else if ('A' <= macaddr[i] && macaddr[i] <= 'F')
++                               num = num * 16 + 10 + macaddr[i] - 'A';
++                       else if ('a' <= macaddr[i] && macaddr[i] <= 'f')
++                               num = num * 16 + 10 + macaddr[i] - 'a';
++                       else
++                               break;
++                       i++;
++               } else if (got_num == 2) {
++                       mtbl[j++] = (u8) num;
++                       num = 0;
++                       got_num = 0;
++                       i++;
++               } else {
++                       break;
++               }
++       }
++
++       if (j == MAC_ADDR_LEN) {
++               netif_dbg(dev, ifup, dev->net, "Overriding MAC address with: "
++               "%02x:%02x:%02x:%02x:%02x:%02x\n", mtbl[0], mtbl[1], mtbl[2],
++                                               mtbl[3], mtbl[4], mtbl[5]);
++               for (i = 0; i < MAC_ADDR_LEN; i++)
++                       dev_mac[i] = mtbl[i];
++               return 1;
++       } else {
++               return 0;
++       }
++}
++
+ static void smsc95xx_init_mac_address(struct usbnet *dev)
+ {
++       /* Check module parameters */
++       if (smsc95xx_is_macaddr_param(dev, dev->net->dev_addr))
++               return;
++
+ 	/* try reading mac address from EEPROM */
+ 	if (smsc95xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN,
+ 			dev->net->dev_addr) == 0) {
+-- 
+2.10.1
+
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-991-update-magic_h-header.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-991-update-magic_h-header.patch
new file mode 100644
index 0000000..aa534ca
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-991-update-magic_h-header.patch
@@ -0,0 +1,28 @@
+diff --git a/include/uapi/linux/magic.h b/include/uapi/linux/magic.h
+index 873e086..77c6031 100644
+--- a/include/uapi/linux/magic.h
++++ b/include/uapi/linux/magic.h
+@@ -11,6 +11,7 @@
+ #define DEBUGFS_MAGIC          0x64626720
+ #define SECURITYFS_MAGIC	0x73636673
+ #define SELINUX_MAGIC		0xf97cff8c
++#define SMACK_MAGIC		0x43415d53	/* "SMAC" */
+ #define RAMFS_MAGIC		0x858458f6	/* some random number */
+ #define TMPFS_MAGIC		0x01021994
+ #define HUGETLBFS_MAGIC 	0x958458f6	/* some random number */
+@@ -29,6 +30,7 @@
+ #define JFFS2_SUPER_MAGIC	0x72b6
+ #define PSTOREFS_MAGIC		0x6165676C
+ #define EFIVARFS_MAGIC		0xde5e81e4
++#define HOSTFS_SUPER_MAGIC	0x00c0ffee
+ 
+ #define MINIX_SUPER_MAGIC	0x137F		/* minix v1 fs, 14 char names */
+ #define MINIX_SUPER_MAGIC2	0x138F		/* minix v1 fs, 30 char names */
+@@ -69,6 +71,6 @@
+ #define USBDEVICE_SUPER_MAGIC	0x9fa2
+ #define MTD_INODE_FS_MAGIC      0x11307854
+ #define ANON_INODE_FS_MAGIC	0x09041934
+-
++#define BTRFS_TEST_MAGIC	0x73727279
+ 
+ #endif /* __LINUX_MAGIC_H__ */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-992-add-sctp-headers.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-992-add-sctp-headers.patch
new file mode 100644
index 0000000..b2f2424
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-992-add-sctp-headers.patch
@@ -0,0 +1,863 @@
+diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
+index 4e67194..c3dade1 100644
+--- a/include/uapi/linux/Kbuild
++++ b/include/uapi/linux/Kbuild
+@@ -330,6 +330,7 @@ header-y += rtnetlink.h
+ header-y += scc.h
+ header-y += sched.h
+ header-y += screen_info.h
++header-y += sctp.h
+ header-y += sdla.h
+ header-y += seccomp.h
+ header-y += securebits.h
+diff --git a/include/uapi/linux/sctp.h b/include/uapi/linux/sctp.h
+new file mode 100644
+index 0000000..266022a
+--- /dev/null
++++ b/include/uapi/linux/sctp.h
+@@ -0,0 +1,845 @@
++/* SCTP kernel implementation
++ * (C) Copyright IBM Corp. 2001, 2004
++ * Copyright (c) 1999-2000 Cisco, Inc.
++ * Copyright (c) 1999-2001 Motorola, Inc.
++ * Copyright (c) 2002 Intel Corp.
++ *
++ * This file is part of the SCTP kernel implementation
++ *
++ * This header represents the structures and constants needed to support
++ * the SCTP Extension to the Sockets API.
++ *
++ * This SCTP implementation is free software;
++ * you can redistribute it and/or modify it under the terms of
++ * the GNU General Public License as published by
++ * the Free Software Foundation; either version 2, or (at your option)
++ * any later version.
++ *
++ * This SCTP implementation is distributed in the hope that it
++ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
++ *                 ************************
++ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
++ * See the GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with GNU CC; see the file COPYING.  If not, see
++ * <http://www.gnu.org/licenses/>.
++ *
++ * Please send any bug reports or fixes you make to the
++ * email address(es):
++ *    lksctp developers <linux-sctp@vger.kernel.org>
++ *
++ * Or submit a bug report through the following website:
++ *    http://www.sf.net/projects/lksctp
++ *
++ * Written or modified by:
++ *    La Monte H.P. Yarroll    <piggy@acm.org>
++ *    R. Stewart               <randall@sctp.chicago.il.us>
++ *    K. Morneau               <kmorneau@cisco.com>
++ *    Q. Xie                   <qxie1@email.mot.com>
++ *    Karl Knutson             <karl@athena.chicago.il.us>
++ *    Jon Grimm                <jgrimm@us.ibm.com>
++ *    Daisy Chang              <daisyc@us.ibm.com>
++ *    Ryan Layer               <rmlayer@us.ibm.com>
++ *    Ardelle Fan              <ardelle.fan@intel.com>
++ *    Sridhar Samudrala        <sri@us.ibm.com>
++ *    Inaky Perez-Gonzalez     <inaky.gonzalez@intel.com>
++ *    Vlad Yasevich            <vladislav.yasevich@hp.com>
++ *
++ * Any bugs reported given to us we will try to fix... any fixes shared will
++ * be incorporated into the next SCTP release.
++ */
++
++#ifndef _UAPI_SCTP_H
++#define _UAPI_SCTP_H
++
++#include <linux/types.h>
++#include <linux/socket.h>
++
++typedef __s32 sctp_assoc_t;
++
++/* The following symbols come from the Sockets API Extensions for
++ * SCTP <draft-ietf-tsvwg-sctpsocket-07.txt>.
++ */
++#define SCTP_RTOINFO	0
++#define SCTP_ASSOCINFO  1
++#define SCTP_INITMSG	2
++#define SCTP_NODELAY	3		/* Get/set nodelay option. */
++#define SCTP_AUTOCLOSE	4
++#define SCTP_SET_PEER_PRIMARY_ADDR 5
++#define SCTP_PRIMARY_ADDR	6
++#define SCTP_ADAPTATION_LAYER	7
++#define SCTP_DISABLE_FRAGMENTS	8
++#define SCTP_PEER_ADDR_PARAMS	9
++#define SCTP_DEFAULT_SEND_PARAM	10
++#define SCTP_EVENTS	11
++#define SCTP_I_WANT_MAPPED_V4_ADDR 12	/* Turn on/off mapped v4 addresses  */
++#define SCTP_MAXSEG	13		/* Get/set maximum fragment. */
++#define SCTP_STATUS	14
++#define SCTP_GET_PEER_ADDR_INFO	15
++#define SCTP_DELAYED_ACK_TIME	16
++#define SCTP_DELAYED_ACK SCTP_DELAYED_ACK_TIME
++#define SCTP_DELAYED_SACK SCTP_DELAYED_ACK_TIME
++#define SCTP_CONTEXT	17
++#define SCTP_FRAGMENT_INTERLEAVE	18
++#define SCTP_PARTIAL_DELIVERY_POINT	19 /* Set/Get partial delivery point */
++#define SCTP_MAX_BURST	20		/* Set/Get max burst */
++#define SCTP_AUTH_CHUNK	21	/* Set only: add a chunk type to authenticate */
++#define SCTP_HMAC_IDENT	22
++#define SCTP_AUTH_KEY	23
++#define SCTP_AUTH_ACTIVE_KEY	24
++#define SCTP_AUTH_DELETE_KEY	25
++#define SCTP_PEER_AUTH_CHUNKS	26	/* Read only */
++#define SCTP_LOCAL_AUTH_CHUNKS	27	/* Read only */
++#define SCTP_GET_ASSOC_NUMBER	28	/* Read only */
++#define SCTP_GET_ASSOC_ID_LIST	29	/* Read only */
++#define SCTP_AUTO_ASCONF       30
++#define SCTP_PEER_ADDR_THLDS	31
++
++/* Internal Socket Options. Some of the sctp library functions are
++ * implemented using these socket options.
++ */
++#define SCTP_SOCKOPT_BINDX_ADD	100	/* BINDX requests for adding addrs */
++#define SCTP_SOCKOPT_BINDX_REM	101	/* BINDX requests for removing addrs. */
++#define SCTP_SOCKOPT_PEELOFF	102	/* peel off association. */
++/* Options 104-106 are deprecated and removed. Do not use this space */
++#define SCTP_SOCKOPT_CONNECTX_OLD	107	/* CONNECTX old requests. */
++#define SCTP_GET_PEER_ADDRS	108		/* Get all peer address. */
++#define SCTP_GET_LOCAL_ADDRS	109		/* Get all local address. */
++#define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
++#define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
++#define SCTP_GET_ASSOC_STATS	112	/* Read only */
++
++/*
++ * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
++ *
++ *   This cmsghdr structure provides information for initializing new
++ *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
++ *   uses this same data structure.  This structure is not used for
++ *   recvmsg().
++ *
++ *   cmsg_level    cmsg_type      cmsg_data[]
++ *   ------------  ------------   ----------------------
++ *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg
++ *
++ */
++struct sctp_initmsg {
++	__u16 sinit_num_ostreams;
++	__u16 sinit_max_instreams;
++	__u16 sinit_max_attempts;
++	__u16 sinit_max_init_timeo;
++};
++
++/*
++ * 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)
++ *
++ *   This cmsghdr structure specifies SCTP options for sendmsg() and
++ *   describes SCTP header information about a received message through
++ *   recvmsg().
++ *
++ *   cmsg_level    cmsg_type      cmsg_data[]
++ *   ------------  ------------   ----------------------
++ *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
++ *
++ */
++struct sctp_sndrcvinfo {
++	__u16 sinfo_stream;
++	__u16 sinfo_ssn;
++	__u16 sinfo_flags;
++	__u32 sinfo_ppid;
++	__u32 sinfo_context;
++	__u32 sinfo_timetolive;
++	__u32 sinfo_tsn;
++	__u32 sinfo_cumtsn;
++	sctp_assoc_t sinfo_assoc_id;
++};
++
++/*
++ *  sinfo_flags: 16 bits (unsigned integer)
++ *
++ *   This field may contain any of the following flags and is composed of
++ *   a bitwise OR of these values.
++ */
++
++enum sctp_sinfo_flags {
++	SCTP_UNORDERED = 1,  /* Send/receive message unordered. */
++	SCTP_ADDR_OVER = 2,  /* Override the primary destination. */
++	SCTP_ABORT=4,        /* Send an ABORT message to the peer. */
++	SCTP_SACK_IMMEDIATELY = 8,	/* SACK should be sent without delay */
++	SCTP_EOF=MSG_FIN,    /* Initiate graceful shutdown process. */
++};
++
++typedef union {
++	__u8   			raw;
++	struct sctp_initmsg	init;
++	struct sctp_sndrcvinfo	sndrcv;
++} sctp_cmsg_data_t;
++
++/* These are cmsg_types.  */
++typedef enum sctp_cmsg_type {
++	SCTP_INIT,              /* 5.2.1 SCTP Initiation Structure */
++#define SCTP_INIT	SCTP_INIT
++	SCTP_SNDRCV,            /* 5.2.2 SCTP Header Information Structure */
++#define SCTP_SNDRCV	SCTP_SNDRCV
++} sctp_cmsg_t;
++
++/*
++ * 5.3.1.1 SCTP_ASSOC_CHANGE
++ *
++ *   Communication notifications inform the ULP that an SCTP association
++ *   has either begun or ended. The identifier for a new association is
++ *   provided by this notificaion. The notification information has the
++ *   following format:
++ *
++ */
++struct sctp_assoc_change {
++	__u16 sac_type;
++	__u16 sac_flags;
++	__u32 sac_length;
++	__u16 sac_state;
++	__u16 sac_error;
++	__u16 sac_outbound_streams;
++	__u16 sac_inbound_streams;
++	sctp_assoc_t sac_assoc_id;
++	__u8 sac_info[0];
++};
++
++/*
++ *   sac_state: 32 bits (signed integer)
++ *
++ *   This field holds one of a number of values that communicate the
++ *   event that happened to the association.  They include:
++ *
++ *   Note:  The following state names deviate from the API draft as
++ *   the names clash too easily with other kernel symbols.
++ */
++enum sctp_sac_state {
++	SCTP_COMM_UP,
++	SCTP_COMM_LOST,
++	SCTP_RESTART,
++	SCTP_SHUTDOWN_COMP,
++	SCTP_CANT_STR_ASSOC,
++};
++
++/*
++ * 5.3.1.2 SCTP_PEER_ADDR_CHANGE
++ *
++ *   When a destination address on a multi-homed peer encounters a change
++ *   an interface details event is sent.  The information has the
++ *   following structure:
++ */
++struct sctp_paddr_change {
++	__u16 spc_type;
++	__u16 spc_flags;
++	__u32 spc_length;
++	struct sockaddr_storage spc_aaddr;
++	int spc_state;
++	int spc_error;
++	sctp_assoc_t spc_assoc_id;
++} __attribute__((packed, aligned(4)));
++
++/*
++ *    spc_state:  32 bits (signed integer)
++ *
++ *   This field holds one of a number of values that communicate the
++ *   event that happened to the address.  They include:
++ */
++enum sctp_spc_state {
++	SCTP_ADDR_AVAILABLE,
++	SCTP_ADDR_UNREACHABLE,
++	SCTP_ADDR_REMOVED,
++	SCTP_ADDR_ADDED,
++	SCTP_ADDR_MADE_PRIM,
++	SCTP_ADDR_CONFIRMED,
++};
++
++
++/*
++ * 5.3.1.3 SCTP_REMOTE_ERROR
++ *
++ *   A remote peer may send an Operational Error message to its peer.
++ *   This message indicates a variety of error conditions on an
++ *   association. The entire error TLV as it appears on the wire is
++ *   included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP
++ *   specification [SCTP] and any extensions for a list of possible
++ *   error formats. SCTP error TLVs have the format:
++ */
++struct sctp_remote_error {
++	__u16 sre_type;
++	__u16 sre_flags;
++	__u32 sre_length;
++	__u16 sre_error;
++	sctp_assoc_t sre_assoc_id;
++	__u8 sre_data[0];
++};
++
++
++/*
++ * 5.3.1.4 SCTP_SEND_FAILED
++ *
++ *   If SCTP cannot deliver a message it may return the message as a
++ *   notification.
++ */
++struct sctp_send_failed {
++	__u16 ssf_type;
++	__u16 ssf_flags;
++	__u32 ssf_length;
++	__u32 ssf_error;
++	struct sctp_sndrcvinfo ssf_info;
++	sctp_assoc_t ssf_assoc_id;
++	__u8 ssf_data[0];
++};
++
++/*
++ *   ssf_flags: 16 bits (unsigned integer)
++ *
++ *   The flag value will take one of the following values
++ *
++ *   SCTP_DATA_UNSENT  - Indicates that the data was never put on
++ *                       the wire.
++ *
++ *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.
++ *                       Note that this does not necessarily mean that the
++ *                       data was (or was not) successfully delivered.
++ */
++enum sctp_ssf_flags {
++	SCTP_DATA_UNSENT,
++	SCTP_DATA_SENT,
++};
++
++/*
++ * 5.3.1.5 SCTP_SHUTDOWN_EVENT
++ *
++ *   When a peer sends a SHUTDOWN, SCTP delivers this notification to
++ *   inform the application that it should cease sending data.
++ */
++struct sctp_shutdown_event {
++	__u16 sse_type;
++	__u16 sse_flags;
++	__u32 sse_length;
++	sctp_assoc_t sse_assoc_id;
++};
++
++/*
++ * 5.3.1.6 SCTP_ADAPTATION_INDICATION
++ *
++ *   When a peer sends a Adaptation Layer Indication parameter , SCTP
++ *   delivers this notification to inform the application
++ *   that of the peers requested adaptation layer.
++ */
++struct sctp_adaptation_event {
++	__u16 sai_type;
++	__u16 sai_flags;
++	__u32 sai_length;
++	__u32 sai_adaptation_ind;
++	sctp_assoc_t sai_assoc_id;
++};
++
++/*
++ * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT
++ *
++ *   When a receiver is engaged in a partial delivery of a
++ *   message this notification will be used to indicate
++ *   various events.
++ */
++struct sctp_pdapi_event {
++	__u16 pdapi_type;
++	__u16 pdapi_flags;
++	__u32 pdapi_length;
++	__u32 pdapi_indication;
++	sctp_assoc_t pdapi_assoc_id;
++};
++
++enum { SCTP_PARTIAL_DELIVERY_ABORTED=0, };
++
++/*
++ * 5.3.1.8.  SCTP_AUTHENTICATION_EVENT
++ *
++ *  When a receiver is using authentication this message will provide
++ *  notifications regarding new keys being made active as well as errors.
++ */
++struct sctp_authkey_event {
++	__u16 auth_type;
++	__u16 auth_flags;
++	__u32 auth_length;
++	__u16 auth_keynumber;
++	__u16 auth_altkeynumber;
++	__u32 auth_indication;
++	sctp_assoc_t auth_assoc_id;
++};
++
++enum { SCTP_AUTH_NEWKEY = 0, };
++
++/*
++ * 6.1.9. SCTP_SENDER_DRY_EVENT
++ *
++ * When the SCTP stack has no more user data to send or retransmit, this
++ * notification is given to the user. Also, at the time when a user app
++ * subscribes to this event, if there is no data to be sent or
++ * retransmit, the stack will immediately send up this notification.
++ */
++struct sctp_sender_dry_event {
++	__u16 sender_dry_type;
++	__u16 sender_dry_flags;
++	__u32 sender_dry_length;
++	sctp_assoc_t sender_dry_assoc_id;
++};
++
++/*
++ * Described in Section 7.3
++ *   Ancillary Data and Notification Interest Options
++ */
++struct sctp_event_subscribe {
++	__u8 sctp_data_io_event;
++	__u8 sctp_association_event;
++	__u8 sctp_address_event;
++	__u8 sctp_send_failure_event;
++	__u8 sctp_peer_error_event;
++	__u8 sctp_shutdown_event;
++	__u8 sctp_partial_delivery_event;
++	__u8 sctp_adaptation_layer_event;
++	__u8 sctp_authentication_event;
++	__u8 sctp_sender_dry_event;
++};
++
++/*
++ * 5.3.1 SCTP Notification Structure
++ *
++ *   The notification structure is defined as the union of all
++ *   notification types.
++ *
++ */
++union sctp_notification {
++	struct {
++		__u16 sn_type;             /* Notification type. */
++		__u16 sn_flags;
++		__u32 sn_length;
++	} sn_header;
++	struct sctp_assoc_change sn_assoc_change;
++	struct sctp_paddr_change sn_paddr_change;
++	struct sctp_remote_error sn_remote_error;
++	struct sctp_send_failed sn_send_failed;
++	struct sctp_shutdown_event sn_shutdown_event;
++	struct sctp_adaptation_event sn_adaptation_event;
++	struct sctp_pdapi_event sn_pdapi_event;
++	struct sctp_authkey_event sn_authkey_event;
++	struct sctp_sender_dry_event sn_sender_dry_event;
++};
++
++/* Section 5.3.1
++ * All standard values for sn_type flags are greater than 2^15.
++ * Values from 2^15 and down are reserved.
++ */
++
++enum sctp_sn_type {
++	SCTP_SN_TYPE_BASE     = (1<<15),
++	SCTP_ASSOC_CHANGE,
++#define SCTP_ASSOC_CHANGE		SCTP_ASSOC_CHANGE
++	SCTP_PEER_ADDR_CHANGE,
++#define SCTP_PEER_ADDR_CHANGE		SCTP_PEER_ADDR_CHANGE
++	SCTP_SEND_FAILED,
++#define SCTP_SEND_FAILED		SCTP_SEND_FAILED
++	SCTP_REMOTE_ERROR,
++#define SCTP_REMOTE_ERROR		SCTP_REMOTE_ERROR
++	SCTP_SHUTDOWN_EVENT,
++#define SCTP_SHUTDOWN_EVENT		SCTP_SHUTDOWN_EVENT
++	SCTP_PARTIAL_DELIVERY_EVENT,
++#define SCTP_PARTIAL_DELIVERY_EVENT	SCTP_PARTIAL_DELIVERY_EVENT
++	SCTP_ADAPTATION_INDICATION,
++#define SCTP_ADAPTATION_INDICATION	SCTP_ADAPTATION_INDICATION
++	SCTP_AUTHENTICATION_EVENT,
++#define SCTP_AUTHENTICATION_INDICATION	SCTP_AUTHENTICATION_EVENT
++	SCTP_SENDER_DRY_EVENT,
++#define SCTP_SENDER_DRY_EVENT		SCTP_SENDER_DRY_EVENT
++};
++
++/* Notification error codes used to fill up the error fields in some
++ * notifications.
++ * SCTP_PEER_ADDRESS_CHAGE 	: spc_error
++ * SCTP_ASSOC_CHANGE		: sac_error
++ * These names should be potentially included in the draft 04 of the SCTP
++ * sockets API specification.
++ */
++typedef enum sctp_sn_error {
++	SCTP_FAILED_THRESHOLD,
++	SCTP_RECEIVED_SACK,
++	SCTP_HEARTBEAT_SUCCESS,
++	SCTP_RESPONSE_TO_USER_REQ,
++	SCTP_INTERNAL_ERROR,
++	SCTP_SHUTDOWN_GUARD_EXPIRES,
++	SCTP_PEER_FAULTY,
++} sctp_sn_error_t;
++
++/*
++ * 7.1.1 Retransmission Timeout Parameters (SCTP_RTOINFO)
++ *
++ *   The protocol parameters used to initialize and bound retransmission
++ *   timeout (RTO) are tunable.  See [SCTP] for more information on how
++ *   these parameters are used in RTO calculation.
++ */
++struct sctp_rtoinfo {
++	sctp_assoc_t	srto_assoc_id;
++	__u32		srto_initial;
++	__u32		srto_max;
++	__u32		srto_min;
++};
++
++/*
++ * 7.1.2 Association Parameters (SCTP_ASSOCINFO)
++ *
++ *   This option is used to both examine and set various association and
++ *   endpoint parameters.
++ */
++struct sctp_assocparams {
++	sctp_assoc_t	sasoc_assoc_id;
++	__u16		sasoc_asocmaxrxt;
++	__u16		sasoc_number_peer_destinations;
++	__u32		sasoc_peer_rwnd;
++	__u32		sasoc_local_rwnd;
++	__u32		sasoc_cookie_life;
++};
++
++/*
++ * 7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)
++ *
++ *  Requests that the peer mark the enclosed address as the association
++ *  primary. The enclosed address must be one of the association's
++ *  locally bound addresses. The following structure is used to make a
++ *   set primary request:
++ */
++struct sctp_setpeerprim {
++	sctp_assoc_t            sspp_assoc_id;
++	struct sockaddr_storage sspp_addr;
++} __attribute__((packed, aligned(4)));
++
++/*
++ * 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)
++ *
++ *  Requests that the local SCTP stack use the enclosed peer address as
++ *  the association primary. The enclosed address must be one of the
++ *  association peer's addresses. The following structure is used to
++ *  make a set peer primary request:
++ */
++struct sctp_prim {
++	sctp_assoc_t            ssp_assoc_id;
++	struct sockaddr_storage ssp_addr;
++} __attribute__((packed, aligned(4)));
++
++/* For backward compatibility use, define the old name too */
++#define sctp_setprim	sctp_prim
++
++/*
++ * 7.1.11 Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)
++ *
++ * Requests that the local endpoint set the specified Adaptation Layer
++ * Indication parameter for all future INIT and INIT-ACK exchanges.
++ */
++struct sctp_setadaptation {
++	__u32	ssb_adaptation_ind;
++};
++
++/*
++ * 7.1.13 Peer Address Parameters  (SCTP_PEER_ADDR_PARAMS)
++ *
++ *   Applications can enable or disable heartbeats for any peer address
++ *   of an association, modify an address's heartbeat interval, force a
++ *   heartbeat to be sent immediately, and adjust the address's maximum
++ *   number of retransmissions sent before an address is considered
++ *   unreachable. The following structure is used to access and modify an
++ *   address's parameters:
++ */
++enum  sctp_spp_flags {
++	SPP_HB_ENABLE = 1<<0,		/*Enable heartbeats*/
++	SPP_HB_DISABLE = 1<<1,		/*Disable heartbeats*/
++	SPP_HB = SPP_HB_ENABLE | SPP_HB_DISABLE,
++	SPP_HB_DEMAND = 1<<2,		/*Send heartbeat immediately*/
++	SPP_PMTUD_ENABLE = 1<<3,	/*Enable PMTU discovery*/
++	SPP_PMTUD_DISABLE = 1<<4,	/*Disable PMTU discovery*/
++	SPP_PMTUD = SPP_PMTUD_ENABLE | SPP_PMTUD_DISABLE,
++	SPP_SACKDELAY_ENABLE = 1<<5,	/*Enable SACK*/
++	SPP_SACKDELAY_DISABLE = 1<<6,	/*Disable SACK*/
++	SPP_SACKDELAY = SPP_SACKDELAY_ENABLE | SPP_SACKDELAY_DISABLE,
++	SPP_HB_TIME_IS_ZERO = 1<<7,	/* Set HB delay to 0 */
++};
++
++struct sctp_paddrparams {
++	sctp_assoc_t		spp_assoc_id;
++	struct sockaddr_storage	spp_address;
++	__u32			spp_hbinterval;
++	__u16			spp_pathmaxrxt;
++	__u32			spp_pathmtu;
++	__u32			spp_sackdelay;
++	__u32			spp_flags;
++} __attribute__((packed, aligned(4)));
++
++/*
++ * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)
++ *
++ * This set option adds a chunk type that the user is requesting to be
++ * received only in an authenticated way.  Changes to the list of chunks
++ * will only effect future associations on the socket.
++ */
++struct sctp_authchunk {
++	__u8		sauth_chunk;
++};
++
++/*
++ * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)
++ *
++ * This option gets or sets the list of HMAC algorithms that the local
++ * endpoint requires the peer to use.
++ */
++#ifndef __KERNEL__
++/* This here is only used by user space as is. It might not be a good idea
++ * to export/reveal the whole structure with reserved fields etc.
++ */
++enum {
++	SCTP_AUTH_HMAC_ID_SHA1 = 1,
++	SCTP_AUTH_HMAC_ID_SHA256 = 3,
++};
++#endif
++
++struct sctp_hmacalgo {
++	__u32		shmac_num_idents;
++	__u16		shmac_idents[];
++};
++
++/* Sadly, user and kernel space have different names for
++ * this structure member, so this is to not break anything.
++ */
++#define shmac_number_of_idents	shmac_num_idents
++
++/*
++ * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)
++ *
++ * This option will set a shared secret key which is used to build an
++ * association shared key.
++ */
++struct sctp_authkey {
++	sctp_assoc_t	sca_assoc_id;
++	__u16		sca_keynumber;
++	__u16		sca_keylength;
++	__u8		sca_key[];
++};
++
++/*
++ * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)
++ *
++ * This option will get or set the active shared key to be used to build
++ * the association shared key.
++ */
++
++struct sctp_authkeyid {
++	sctp_assoc_t	scact_assoc_id;
++	__u16		scact_keynumber;
++};
++
++
++/*
++ * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)
++ *
++ * This option will effect the way delayed acks are performed.  This
++ * option allows you to get or set the delayed ack time, in
++ * milliseconds.  It also allows changing the delayed ack frequency.
++ * Changing the frequency to 1 disables the delayed sack algorithm.  If
++ * the assoc_id is 0, then this sets or gets the endpoints default
++ * values.  If the assoc_id field is non-zero, then the set or get
++ * effects the specified association for the one to many model (the
++ * assoc_id field is ignored by the one to one model).  Note that if
++ * sack_delay or sack_freq are 0 when setting this option, then the
++ * current values will remain unchanged.
++ */
++struct sctp_sack_info {
++	sctp_assoc_t	sack_assoc_id;
++	uint32_t	sack_delay;
++	uint32_t	sack_freq;
++};
++
++struct sctp_assoc_value {
++    sctp_assoc_t            assoc_id;
++    uint32_t                assoc_value;
++};
++
++/*
++ * 7.2.2 Peer Address Information
++ *
++ *   Applications can retrieve information about a specific peer address
++ *   of an association, including its reachability state, congestion
++ *   window, and retransmission timer values.  This information is
++ *   read-only. The following structure is used to access this
++ *   information:
++ */
++struct sctp_paddrinfo {
++	sctp_assoc_t		spinfo_assoc_id;
++	struct sockaddr_storage	spinfo_address;
++	__s32			spinfo_state;
++	__u32			spinfo_cwnd;
++	__u32			spinfo_srtt;
++	__u32			spinfo_rto;
++	__u32			spinfo_mtu;
++} __attribute__((packed, aligned(4)));
++
++/* Peer addresses's state. */
++/* UNKNOWN: Peer address passed by the upper layer in sendmsg or connect[x]
++ * calls.
++ * UNCONFIRMED: Peer address received in INIT/INIT-ACK address parameters.
++ *              Not yet confirmed by a heartbeat and not available for data
++ *		transfers.
++ * ACTIVE : Peer address confirmed, active and available for data transfers.
++ * INACTIVE: Peer address inactive and not available for data transfers.
++ */
++enum sctp_spinfo_state {
++	SCTP_INACTIVE,
++	SCTP_PF,
++	SCTP_ACTIVE,
++	SCTP_UNCONFIRMED,
++	SCTP_UNKNOWN = 0xffff  /* Value used for transport state unknown */
++};
++
++/*
++ * 7.2.1 Association Status (SCTP_STATUS)
++ *
++ *   Applications can retrieve current status information about an
++ *   association, including association state, peer receiver window size,
++ *   number of unacked data chunks, and number of data chunks pending
++ *   receipt.  This information is read-only.  The following structure is
++ *   used to access this information:
++ */
++struct sctp_status {
++	sctp_assoc_t		sstat_assoc_id;
++	__s32			sstat_state;
++	__u32			sstat_rwnd;
++	__u16			sstat_unackdata;
++	__u16			sstat_penddata;
++	__u16			sstat_instrms;
++	__u16			sstat_outstrms;
++	__u32			sstat_fragmentation_point;
++	struct sctp_paddrinfo	sstat_primary;
++};
++
++/*
++ * 7.2.3.  Get the list of chunks the peer requires to be authenticated
++ *         (SCTP_PEER_AUTH_CHUNKS)
++ *
++ * This option gets a list of chunks for a specified association that
++ * the peer requires to be received authenticated only.
++ */
++struct sctp_authchunks {
++	sctp_assoc_t	gauth_assoc_id;
++	__u32		gauth_number_of_chunks;
++	uint8_t		gauth_chunks[];
++};
++
++/* The broken spelling has been released already in lksctp-tools header,
++ * so don't break anyone, now that it's fixed.
++ */
++#define guth_number_of_chunks	gauth_number_of_chunks
++
++/* Association states.  */
++enum sctp_sstat_state {
++	SCTP_EMPTY                = 0,
++	SCTP_CLOSED               = 1,
++	SCTP_COOKIE_WAIT          = 2,
++	SCTP_COOKIE_ECHOED        = 3,
++	SCTP_ESTABLISHED          = 4,
++	SCTP_SHUTDOWN_PENDING     = 5,
++	SCTP_SHUTDOWN_SENT        = 6,
++	SCTP_SHUTDOWN_RECEIVED    = 7,
++	SCTP_SHUTDOWN_ACK_SENT    = 8,
++};
++
++/*
++ * 8.2.6. Get the Current Identifiers of Associations
++ *        (SCTP_GET_ASSOC_ID_LIST)
++ *
++ * This option gets the current list of SCTP association identifiers of
++ * the SCTP associations handled by a one-to-many style socket.
++ */
++struct sctp_assoc_ids {
++	__u32		gaids_number_of_ids;
++	sctp_assoc_t	gaids_assoc_id[];
++};
++
++/*
++ * 8.3, 8.5 get all peer/local addresses in an association.
++ * This parameter struct is used by SCTP_GET_PEER_ADDRS and
++ * SCTP_GET_LOCAL_ADDRS socket options used internally to implement
++ * sctp_getpaddrs() and sctp_getladdrs() API.
++ */
++struct sctp_getaddrs_old {
++	sctp_assoc_t            assoc_id;
++	int			addr_num;
++#ifdef __KERNEL__
++	struct sockaddr		__user *addrs;
++#else
++	struct sockaddr		*addrs;
++#endif
++};
++
++struct sctp_getaddrs {
++	sctp_assoc_t		assoc_id; /*input*/
++	__u32			addr_num; /*output*/
++	__u8			addrs[0]; /*output, variable size*/
++};
++
++/* A socket user request obtained via SCTP_GET_ASSOC_STATS that retrieves
++ * association stats. All stats are counts except sas_maxrto and
++ * sas_obs_rto_ipaddr. maxrto is the max observed rto + transport since
++ * the last call. Will return 0 when RTO was not update since last call
++ */
++struct sctp_assoc_stats {
++	sctp_assoc_t	sas_assoc_id;    /* Input */
++					 /* Transport of observed max RTO */
++	struct sockaddr_storage sas_obs_rto_ipaddr;
++	__u64		sas_maxrto;      /* Maximum Observed RTO for period */
++	__u64		sas_isacks;	 /* SACKs received */
++	__u64		sas_osacks;	 /* SACKs sent */
++	__u64		sas_opackets;	 /* Packets sent */
++	__u64		sas_ipackets;	 /* Packets received */
++	__u64		sas_rtxchunks;   /* Retransmitted Chunks */
++	__u64		sas_outofseqtsns;/* TSN received > next expected */
++	__u64		sas_idupchunks;  /* Dups received (ordered+unordered) */
++	__u64		sas_gapcnt;      /* Gap Acknowledgements Received */
++	__u64		sas_ouodchunks;  /* Unordered data chunks sent */
++	__u64		sas_iuodchunks;  /* Unordered data chunks received */
++	__u64		sas_oodchunks;	 /* Ordered data chunks sent */
++	__u64		sas_iodchunks;	 /* Ordered data chunks received */
++	__u64		sas_octrlchunks; /* Control chunks sent */
++	__u64		sas_ictrlchunks; /* Control chunks received */
++};
++
++/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
++/* On user space Linux, these live in <bits/socket.h> as an enum.  */
++enum sctp_msg_flags {
++	MSG_NOTIFICATION = 0x8000,
++#define MSG_NOTIFICATION MSG_NOTIFICATION
++};
++
++/*
++ * 8.1 sctp_bindx()
++ *
++ * The flags parameter is formed from the bitwise OR of zero or more of the
++ * following currently defined flags:
++ */
++#define SCTP_BINDX_ADD_ADDR 0x01
++#define SCTP_BINDX_REM_ADDR 0x02
++
++/* This is the structure that is passed as an argument(optval) to
++ * getsockopt(SCTP_SOCKOPT_PEELOFF).
++ */
++typedef struct {
++	sctp_assoc_t associd;
++	int sd;
++} sctp_peeloff_arg_t;
++
++/*
++ *  Peer Address Thresholds socket option
++ */
++struct sctp_paddrthlds {
++	sctp_assoc_t spt_assoc_id;
++	struct sockaddr_storage spt_address;
++	__u16 spt_pathmaxrxt;
++	__u16 spt_pathpfthld;
++};
++
++#endif /* _UAPI_SCTP_H */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-993-add-btrfs-headers.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-993-add-btrfs-headers.patch
new file mode 100644
index 0000000..016c58f
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-993-add-btrfs-headers.patch
@@ -0,0 +1,652 @@
+diff --git a/include/linux/btrfs.h b/include/linux/btrfs.h
+new file mode 100644
+index 0000000..22d7991
+--- /dev/null
++++ b/include/linux/btrfs.h
+@@ -0,0 +1,6 @@
++#ifndef _LINUX_BTRFS_H
++#define _LINUX_BTRFS_H
++
++#include <uapi/linux/btrfs.h>
++
++#endif /* _LINUX_BTRFS_H */
+diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
+index 4e67194..5c8a1d2 100644
+--- a/include/uapi/linux/Kbuild
++++ b/include/uapi/linux/Kbuild
+@@ -68,6 +68,7 @@ header-y += blkpg.h
+ header-y += blktrace_api.h
+ header-y += bpqether.h
+ header-y += bsg.h
++header-y += btrfs.h
+ header-y += can.h
+ header-y += capability.h
+ header-y += capi.h
+diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
+new file mode 100644
+index 0000000..b4d6909
+--- /dev/null
++++ b/include/uapi/linux/btrfs.h
+@@ -0,0 +1,622 @@
++/*
++ * Copyright (C) 2007 Oracle.  All rights reserved.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public
++ * License v2 as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public
++ * License along with this program; if not, write to the
++ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
++ * Boston, MA 021110-1307, USA.
++ */
++
++#ifndef _UAPI_LINUX_BTRFS_H
++#define _UAPI_LINUX_BTRFS_H
++#include <linux/types.h>
++#include <linux/ioctl.h>
++
++#define BTRFS_IOCTL_MAGIC 0x94
++#define BTRFS_VOL_NAME_MAX 255
++
++/* this should be 4k */
++#define BTRFS_PATH_NAME_MAX 4087
++struct btrfs_ioctl_vol_args {
++	__s64 fd;
++	char name[BTRFS_PATH_NAME_MAX + 1];
++};
++
++#define BTRFS_DEVICE_PATH_NAME_MAX 1024
++
++#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
++#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
++#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
++#define BTRFS_FSID_SIZE 16
++#define BTRFS_UUID_SIZE 16
++
++#define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
++
++struct btrfs_qgroup_limit {
++	__u64	flags;
++	__u64	max_rfer;
++	__u64	max_excl;
++	__u64	rsv_rfer;
++	__u64	rsv_excl;
++};
++
++struct btrfs_qgroup_inherit {
++	__u64	flags;
++	__u64	num_qgroups;
++	__u64	num_ref_copies;
++	__u64	num_excl_copies;
++	struct btrfs_qgroup_limit lim;
++	__u64	qgroups[0];
++};
++
++struct btrfs_ioctl_qgroup_limit_args {
++	__u64	qgroupid;
++	struct btrfs_qgroup_limit lim;
++};
++
++#define BTRFS_SUBVOL_NAME_MAX 4039
++struct btrfs_ioctl_vol_args_v2 {
++	__s64 fd;
++	__u64 transid;
++	__u64 flags;
++	union {
++		struct {
++			__u64 size;
++			struct btrfs_qgroup_inherit __user *qgroup_inherit;
++		};
++		__u64 unused[4];
++	};
++	char name[BTRFS_SUBVOL_NAME_MAX + 1];
++};
++
++/*
++ * structure to report errors and progress to userspace, either as a
++ * result of a finished scrub, a canceled scrub or a progress inquiry
++ */
++struct btrfs_scrub_progress {
++	__u64 data_extents_scrubbed;	/* # of data extents scrubbed */
++	__u64 tree_extents_scrubbed;	/* # of tree extents scrubbed */
++	__u64 data_bytes_scrubbed;	/* # of data bytes scrubbed */
++	__u64 tree_bytes_scrubbed;	/* # of tree bytes scrubbed */
++	__u64 read_errors;		/* # of read errors encountered (EIO) */
++	__u64 csum_errors;		/* # of failed csum checks */
++	__u64 verify_errors;		/* # of occurences, where the metadata
++					 * of a tree block did not match the
++					 * expected values, like generation or
++					 * logical */
++	__u64 no_csum;			/* # of 4k data block for which no csum
++					 * is present, probably the result of
++					 * data written with nodatasum */
++	__u64 csum_discards;		/* # of csum for which no data was found
++					 * in the extent tree. */
++	__u64 super_errors;		/* # of bad super blocks encountered */
++	__u64 malloc_errors;		/* # of internal kmalloc errors. These
++					 * will likely cause an incomplete
++					 * scrub */
++	__u64 uncorrectable_errors;	/* # of errors where either no intact
++					 * copy was found or the writeback
++					 * failed */
++	__u64 corrected_errors;		/* # of errors corrected */
++	__u64 last_physical;		/* last physical address scrubbed. In
++					 * case a scrub was aborted, this can
++					 * be used to restart the scrub */
++	__u64 unverified_errors;	/* # of occurences where a read for a
++					 * full (64k) bio failed, but the re-
++					 * check succeeded for each 4k piece.
++					 * Intermittent error. */
++};
++
++#define BTRFS_SCRUB_READONLY	1
++struct btrfs_ioctl_scrub_args {
++	__u64 devid;				/* in */
++	__u64 start;				/* in */
++	__u64 end;				/* in */
++	__u64 flags;				/* in */
++	struct btrfs_scrub_progress progress;	/* out */
++	/* pad to 1k */
++	__u64 unused[(1024-32-sizeof(struct btrfs_scrub_progress))/8];
++};
++
++#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS	0
++#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID	1
++struct btrfs_ioctl_dev_replace_start_params {
++	__u64 srcdevid;	/* in, if 0, use srcdev_name instead */
++	__u64 cont_reading_from_srcdev_mode;	/* in, see #define
++						 * above */
++	__u8 srcdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
++	__u8 tgtdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
++};
++
++#define BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED	0
++#define BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED		1
++#define BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED		2
++#define BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED		3
++#define BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED		4
++struct btrfs_ioctl_dev_replace_status_params {
++	__u64 replace_state;	/* out, see #define above */
++	__u64 progress_1000;	/* out, 0 <= x <= 1000 */
++	__u64 time_started;	/* out, seconds since 1-Jan-1970 */
++	__u64 time_stopped;	/* out, seconds since 1-Jan-1970 */
++	__u64 num_write_errors;	/* out */
++	__u64 num_uncorrectable_read_errors;	/* out */
++};
++
++#define BTRFS_IOCTL_DEV_REPLACE_CMD_START			0
++#define BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS			1
++#define BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL			2
++#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR			0
++#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED		1
++#define BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED		2
++struct btrfs_ioctl_dev_replace_args {
++	__u64 cmd;	/* in */
++	__u64 result;	/* out */
++
++	union {
++		struct btrfs_ioctl_dev_replace_start_params start;
++		struct btrfs_ioctl_dev_replace_status_params status;
++	};	/* in/out */
++
++	__u64 spare[64];
++};
++
++struct btrfs_ioctl_dev_info_args {
++	__u64 devid;				/* in/out */
++	__u8 uuid[BTRFS_UUID_SIZE];		/* in/out */
++	__u64 bytes_used;			/* out */
++	__u64 total_bytes;			/* out */
++	__u64 unused[379];			/* pad to 4k */
++	__u8 path[BTRFS_DEVICE_PATH_NAME_MAX];	/* out */
++};
++
++struct btrfs_ioctl_fs_info_args {
++	__u64 max_id;				/* out */
++	__u64 num_devices;			/* out */
++	__u8 fsid[BTRFS_FSID_SIZE];		/* out */
++	__u64 reserved[124];			/* pad to 1k */
++};
++
++struct btrfs_ioctl_feature_flags {
++	__u64 compat_flags;
++	__u64 compat_ro_flags;
++	__u64 incompat_flags;
++};
++
++/* balance control ioctl modes */
++#define BTRFS_BALANCE_CTL_PAUSE		1
++#define BTRFS_BALANCE_CTL_CANCEL	2
++
++/*
++ * this is packed, because it should be exactly the same as its disk
++ * byte order counterpart (struct btrfs_disk_balance_args)
++ */
++struct btrfs_balance_args {
++	__u64 profiles;
++	__u64 usage;
++	__u64 devid;
++	__u64 pstart;
++	__u64 pend;
++	__u64 vstart;
++	__u64 vend;
++
++	__u64 target;
++
++	__u64 flags;
++
++	__u64 unused[8];
++} __attribute__ ((__packed__));
++
++/* report balance progress to userspace */
++struct btrfs_balance_progress {
++	__u64 expected;		/* estimated # of chunks that will be
++				 * relocated to fulfill the request */
++	__u64 considered;	/* # of chunks we have considered so far */
++	__u64 completed;	/* # of chunks relocated so far */
++};
++
++#define BTRFS_BALANCE_STATE_RUNNING	(1ULL << 0)
++#define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 1)
++#define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)
++
++struct btrfs_ioctl_balance_args {
++	__u64 flags;				/* in/out */
++	__u64 state;				/* out */
++
++	struct btrfs_balance_args data;		/* in/out */
++	struct btrfs_balance_args meta;		/* in/out */
++	struct btrfs_balance_args sys;		/* in/out */
++
++	struct btrfs_balance_progress stat;	/* out */
++
++	__u64 unused[72];			/* pad to 1k */
++};
++
++#define BTRFS_INO_LOOKUP_PATH_MAX 4080
++struct btrfs_ioctl_ino_lookup_args {
++	__u64 treeid;
++	__u64 objectid;
++	char name[BTRFS_INO_LOOKUP_PATH_MAX];
++};
++
++struct btrfs_ioctl_search_key {
++	/* which root are we searching.  0 is the tree of tree roots */
++	__u64 tree_id;
++
++	/* keys returned will be >= min and <= max */
++	__u64 min_objectid;
++	__u64 max_objectid;
++
++	/* keys returned will be >= min and <= max */
++	__u64 min_offset;
++	__u64 max_offset;
++
++	/* max and min transids to search for */
++	__u64 min_transid;
++	__u64 max_transid;
++
++	/* keys returned will be >= min and <= max */
++	__u32 min_type;
++	__u32 max_type;
++
++	/*
++	 * how many items did userland ask for, and how many are we
++	 * returning
++	 */
++	__u32 nr_items;
++
++	/* align to 64 bits */
++	__u32 unused;
++
++	/* some extra for later */
++	__u64 unused1;
++	__u64 unused2;
++	__u64 unused3;
++	__u64 unused4;
++};
++
++struct btrfs_ioctl_search_header {
++	__u64 transid;
++	__u64 objectid;
++	__u64 offset;
++	__u32 type;
++	__u32 len;
++};
++
++#define BTRFS_SEARCH_ARGS_BUFSIZE (4096 - sizeof(struct btrfs_ioctl_search_key))
++/*
++ * the buf is an array of search headers where
++ * each header is followed by the actual item
++ * the type field is expanded to 32 bits for alignment
++ */
++struct btrfs_ioctl_search_args {
++	struct btrfs_ioctl_search_key key;
++	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];
++};
++
++struct btrfs_ioctl_clone_range_args {
++  __s64 src_fd;
++  __u64 src_offset, src_length;
++  __u64 dest_offset;
++};
++
++/* flags for the defrag range ioctl */
++#define BTRFS_DEFRAG_RANGE_COMPRESS 1
++#define BTRFS_DEFRAG_RANGE_START_IO 2
++
++#define BTRFS_SAME_DATA_DIFFERS	1
++/* For extent-same ioctl */
++struct btrfs_ioctl_same_extent_info {
++	__s64 fd;		/* in - destination file */
++	__u64 logical_offset;	/* in - start of extent in destination */
++	__u64 bytes_deduped;	/* out - total # of bytes we were able
++				 * to dedupe from this file */
++	/* status of this dedupe operation:
++	 * 0 if dedup succeeds
++	 * < 0 for error
++	 * == BTRFS_SAME_DATA_DIFFERS if data differs
++	 */
++	__s32 status;		/* out - see above description */
++	__u32 reserved;
++};
++
++struct btrfs_ioctl_same_args {
++	__u64 logical_offset;	/* in - start of extent in source */
++	__u64 length;		/* in - length of extent */
++	__u16 dest_count;	/* in - total elements in info array */
++	__u16 reserved1;
++	__u32 reserved2;
++	struct btrfs_ioctl_same_extent_info info[0];
++};
++
++struct btrfs_ioctl_space_info {
++	__u64 flags;
++	__u64 total_bytes;
++	__u64 used_bytes;
++};
++
++struct btrfs_ioctl_space_args {
++	__u64 space_slots;
++	__u64 total_spaces;
++	struct btrfs_ioctl_space_info spaces[0];
++};
++
++struct btrfs_data_container {
++	__u32	bytes_left;	/* out -- bytes not needed to deliver output */
++	__u32	bytes_missing;	/* out -- additional bytes needed for result */
++	__u32	elem_cnt;	/* out */
++	__u32	elem_missed;	/* out */
++	__u64	val[0];		/* out */
++};
++
++struct btrfs_ioctl_ino_path_args {
++	__u64				inum;		/* in */
++	__u64				size;		/* in */
++	__u64				reserved[4];
++	/* struct btrfs_data_container	*fspath;	   out */
++	__u64				fspath;		/* out */
++};
++
++struct btrfs_ioctl_logical_ino_args {
++	__u64				logical;	/* in */
++	__u64				size;		/* in */
++	__u64				reserved[4];
++	/* struct btrfs_data_container	*inodes;	out   */
++	__u64				inodes;
++};
++
++enum btrfs_dev_stat_values {
++	/* disk I/O failure stats */
++	BTRFS_DEV_STAT_WRITE_ERRS, /* EIO or EREMOTEIO from lower layers */
++	BTRFS_DEV_STAT_READ_ERRS, /* EIO or EREMOTEIO from lower layers */
++	BTRFS_DEV_STAT_FLUSH_ERRS, /* EIO or EREMOTEIO from lower layers */
++
++	/* stats for indirect indications for I/O failures */
++	BTRFS_DEV_STAT_CORRUPTION_ERRS, /* checksum error, bytenr error or
++					 * contents is illegal: this is an
++					 * indication that the block was damaged
++					 * during read or write, or written to
++					 * wrong location or read from wrong
++					 * location */
++	BTRFS_DEV_STAT_GENERATION_ERRS, /* an indication that blocks have not
++					 * been written */
++
++	BTRFS_DEV_STAT_VALUES_MAX
++};
++
++/* Reset statistics after reading; needs SYS_ADMIN capability */
++#define	BTRFS_DEV_STATS_RESET		(1ULL << 0)
++
++struct btrfs_ioctl_get_dev_stats {
++	__u64 devid;				/* in */
++	__u64 nr_items;				/* in/out */
++	__u64 flags;				/* in/out */
++
++	/* out values: */
++	__u64 values[BTRFS_DEV_STAT_VALUES_MAX];
++
++	__u64 unused[128 - 2 - BTRFS_DEV_STAT_VALUES_MAX]; /* pad to 1k */
++};
++
++#define BTRFS_QUOTA_CTL_ENABLE	1
++#define BTRFS_QUOTA_CTL_DISABLE	2
++#define BTRFS_QUOTA_CTL_RESCAN__NOTUSED	3
++struct btrfs_ioctl_quota_ctl_args {
++	__u64 cmd;
++	__u64 status;
++};
++
++struct btrfs_ioctl_quota_rescan_args {
++	__u64	flags;
++	__u64   progress;
++	__u64   reserved[6];
++};
++
++struct btrfs_ioctl_qgroup_assign_args {
++	__u64 assign;
++	__u64 src;
++	__u64 dst;
++};
++
++struct btrfs_ioctl_qgroup_create_args {
++	__u64 create;
++	__u64 qgroupid;
++};
++struct btrfs_ioctl_timespec {
++	__u64 sec;
++	__u32 nsec;
++};
++
++struct btrfs_ioctl_received_subvol_args {
++	char	uuid[BTRFS_UUID_SIZE];	/* in */
++	__u64	stransid;		/* in */
++	__u64	rtransid;		/* out */
++	struct btrfs_ioctl_timespec stime; /* in */
++	struct btrfs_ioctl_timespec rtime; /* out */
++	__u64	flags;			/* in */
++	__u64	reserved[16];		/* in */
++};
++
++/*
++ * Caller doesn't want file data in the send stream, even if the
++ * search of clone sources doesn't find an extent. UPDATE_EXTENT
++ * commands will be sent instead of WRITE commands.
++ */
++#define BTRFS_SEND_FLAG_NO_FILE_DATA		0x1
++
++/*
++ * Do not add the leading stream header. Used when multiple snapshots
++ * are sent back to back.
++ */
++#define BTRFS_SEND_FLAG_OMIT_STREAM_HEADER	0x2
++
++/*
++ * Omit the command at the end of the stream that indicated the end
++ * of the stream. This option is used when multiple snapshots are
++ * sent back to back.
++ */
++#define BTRFS_SEND_FLAG_OMIT_END_CMD		0x4
++
++#define BTRFS_SEND_FLAG_MASK \
++	(BTRFS_SEND_FLAG_NO_FILE_DATA | \
++	 BTRFS_SEND_FLAG_OMIT_STREAM_HEADER | \
++	 BTRFS_SEND_FLAG_OMIT_END_CMD)
++
++struct btrfs_ioctl_send_args {
++	__s64 send_fd;			/* in */
++	__u64 clone_sources_count;	/* in */
++	__u64 __user *clone_sources;	/* in */
++	__u64 parent_root;		/* in */
++	__u64 flags;			/* in */
++	__u64 reserved[4];		/* in */
++};
++
++/* Error codes as returned by the kernel */
++enum btrfs_err_code {
++	notused,
++	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET,
++	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET,
++	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET,
++	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET,
++	BTRFS_ERROR_DEV_TGT_REPLACE,
++	BTRFS_ERROR_DEV_MISSING_NOT_FOUND,
++	BTRFS_ERROR_DEV_ONLY_WRITABLE,
++	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS
++};
++/* An error code to error string mapping for the kernel
++*  error codes
++*/
++static inline char *btrfs_err_str(enum btrfs_err_code err_code)
++{
++	switch (err_code) {
++		case BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET:
++			return "unable to go below two devices on raid1";
++		case BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET:
++			return "unable to go below four devices on raid10";
++		case BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET:
++			return "unable to go below two devices on raid5";
++		case BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET:
++			return "unable to go below three devices on raid6";
++		case BTRFS_ERROR_DEV_TGT_REPLACE:
++			return "unable to remove the dev_replace target dev";
++		case BTRFS_ERROR_DEV_MISSING_NOT_FOUND:
++			return "no missing devices found to remove";
++		case BTRFS_ERROR_DEV_ONLY_WRITABLE:
++			return "unable to remove the only writeable device";
++		case BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS:
++			return "add/delete/balance/replace/resize operation "\
++				"in progress";
++		default:
++			return NULL;
++	}
++}
++
++#define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_DEFRAG _IOW(BTRFS_IOCTL_MAGIC, 2, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_RESIZE _IOW(BTRFS_IOCTL_MAGIC, 3, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \
++				   struct btrfs_ioctl_vol_args)
++/* trans start and trans end are dangerous, and only for
++ * use by applications that know how to avoid the
++ * resulting deadlocks
++ */
++#define BTRFS_IOC_TRANS_START  _IO(BTRFS_IOCTL_MAGIC, 6)
++#define BTRFS_IOC_TRANS_END    _IO(BTRFS_IOCTL_MAGIC, 7)
++#define BTRFS_IOC_SYNC         _IO(BTRFS_IOCTL_MAGIC, 8)
++
++#define BTRFS_IOC_CLONE        _IOW(BTRFS_IOCTL_MAGIC, 9, int)
++#define BTRFS_IOC_ADD_DEV _IOW(BTRFS_IOCTL_MAGIC, 10, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_RM_DEV _IOW(BTRFS_IOCTL_MAGIC, 11, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_BALANCE _IOW(BTRFS_IOCTL_MAGIC, 12, \
++				   struct btrfs_ioctl_vol_args)
++
++#define BTRFS_IOC_CLONE_RANGE _IOW(BTRFS_IOCTL_MAGIC, 13, \
++				  struct btrfs_ioctl_clone_range_args)
++
++#define BTRFS_IOC_SUBVOL_CREATE _IOW(BTRFS_IOCTL_MAGIC, 14, \
++				   struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_SNAP_DESTROY _IOW(BTRFS_IOCTL_MAGIC, 15, \
++				struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_DEFRAG_RANGE _IOW(BTRFS_IOCTL_MAGIC, 16, \
++				struct btrfs_ioctl_defrag_range_args)
++#define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \
++				   struct btrfs_ioctl_search_args)
++#define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
++				   struct btrfs_ioctl_ino_lookup_args)
++#define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
++#define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
++				    struct btrfs_ioctl_space_args)
++#define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)
++#define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)
++#define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \
++				   struct btrfs_ioctl_vol_args_v2)
++#define BTRFS_IOC_SUBVOL_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 24, \
++				   struct btrfs_ioctl_vol_args_v2)
++#define BTRFS_IOC_SUBVOL_GETFLAGS _IOR(BTRFS_IOCTL_MAGIC, 25, __u64)
++#define BTRFS_IOC_SUBVOL_SETFLAGS _IOW(BTRFS_IOCTL_MAGIC, 26, __u64)
++#define BTRFS_IOC_SCRUB _IOWR(BTRFS_IOCTL_MAGIC, 27, \
++			      struct btrfs_ioctl_scrub_args)
++#define BTRFS_IOC_SCRUB_CANCEL _IO(BTRFS_IOCTL_MAGIC, 28)
++#define BTRFS_IOC_SCRUB_PROGRESS _IOWR(BTRFS_IOCTL_MAGIC, 29, \
++				       struct btrfs_ioctl_scrub_args)
++#define BTRFS_IOC_DEV_INFO _IOWR(BTRFS_IOCTL_MAGIC, 30, \
++				 struct btrfs_ioctl_dev_info_args)
++#define BTRFS_IOC_FS_INFO _IOR(BTRFS_IOCTL_MAGIC, 31, \
++			       struct btrfs_ioctl_fs_info_args)
++#define BTRFS_IOC_BALANCE_V2 _IOWR(BTRFS_IOCTL_MAGIC, 32, \
++				   struct btrfs_ioctl_balance_args)
++#define BTRFS_IOC_BALANCE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)
++#define BTRFS_IOC_BALANCE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \
++					struct btrfs_ioctl_balance_args)
++#define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \
++					struct btrfs_ioctl_ino_path_args)
++#define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \
++					struct btrfs_ioctl_ino_path_args)
++#define BTRFS_IOC_SET_RECEIVED_SUBVOL _IOWR(BTRFS_IOCTL_MAGIC, 37, \
++				struct btrfs_ioctl_received_subvol_args)
++#define BTRFS_IOC_SEND _IOW(BTRFS_IOCTL_MAGIC, 38, struct btrfs_ioctl_send_args)
++#define BTRFS_IOC_DEVICES_READY _IOR(BTRFS_IOCTL_MAGIC, 39, \
++				     struct btrfs_ioctl_vol_args)
++#define BTRFS_IOC_QUOTA_CTL _IOWR(BTRFS_IOCTL_MAGIC, 40, \
++			       struct btrfs_ioctl_quota_ctl_args)
++#define BTRFS_IOC_QGROUP_ASSIGN _IOW(BTRFS_IOCTL_MAGIC, 41, \
++			       struct btrfs_ioctl_qgroup_assign_args)
++#define BTRFS_IOC_QGROUP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 42, \
++			       struct btrfs_ioctl_qgroup_create_args)
++#define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \
++			       struct btrfs_ioctl_qgroup_limit_args)
++#define BTRFS_IOC_QUOTA_RESCAN _IOW(BTRFS_IOCTL_MAGIC, 44, \
++			       struct btrfs_ioctl_quota_rescan_args)
++#define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \
++			       struct btrfs_ioctl_quota_rescan_args)
++#define BTRFS_IOC_QUOTA_RESCAN_WAIT _IO(BTRFS_IOCTL_MAGIC, 46)
++#define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
++				   char[BTRFS_LABEL_SIZE])
++#define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \
++				   char[BTRFS_LABEL_SIZE])
++#define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
++				      struct btrfs_ioctl_get_dev_stats)
++#define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \
++				    struct btrfs_ioctl_dev_replace_args)
++#define BTRFS_IOC_FILE_EXTENT_SAME _IOWR(BTRFS_IOCTL_MAGIC, 54, \
++					 struct btrfs_ioctl_same_args)
++#define BTRFS_IOC_GET_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
++				   struct btrfs_ioctl_feature_flags)
++#define BTRFS_IOC_SET_FEATURES _IOW(BTRFS_IOCTL_MAGIC, 57, \
++				   struct btrfs_ioctl_feature_flags[2])
++#define BTRFS_IOC_GET_SUPPORTED_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
++				   struct btrfs_ioctl_feature_flags[3])
++
++#endif /* _UAPI_LINUX_BTRFS_H */
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-994-remove-aufs-headers-install.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-994-remove-aufs-headers-install.patch
new file mode 100644
index 0000000..9a5fdf9
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-994-remove-aufs-headers-install.patch
@@ -0,0 +1,12 @@
+diff --git a/ubuntu/include/linux/Kbuild b/ubuntu/include/linux/Kbuild
+index 50d9e8c..e69de29 100644
+--- a/ubuntu/include/linux/Kbuild
++++ b/ubuntu/include/linux/Kbuild
+@@ -1 +0,0 @@
+-header-y += aufs_type.h
+diff --git a/ubuntu/include/uapi/linux/Kbuild b/ubuntu/include/uapi/linux/Kbuild
+index e1b2bd3..e69de29 100644
+--- a/ubuntu/include/uapi/linux/Kbuild
++++ b/ubuntu/include/uapi/linux/Kbuild
+@@ -1 +0,0 @@
+-header-y = aufs_type.h
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-995-CX24120-13Z_frontend.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-995-CX24120-13Z_frontend.patch
new file mode 100644
index 0000000..41d0f1d
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-995-CX24120-13Z_frontend.patch
@@ -0,0 +1,1577 @@
+http://patchwork.linuxtv.org/patch/10575/
+modified for 3.7.10
+
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/flexcop-common.h linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-common.h
+--- linux-3.4-r1/drivers/media/common/b2c2/flexcop-common.h	2012-04-03 15:23:44.824143495 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-common.h	2012-04-03 15:26:40.756140116 +0400
+@@ -91,6 +91,8 @@ 
+ 	int feedcount;
+ 	int pid_filtering;
+ 	int fullts_streaming_state;
++	/* the stream will be activated by an externally (by the fe for example) */
++	int need_external_stream_control;
+ 
+ 	/* bus specific callbacks */
+ 	flexcop_ibi_value(*read_ibi_reg) (struct flexcop_device *,
+@@ -177,6 +179,8 @@ 
+ 		struct dvb_demux_feed *dvbdmxfeed, int onoff);
+ void flexcop_hw_filter_init(struct flexcop_device *fc);
+ 
++extern void flexcop_external_stream_control(struct dvb_frontend *fe, u8 onoff);
++
+ void flexcop_smc_ctrl(struct flexcop_device *fc, int onoff);
+ 
+ void flexcop_set_mac_filter(struct flexcop_device *fc, u8 mac[6]);
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/flexcop-fe-tuner.c linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-fe-tuner.c
+--- linux-3.4-r1/drivers/media/common/b2c2/flexcop-fe-tuner.c	2012-04-03 15:23:44.828143388 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-fe-tuner.c	2012-04-03 15:26:40.760141513 +0400
+@@ -12,6 +12,7 @@ 
+ #include "cx24113.h"
+ #include "cx24123.h"
+ #include "isl6421.h"
++#include "cx24120.h"
+ #include "mt352.h"
+ #include "bcm3510.h"
+ #include "nxt200x.h"
+@@ -26,6 +27,15 @@ 
+ #define FE_SUPPORTED(fe) (defined(CONFIG_DVB_##fe) || \
+ 	(defined(CONFIG_DVB_##fe##_MODULE) && defined(MODULE)))
+ 
++#if FE_SUPPORTED(BCM3510) || FE_SUPPORTED(CX24120)
++static int flexcop_fe_request_firmware(struct dvb_frontend *fe,
++	const struct firmware **fw, char* name)
++{
++	struct flexcop_device *fc = fe->dvb->priv;
++	return request_firmware(fw, name, fc->dev);
++}
++#endif
++
+ /* lnb control */
+ #if FE_SUPPORTED(MT312) || FE_SUPPORTED(STV0299)
+ static int flexcop_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+@@ -445,13 +455,6 @@ 
+ 
+ /* AirStar ATSC 1st generation */
+ #if FE_SUPPORTED(BCM3510)
+-static int flexcop_fe_request_firmware(struct dvb_frontend *fe,
+-	const struct firmware **fw, char* name)
+-{
+-	struct flexcop_device *fc = fe->dvb->priv;
+-	return request_firmware(fw, name, fc->dev);
+-}
+-
+ static struct bcm3510_config air2pc_atsc_first_gen_config = {
+ 	.demod_address    = 0x0f,
+ 	.request_firmware = flexcop_fe_request_firmware,
+@@ -619,10 +622,40 @@ 
+ #define cablestar2_attach NULL
+ #endif
+ 
++/* SkyStar S2 PCI DVB-S/S2 card based on Conexant cx24120/cx24118 */
++#if FE_SUPPORTED(CX24120) && FE_SUPPORTED(ISL6421)
++static const struct cx24120_config skystar2_rev3_3_cx24120_config = {
++	.i2c_addr = 0x55,
++	.request_firmware = flexcop_fe_request_firmware,
++};
++
++static int skystarS2_rev33_attach(struct flexcop_device *fc, struct i2c_adapter *i2c)
++{
++//	struct dvb_frontend_ops *ops;
++	
++	fc->fe = dvb_attach(cx24120_attach,
++		&skystar2_rev3_3_cx24120_config, i2c);
++	if (fc->fe == NULL) return 0;
++	fc->dev_type = FC_SKYS2_REV33;
++	fc->fc_i2c_adap[2].no_base_addr = 1;
++	if ( (dvb_attach(isl6421_attach, fc->fe,
++		&fc->fc_i2c_adap[2].i2c_adap, 0x08, 0, 0, false) == NULL) ) {
++		err("ISL6421 could NOT be attached!");
++		return 0;
++	}
++	info("ISL6421 successfully attached.");
++//	ops = &fc->fe->ops;
++	return 1;
++}
++#else
++#define skystarS2_rev33_attach NULL
++#endif
++
+ static struct {
+ 	flexcop_device_type_t type;
+ 	int (*attach)(struct flexcop_device *, struct i2c_adapter *);
+ } flexcop_frontends[] = {
++	{ FC_SKYS2_REV33, skystarS2_rev33_attach },
+ 	{ FC_SKY_REV27, skystar2_rev27_attach },
+ 	{ FC_SKY_REV28, skystar2_rev28_attach },
+ 	{ FC_SKY_REV26, skystar2_rev26_attach },
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/flexcop-hw-filter.c linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-hw-filter.c
+--- linux-3.4-r1/drivers/media/common/b2c2/flexcop-hw-filter.c	2012-04-03 15:23:44.828143388 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-hw-filter.c	2012-04-03 15:26:40.760141513 +0400
+@@ -11,6 +11,12 @@ 
+ 	deb_ts("rcv_data is now: '%s'\n", onoff ? "on" : "off");
+ }
+ 
++void flexcop_external_stream_control(struct dvb_frontend *fe, u8 onoff)
++{
++	struct flexcop_device *fc = fe->dvb->priv;
++	flexcop_rcv_data_ctrl(fc, onoff);
++}
++
+ void flexcop_smc_ctrl(struct flexcop_device *fc, int onoff)
+ {
+ 	flexcop_set_ibi_value(ctrl_208, SMC_Enable_sig, onoff);
+@@ -199,6 +205,7 @@ 
+ 
+ 	/* if it was the first or last feed request change the stream-status */
+ 	if (fc->feedcount == onoff) {
++		if (!fc->need_external_stream_control)
+ 		flexcop_rcv_data_ctrl(fc, onoff);
+ 		if (fc->stream_control) /* device specific stream control */
+ 			fc->stream_control(fc, onoff);
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/flexcop-misc.c linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-misc.c
+--- linux-3.4-r1/drivers/media/common/b2c2/flexcop-misc.c	2012-04-03 15:23:44.832143280 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-misc.c	2012-04-03 15:26:40.760141513 +0400
+@@ -56,6 +56,7 @@ 
+ 	[FC_SKY_REV26]	= "Sky2PC/SkyStar 2 DVB-S rev 2.6",
+ 	[FC_SKY_REV27]	= "Sky2PC/SkyStar 2 DVB-S rev 2.7a/u",
+ 	[FC_SKY_REV28]	= "Sky2PC/SkyStar 2 DVB-S rev 2.8",
++	[FC_SKYS2_REV33]= "Sky2PC/SkyStar S2 DVB-S/S2 rev 3.3",
+ };
+ 
+ static const char *flexcop_bus_names[] = {
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/flexcop-reg.h linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-reg.h
+--- linux-3.4-r1/drivers/media/common/b2c2/flexcop-reg.h	2012-04-03 15:23:44.832143280 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/flexcop-reg.h	2012-04-03 15:26:40.760141513 +0400
+@@ -24,6 +24,7 @@ 
+ 	FC_SKY_REV26,
+ 	FC_SKY_REV27,
+ 	FC_SKY_REV28,
++	FC_SKYS2_REV33,
+ } flexcop_device_type_t;
+ 
+ typedef enum {
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/common/b2c2/Kconfig linux-3.4-r1-S2/drivers/media/common/b2c2/Kconfig
+--- linux-3.4-r1/drivers/media/common/b2c2/Kconfig	2012-04-03 15:23:44.824143495 +0400
++++ linux-3.4-r1-S2/drivers/media/common/b2c2/Kconfig	2012-04-03 15:26:40.760141513 +0400
+@@ -3,6 +3,7 @@
+ 	depends on DVB_CORE && I2C
+ 	depends on DVB_B2C2_FLEXCOP_PCI || DVB_B2C2_FLEXCOP_USB
+ 	default y
++	select DVB_CX24120 if !DVB_FE_CUSTOMISE
+ 	select DVB_PLL if MEDIA_SUBDRV_AUTOSELECT
+ 	select DVB_STV0299 if MEDIA_SUBDRV_AUTOSELECT
+ 	select DVB_MT352 if MEDIA_SUBDRV_AUTOSELECT
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/dvb-frontends/cx24120.c linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120.c
+--- linux-3.4-r1/drivers/media/dvb-frontends/cx24120.c	1970-01-01 03:00:00.000000000 +0300
++++ linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120.c	2012-04-03 16:10:59.000000000 +0400
+@@ -0,0 +1,1053 @@ 
++/*	
++    Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner driver
++	Version 0.0.4a	03.04.2012
++	
++	Copyright (C) 2009 Sergey Tyurin <forum.free-x.de>
++	Updated 2012 by Jannis Achstetter <jannis_achstetter@web.de>
++
++    This program is free software; you can redistribute it and/or modify
++    it under the terms of the GNU General Public License as published by
++    the Free Software Foundation; either version 2 of the License, or
++    (at your option) any later version.
++
++    This program is distributed in the hope that it will be useful,
++    but WITHOUT ANY WARRANTY; without even the implied warranty of
++    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++    GNU General Public License for more details.
++
++    You should have received a copy of the GNU General Public License
++    along with this program; if not, write to the Free Software
++    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++*/
++
++#include <linux/slab.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/firmware.h>
++#include "dvb_frontend.h"
++#include "cx24120.h"
++#include "cx24120_const.h"
++
++//==========================
++#define dbginfo(args...) do { if(cx24120_debug) { printk(KERN_DEBUG "CX24120: %s: >>> ", __func__); \
++			printk(args); }  } while (0)
++#define info(args...) do { printk(KERN_INFO "CX24120: %s: -> ", __func__); \
++			printk(args); } while (0)
++#define err(args...) do {  printk(KERN_ERR "CX24120: %s: ### ERROR: ", __func__); \
++			printk(args); } while (0)
++//==========================
++
++static int cx24120_debug=0;
++static int reg_debug=0;
++MODULE_DESCRIPTION("DVB Frontend module for Conexant CX24120/CX24118 hardware");
++module_param(cx24120_debug, int, 0644);
++MODULE_PARM_DESC(cx24120_debug, "Activates frontend debugging (default:0)");
++
++// ##############################
++struct cx24120_state {
++	struct i2c_adapter *i2c;
++	const struct cx24120_config *config;
++	struct dvb_frontend frontend;
++	u8 need_set_mpeg_out;
++	u8 attached;
++	u8 dvb_s2_mode;
++	u8 cold_init;	
++}; 
++// #####################################
++// #### Command message to firmware ####
++struct cx24120_cmd {			// total size = 36
++	u8 id;						// [00] - message id
++	u8 arg[30];					// [04] - message first byte
++	u8 len;						// [34] - message lengh or first registers to read
++	u8 reg;						// [35] - number of registers to read
++};
++
++//===================================================================
++static int cx24120_readreg(struct cx24120_state *state, u8 reg) 
++{
++	int ret;
++	u8 buf = 0;
++	struct i2c_msg msg[] = {
++		{ 	.addr = state->config->i2c_addr,
++			.flags = 0,
++			.len = 1,
++			.buf = &reg	},
++			
++		{ 	.addr = state->config->i2c_addr,
++			.flags = I2C_M_RD,
++			.len = 1,
++			.buf = &buf	}
++	};
++	ret = i2c_transfer(state->i2c, msg, 2);
++	if (ret != 2) {
++		err("Read error: reg=0x%02x,  ret=0x%02x)\n", reg, ret);
++		return ret;
++	}
++	if (reg_debug) dbginfo("reg=0x%02x; data=0x%02x\n", reg, buf);
++	return buf;
++} // end cx24120_readreg
++//===================================================================
++static int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data) 
++{
++	u8 buf[] = { reg, data };
++	struct i2c_msg msg = {
++		.addr = state->config->i2c_addr, 
++		.flags = 0, 
++		.buf = buf, 
++		.len = 2 };
++	int ret;
++	ret = i2c_transfer(state->i2c, &msg, 1);
++	if (ret != 1) {
++		err("Write error: i2c_write error(err == %i, 0x%02x: 0x%02x)\n", ret, reg, data);
++		return ret;
++	}
++	if (reg_debug) dbginfo("reg=0x%02x; data=0x%02x\n", reg, data);
++	return 0;
++} // end cx24120_writereg
++//===================================================================
++static int cx24120_writeregN(struct cx24120_state *state, u8 reg, const u8 *values, u16 len, u8 incr)
++{
++	u8 buf[5]; /* maximum 4 data bytes at once - flexcop limitation (very limited i2c-interface this one) */
++	struct i2c_msg msg = {
++		.addr = state->config->i2c_addr, 
++		.flags = 0, 
++		.buf = buf, 
++		.len = len };
++	int ret;
++
++	do {
++		buf[0] = reg;
++		msg.len = len > 4 ? 4 : len;
++		memcpy(&buf[1], values, msg.len);
++		len  -= msg.len;					// data length revers counter
++		values += msg.len;					// incr data pointer
++		if (incr) reg += msg.len; 			
++		msg.len++; 							/* don't forget the addr byte */
++		ret = i2c_transfer(state->i2c, &msg, 1);
++		if (ret != 1) {
++			err("i2c_write error(err == %i, 0x%02x)\n", ret, reg);
++			return ret;
++		}
++		if (reg_debug) {
++			if( !(reg == 0xFA) && !(reg == 0x20) && !(reg == 0x21)) {		// Exclude firmware upload & diseqc messages
++				dbginfo("reg=0x%02x; data=0x%02x,0x%02x,0x%02x,0x%02x\n",	// from debug
++						reg, 	buf[1], buf[2], buf[3], buf[4]);
++			}
++		}
++	} while (len);
++	return 0;
++} // end cx24120_writeregN
++//===================================================================
++static struct dvb_frontend_ops cx24120_ops;
++//===================================================================
++struct dvb_frontend *cx24120_attach(const struct cx24120_config *config, struct i2c_adapter *i2c)
++{
++	struct cx24120_state *state = NULL;
++	int demod_rev;
++
++	info("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\n");
++	info("Driver version: 'SVT - 0.0.4a	03.04.2012'\n");
++	state = kzalloc(sizeof(struct cx24120_state),
++						GFP_KERNEL);
++	if (state == NULL) {
++		err("### Unable to allocate memory for cx24120_state structure. :(\n");
++		goto error;
++	}
++	/* setup the state */
++	state->config = config;
++	state->i2c = i2c;
++	/* check if the demod is present and has proper type */
++	demod_rev = cx24120_readreg(state, CX24120_REG_REVISION);
++	switch (demod_rev) {
++	case 0x07:
++		info("Demod CX24120 rev. 0x07 detected.\n");
++		break;
++	case 0x05:
++		info("Demod CX24120 rev. 0x05 detected.\n");
++		break;
++	default:
++		err("### Unsupported demod revision: 0x%x detected. Exit.\n", demod_rev);
++		goto error;
++	}
++	/* create dvb_frontend */
++	state->attached = 0x10;			// set attached flag
++	state->cold_init=0;
++	memcpy(&state->frontend.ops, &cx24120_ops, sizeof(struct dvb_frontend_ops));
++	state->frontend.demodulator_priv = state;
++	info("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner ATTACHED.\n");
++	return &state->frontend;
++
++error:
++	kfree(state);
++	return NULL;
++} 
++EXPORT_SYMBOL(cx24120_attach); // end cx24120_attach
++//===================================================================
++static int cx24120_test_rom(struct cx24120_state *state)
++{
++	int err, ret;
++	err = cx24120_readreg(state, 0xFD);
++	if (err & 4 )
++		{
++			ret = cx24120_readreg(state, 0xDF) & 0xFE;
++			err = cx24120_writereg(state, 0xDF, ret);
++		}
++	return err;
++} // end  cx24120_test_rom
++//===================================================================
++static int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	
++	*snr = (cx24120_readreg(state, CX24120_REG_QUALITY_H)<<8) |
++				 (cx24120_readreg(state, CX24120_REG_QUALITY_L));
++	dbginfo("read SNR index = %d\n", *snr);
++	
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_read_snr); // end cx24120_read_snr
++//===================================================================
++static int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++
++	*ber =  (cx24120_readreg(state, CX24120_REG_BER_HH) << 24)	|	// BER high byte of high word
++		(cx24120_readreg(state, CX24120_REG_BER_HL) << 16)		|	// BER low byte of high word
++		(cx24120_readreg(state, CX24120_REG_BER_LH)  << 8)		|	// BER high byte of low word
++		 cx24120_readreg(state, CX24120_REG_BER_LL);				// BER low byte of low word
++		dbginfo("read BER index = %d\n", *ber);
++
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_read_ber); // end cx24120_read_ber
++//===================================================================
++static int cx24120_message_send(struct cx24120_state *state, struct cx24120_cmd *cmd);
++//===================================================================
++static int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state, u8 flag)
++{
++	u8 tristate;
++	struct cx24120_cmd cmd;
++
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	
++	cmd.id = 0x13;						// (19) message Enable/Disable mpeg output ???
++	cmd.arg[0] = 1;
++	cmd.arg[1] = 0;
++	tristate = flag ? 0 : (u8)(-1);
++	cmd.arg[2] = tristate;
++	cmd.arg[3] = 1;						
++	cmd.len = 4;
++
++	if(flag) dbginfo("MPEG output DISABLED\n");
++	else dbginfo("MPEG output ENABLED\n");
++  
++	return cx24120_message_send(state, &cmd);
++}		// end	cx24120_msg_mpeg_output_global_config
++//===================================================================
++static int cx24120_message_send(struct cx24120_state *state, struct cx24120_cmd *cmd)
++{
++	u8 xxzz;
++	u32 msg_cmd_mask;
++	int ret, ficus;
++
++	if(state->dvb_s2_mode & 0x02) {		// is MPEG enabled?
++										// if yes:
++		xxzz = cmd->id - 0x11;			// look for specific message id
++		if ( xxzz <= 0x13 ) {
++			msg_cmd_mask = 1 << xxzz;
++			//0x0F8021 // if cmd_id 17 or 22 or 33-36, 42, 47, 57-61 etc. disable mpeg output
++			if ( msg_cmd_mask & 0x0F8021 ) {		// 000011111000000000100001b
++				cx24120_msg_mpeg_output_global_config(state, 0);
++				msleep(100);
++				state->dvb_s2_mode &=  0xFD;		// reset mpeg out enable flag
++			}
++		}
++	}
++	ret = cx24120_writereg(state, 0x00 /* reg id*/, cmd->id /* value */);			// message start & target
++	ret = cx24120_writeregN(state, 0x01 /* reg msg*/, &cmd->arg[0], cmd->len /* len*/, 1 /* incr */);		// message data
++	ret = cx24120_writereg(state, 0x1F /* reg msg_end */, 0x01 /* value */);		// message end
++
++	ficus = 1000;
++	while ( cx24120_readreg(state, 0x1F)) { 	// is command done???
++		msleep(1);
++		if( !(--ficus)) {
++			err("Too long waiting 'done' state from reg(0x1F). :(\n");
++			return -EREMOTEIO;
++		}
++	}
++	dbginfo("Successfully send message 0x%02x\n", cmd->id);
++
++	if ( cmd->reg > 30 ) {
++		err("Too much registers to read. cmd->reg = %d", cmd->reg);
++		return -EREMOTEIO;
++	}
++	ficus = 0;
++	if ( cmd->reg ) {					// cmd->reg - qty consecutive regs to read 
++		while ( ficus < cmd->reg ){		// starts from reg No cmd->len
++										// number of registers to read is cmd->reg
++										// and write results starts from cmd->arg[0].
++			cmd->arg[ficus] = cx24120_readreg(state, (cmd->len+ficus+1)); 		
++			++ficus;
++		}
++	}		
++	return 0;
++} // end cx24120_message_send
++//===================================================================
++static int cx24120_set_frontend(struct dvb_frontend *fe)
++{
++        struct dtv_frontend_properties *p = &fe->dtv_property_cache;
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	u32 srate, freq;
++	fe_code_rate_t fec;
++	fe_spectral_inversion_t inversion;
++	u8 smbr1, smbr2;
++	int ret;
++	
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	
++	cmd.id = CMD_TUNEREQUEST;		// 0x11 set tuner parametrs
++	cmd.len = 15;		
++	
++	freq = p->frequency;
++	srate = p->symbol_rate;
++	fec = p->fec_inner;
++	inversion = p->inversion;
++	
++	// check symbol rate
++	if ( srate  > 31000000 ) {      	// if symbol rate > 31 000
++		smbr1 = (-(srate < 31000001) & 3) + 2;		// ebp
++		smbr2 = (-(srate < 31000001) & 6) + 4;		// edi
++	} else {
++		smbr1 = 3;
++		smbr2 = 6;
++	}
++
++	ret = cx24120_writereg(state, 0xE6, smbr1);
++	ret = cx24120_readreg(state, 0xF0);
++	ret &= 0xFFFFFFF0;
++	ret |= smbr2;
++	ret = cx24120_writereg(state, 0xF0, ret);
++	
++	cmd.arg[0] = 0;		// CMD_TUNER_REQUEST
++	
++	// Frequency
++	cmd.arg[1] = (freq & 0xFF0000) >> 16;		/* intermediate frequency in kHz */
++	cmd.arg[2] = (freq & 0x00FF00) >> 8;
++	cmd.arg[3] = (freq & 0x0000FF);
++	
++	// Symbol Rate
++	cmd.arg[4] = ((srate/1000) & 0xFF00) >> 8;
++	cmd.arg[5] = ((srate/1000) & 0x00FF);
++	
++	// Inversion
++	if ( inversion ) {
++    	if ( inversion == 1 ) cmd.arg[6] = 4;
++		else cmd.arg[6] = 0x0C;
++	} else {
++		cmd.arg[6] = 0;
++	}
++
++	// FEC
++	switch ( fec )			// fec = p->u.qpsk.fec_inner
++	{
++		case 1:							// FEC_1_2
++			cmd.arg[7] = 0x2E; break;	// [11] = 0 by memset	
++		case 2:							// FEC_2_3
++			cmd.arg[7] = 0x2F; break;
++		case 3:							// FEC_3_4
++			cmd.arg[7] = 0x30; break;
++		case 5:							// FEC_5_6
++			cmd.arg[7] = 0x31; break;
++		case 7:							// FEC_7_8
++			cmd.arg[7] = 0x32; break;
++		default:								// FEC_NONE, FEC_4_5, FEC_6_7, FEC_8_9, 
++    											// FEC_AUTO, FEC_3_5, FEC_9_10
++			if ( state->dvb_s2_mode & 1 ) {	// if DVB-S2 mode	
++				cmd.arg[7] = 0;				
++				cmd.arg[11] = 0;
++			} else {
++				cmd.arg[7] = 0x2E;
++				cmd.arg[11] = 0xAC;
++			} 
++			break;
++	}
++	cmd.arg[8] = 0x13;
++	cmd.arg[9] = 0x88;
++	cmd.arg[10] = 0;
++	cmd.arg[12] = smbr2;
++	cmd.arg[13] = smbr1;
++	cmd.arg[14] = 0;
++
++	state->need_set_mpeg_out |= 0x01;		// after tune we need restart mpeg out ?????
++
++	return cx24120_message_send(state, &cmd);
++	
++} 
++EXPORT_SYMBOL(cx24120_set_frontend);		// end cx24120_set_frontend
++//===================================================================
++void cx24120_message_fill(struct cx24120_cmd *cmd,
++		u8 msg_id, 
++		u8 *msg_addr,
++		u8 msg_len,
++		u8 num_regs)
++{
++	cmd->id = msg_id;
++	memcpy(&cmd->arg[0], msg_addr, msg_len);
++	cmd->len = msg_len;
++	cmd->reg = num_regs;
++} // end cx24120_message_fill
++//===================================================================
++static int cx24120_read_signal_strength(struct dvb_frontend *fe, u16 *signal_strength)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	int result, sigstr_h, sigstr_l;
++
++	cx24120_message_fill(&cmd, 0x1A/*msg_id*/, &cx24120_msg_read_sigstr[0], 1/*msg_len*/, 0/*num_regs*/);
++
++	if( !(cx24120_message_send(state, &cmd)) ) {
++		sigstr_h = (cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6) << 8;
++		sigstr_l = cx24120_readreg(state, CX24120_REG_SIGSTR_L );
++		dbginfo("Signal strength from firmware= 0x%x\n", (sigstr_h | sigstr_l));
++		*signal_strength = ((sigstr_h | sigstr_l)  << 5) & 0x0000FFFF;
++		dbginfo("Signal strength= 0x%x\n", *signal_strength);
++		result = 0;
++	} else {
++		err("error reading signal strength\n");
++		result = -EREMOTEIO;
++	}
++	return result;
++}
++EXPORT_SYMBOL(cx24120_read_signal_strength);		// end cx24120_read_signal_strength
++//===================================================================
++static int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 num, 
++			struct cx24120_skystar2_mpeg_config *config_msg)
++{
++	struct cx24120_cmd cmd;
++	
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++  
++	cmd.id = CMD_MPEG_INIT;          // cmd->id=20 - message id
++	cmd.len = 7;            
++	cmd.arg[0] = num;     // sequental number - can be 0,1,2
++	cmd.arg[1] =  	((config_msg->x1 & 0x01) << 1) |
++					((config_msg->x1 >> 1) & 0x01);
++	cmd.arg[2] = 0x05;
++	cmd.arg[3] = 0x02;
++	cmd.arg[4] = ((config_msg->x2 >> 1) & 0x01);
++	cmd.arg[5] = (config_msg->x2 & 0xF0) | (config_msg->x3 & 0x0F);
++	cmd.arg[6] = state->attached; 	/* 0x10 if succesfully attached */
++  
++  return cx24120_message_send(state, &cmd);
++}	// end cx24120_msg_mpeg_output_config
++//===================================================================
++static int cx24120_diseqc_send_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t burst)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	
++	cmd.id = CMD_DISEQC_BURST;
++	cmd.arg[0] = 0x00;
++	if (burst)
++		cmd.arg[1] = 0x01;
++	dbginfo("burst sent.\n");
++
++  return cx24120_message_send(state, &cmd);
++}
++EXPORT_SYMBOL(cx24120_diseqc_send_burst);		// end cx24120_diseqc_send_burst
++//===================================================================
++static int cx24120_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++
++	dbginfo("cmd(0x23,4) - tone = %d\n", tone);
++	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
++		err("Invalid tone=%d\n", tone);
++		return -EINVAL;
++	}
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	cmd.id = CMD_SETTONE;	// 0x23
++	cmd.len = 4;
++	if (!tone)
++		cmd.arg[3] = 0x01;
++  return cx24120_message_send(state, &cmd);
++}
++EXPORT_SYMBOL(cx24120_set_tone);		// end cx24120_set_tone
++//===================================================================
++static int cx24120_set_voltage(struct dvb_frontend *fe,	fe_sec_voltage_t voltage)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	cmd.id = CMD_SETVOLTAGE;		//
++	cmd.len = 2;
++	if (!(voltage - 1))
++		cmd.arg[1] = 0x01;
++	return cx24120_message_send(state, &cmd);
++}
++EXPORT_SYMBOL(cx24120_set_voltage);		// end cx24120_set_voltage
++//===================================================================
++static int cx24120_send_diseqc_msg(struct dvb_frontend *fe,	struct dvb_diseqc_master_cmd *d)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	int back_count;
++	
++	dbginfo("Start sending diseqc sequence===============\n");
++	
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	
++	cmd.id = CMD_DISEQC_MSG1;		// 0x20
++	cmd.len = 11;
++	cmd.arg[0] = 0x00;
++	cmd.arg[1] = 0x00;
++	cmd.arg[2] = 0x03;
++	cmd.arg[3] = 0x16;
++	cmd.arg[4] = 0x28;
++	cmd.arg[5] = 0x01;
++	cmd.arg[6] = 0x01;
++	cmd.arg[7] = 0x14;
++	cmd.arg[8] = 0x19;
++	cmd.arg[9] = 0x14;
++	cmd.arg[10] = 0x1E;
++	if ( cx24120_message_send(state, &cmd) ) {
++		err("send 1st message(0x%x) filed==========\n", cmd.id);
++		return -EREMOTEIO;
++	}
++	cmd.id = CMD_DISEQC_MSG2;		// 0x21
++	cmd.len = d->msg_len + 6;
++	cmd.arg[0] = 0x00;
++	cmd.arg[1] = 0x01;
++	cmd.arg[2] = 0x02;
++	cmd.arg[3] = 0x00;
++	cmd.arg[4] = 0x00;
++	cmd.arg[5] = d->msg_len;
++	
++	memcpy(&cmd.arg[6], &d->msg, d->msg_len);
++	
++	if ( cx24120_message_send(state, &cmd) ) {
++		err("send 2d message(0x%x) filed========\n", cmd.id);
++		return -EREMOTEIO;
++	}
++	back_count = 100;
++	do {
++		if ( !(cx24120_readreg(state, 0x93) & 0x01) ) {	
++			dbginfo("diseqc sequence sent success==========.\n");
++			return 0;
++		}
++		msleep(5);
++		--back_count;
++	} while ( back_count );
++	err("Too long waiting for diseqc.=============\n");
++	return -ETIMEDOUT;
++}
++EXPORT_SYMBOL(cx24120_send_diseqc_msg);		// end cx24120_send_diseqc_msg
++//===================================================================
++static int cx24120_read_status(struct dvb_frontend *fe, fe_status_t *status)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	int ret, clock_seq_num, GettedFEC;
++	u8 mode_code, mode_8PSK_flag, attached_flag, clock_id;
++	
++	ret = cx24120_readreg(state, CX24120_REG_STATUS);		//0x3A
++	dbginfo("status = 0x%x\n", ret);
++	*status = 0;
++	if ( ret & CX24120_HAS_SIGNAL ) *status = FE_HAS_SIGNAL;
++	if ( ret & CX24120_HAS_CARRIER) *status |= FE_HAS_CARRIER;
++	if ( ret & CX24120_HAS_VITERBI) *status |= (FE_HAS_VITERBI + FE_HAS_SYNC);
++	
++	if ( ret & CX24120_HAS_LOCK ) {		// 0x08
++		*status |= FE_HAS_LOCK;
++		if ( state->need_set_mpeg_out & 1 ) {			// just tuned???
++			memset(&cmd, 0, sizeof(struct cx24120_cmd));
++			cmd.id = CMD_CLOCK_READ;
++			cmd.arg[0] = 0x00;
++			cmd.len = 1;			// cmd.reg != 0, so it is first register to read 
++			cmd.reg = 6;			// number of registers to read (0x01-0x06)
++			if ( !cx24120_message_send(state, &cmd) ) {			// in cmd[0]-[5] - result
++																//      0x02-0x07
++				ret = cx24120_readreg(state, CX24120_REG_FECMODE) & 0x3F;		// ntv - 0x8E(142) & 3F = 14
++				GettedFEC = ret;												// 		 0x0d= 13
++				dbginfo("Get FEC: %d\n", ret);
++				if ( state->dvb_s2_mode & 0x01 ) {							// is DVB-S2?
++					switch (ret-4) {
++						case 0:
++							mode_code = 0x01; goto mode_QPSK;	// FEC_1_2 - qpsk only
++						case 1:
++						case 8:
++							mode_code = 0x64; goto mode_8PSK;	// FEC_3_5 (10)- 8PSK only
++						case 2:
++						case 9:
++							mode_code = 0x02; goto mode_8PSK;	// FEC_2_3
++						case 3:
++						case 10:
++							mode_code = 0x03; goto mode_8PSK;	// FEC_3_4	// 14-4=10 - ntv+
++						case 4:
++							mode_code = 0x04; goto mode_QPSK;	// FEC_4_5 - qpsk only
++						case 5:
++						case 11:
++							mode_code = 0x05; goto mode_8PSK;	// FEC_5_6
++						case 6:
++						case 12:
++							mode_code = 0x08; goto mode_8PSK;	// FEC_8_9
++						case 7:
++						case 13:
++							mode_code = 0x65; goto mode_8PSK;	// FEC_9_10 (11)- 8PSK only
++						default:
++							info("Unknown DVB-S2 modefec (not QPSK or 8PSK): %d\n", ret-4);
++							mode_code = 0x01; 						// set like for mode 0
++					mode_8PSK:
++						if ( ret > 11 ) {		// 14
++							mode_8PSK_flag = 0x63;			// DVB-S2-8PSK flag
++							dbginfo("DVB-S2: 8PSK mode: %d, mode_code= 0x%x\n", ret-4, mode_code);
++						} else {
++					mode_QPSK:
++							mode_8PSK_flag = 0x00;
++   		     	      		dbginfo("DVB-S2: QPSK mode: %d\n", ret-4);
++						}
++						break;
++					} // end switch
++				} // end if dvb_s2_mode // dvb-s2
++				else {								// state->dvb_s2_mode & 1 = 0 -> #### DVB-S
++					switch ( ret - 2 ) {
++						case 0:
++							mode_code = 2; break;	// FEC_2_3
++						case 1:
++							mode_code = 3; break;	// FEC_3_4
++						case 2:
++							mode_code = 4; break;	// FEC_4_5
++						case 3:
++							mode_code = 5; break;	// FEC_5_6
++						case 4:
++							mode_code = 6; break;	// FEC_6_7
++						case 5:
++							mode_code = 7; break;	// FEC_7_8
++						default: 
++							mode_code = 1;break;	// FEC_1_2
++					}
++					mode_8PSK_flag = 0;
++				} // end of switch for dvb-s
++				
++				attached_flag = 0x10;
++				if (state->attached == 0x10)  // must be 0x10 if successfully attached in flexcop_fe_tuner
++					attached_flag = 0;
++				ret = 0;
++				if ( state->dvb_s2_mode & 0x01 )		// if dvb-s2
++					ret = (cx24120_readreg(state, CX24120_REG_FECMODE) >> 7) & 0x01;  // QPSK or 8PSK ???
++						 // bit 4          bit 5			bit 0                 bit 3
++				clock_id = (ret << 3) | attached_flag | (state->dvb_s2_mode & 1) | 4;		// possible id: 4, 5, 13. 12-impossible, 
++				// ntv S2 = 0x8E -> 8 | 1 | 4 = 13											// because 7th bit of ret - is S2 flag
++				// 1/2 S2 = 0x0d -> 0 | 1 | 4 = 5
++				dbginfo("Check clock table for: clock_id=0x%x, 8PSK_mask=0x%x, mode_code=0x%x\n", 
++				 	clock_id, mode_8PSK_flag, mode_code);
++				
++				clock_seq_num = 0;
++				while ( (clock_ratios_table[clock_seq_num].ratio_id != clock_id) ||
++						(clock_ratios_table[clock_seq_num].mode_xPSK != mode_8PSK_flag) ||
++						(clock_ratios_table[clock_seq_num].fec_mode != mode_code) )
++				{
++				/*	dbginfo("Check table string(%d): clock_id=%d, 8PSK_flag=%d, mode_code=%d\n",	clock_seq_num, 
++				 *		clock_ratios_table[clock_seq_num].ratio_id,
++				 *		clock_ratios_table[clock_seq_num].mode_xPSK,
++				 *		clock_ratios_table[clock_seq_num].fec_mode);
++				 */
++					++clock_seq_num;
++					if ( clock_seq_num == ARRAY_SIZE(clock_ratios_table) ) {
++						info("Check in clock table filed: unsupported modulation tuned - data reception in danger. :(\n");
++						goto settings_end;
++					}
++				}
++	//###############################
++				dbginfo("Check succesful: GetFEC: %d; post lock: m=%d, n=%d; clock_seq_idx: %d m=%d, n=%d, rate=%d\n",
++					GettedFEC,
++					cmd.arg[2] | (cmd.arg[1] << 8) | (cmd.arg[0] << 16), 		// registers was readed early
++					cmd.arg[5] | (cmd.arg[4] << 8) | (cmd.arg[3] << 16),		// in message with id = 0x16
++					clock_seq_num,
++					clock_ratios_table[clock_seq_num].m_rat,
++					clock_ratios_table[clock_seq_num].n_rat,
++					clock_ratios_table[clock_seq_num].rate);
++ 	//###############################
++				cmd.id = CMD_CLOCK_SET;
++				cmd.len = 10;
++				cmd.reg = 0;
++				cmd.arg[0] = 0;
++				cmd.arg[1] = state->attached;		// must be 0x10 if successfully attached in flexcop_fe_tuner
++				
++				cmd.arg[2] = (clock_ratios_table[clock_seq_num].m_rat >> 16) & 0xFF;
++				cmd.arg[3] = (clock_ratios_table[clock_seq_num].m_rat >>  8) & 0xFF;
++				cmd.arg[4] = (clock_ratios_table[clock_seq_num].m_rat >>  0) & 0xFF;
++
++				cmd.arg[5] = (clock_ratios_table[clock_seq_num].n_rat >> 16) & 0xFF;
++				cmd.arg[6] = (clock_ratios_table[clock_seq_num].n_rat >>  8) & 0xFF;
++				cmd.arg[7] = (clock_ratios_table[clock_seq_num].n_rat >>  0) & 0xFF;
++
++				cmd.arg[8] = (clock_ratios_table[clock_seq_num].rate >> 8) & 0xFF;
++				cmd.arg[9] = (clock_ratios_table[clock_seq_num].rate >> 0) & 0xFF;
++				
++				cx24120_message_send(state, &cmd);
++				
++			settings_end:
++				msleep(200);
++				cx24120_msg_mpeg_output_global_config(state, 1);	
++				state->dvb_s2_mode |= 0x02;							// set mpeg flag
++				state->need_set_mpeg_out &= 0xFE;					// clocks set done -> clear flag
++			}
++		}
++	}
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_read_status);		// end cx24120_read_status
++//===================================================================
++int cx24120_init(struct dvb_frontend *fe)
++{
++	const struct firmware *fw;
++	struct cx24120_state *state = fe->demodulator_priv;
++	struct cx24120_cmd cmd;
++	u8 ret, ret_EA, reg1, fL, fH;
++	u32 vco, xtal_khz;
++	u64 inv_vco, res, xxyyzz;
++	int reset_result;
++
++	if( state->cold_init ) return 0;
++
++	ret = cx24120_writereg(state, 0xEA, 0x00);
++	ret = cx24120_test_rom(state);
++	ret = cx24120_readreg(state, 0xFB) & 0xFE;
++	ret = cx24120_writereg(state, 0xFB, ret);
++	ret = cx24120_readreg(state, 0xFC) & 0xFE;
++	ret = cx24120_writereg(state, 0xFC, ret);
++	ret = cx24120_writereg(state, 0xC3, 0x04);
++	ret = cx24120_writereg(state, 0xC4, 0x04);
++	ret = cx24120_writereg(state, 0xCE, 0x00);
++	ret = cx24120_writereg(state, 0xCF, 0x00);
++	ret_EA = cx24120_readreg(state, 0xEA) & 0xFE;
++	ret = cx24120_writereg(state, 0xEA, ret_EA);
++	ret = cx24120_writereg(state, 0xEB, 0x0C);
++	ret = cx24120_writereg(state, 0xEC, 0x06);
++	ret = cx24120_writereg(state, 0xED, 0x05);
++	ret = cx24120_writereg(state, 0xEE, 0x03);
++	ret = cx24120_writereg(state, 0xEF, 0x05);
++	ret = cx24120_writereg(state, 0xF3, 0x03);
++	ret = cx24120_writereg(state, 0xF4, 0x44);
++	
++	reg1 = 0xF0;
++	do {
++		cx24120_writereg(state, reg1, 0x04);
++		cx24120_writereg(state, reg1 - 10, 0x02);
++		++reg1;
++	} while ( reg1 != 0xF3 );
++
++	ret = cx24120_writereg(state, 0xEA, (ret_EA | 0x01));
++		reg1 = 0xC5;
++	do {
++		ret = cx24120_writereg(state, reg1, 0x00);
++		ret = cx24120_writereg(state, reg1 + 1, 0x00);
++		reg1 += 2;
++    } while ( reg1 != 0xCB );
++    
++    ret = cx24120_writereg(state, 0xE4, 0x03);
++    ret = cx24120_writereg(state, 0xEB, 0x0A);
++    
++    dbginfo("Requesting firmware (%s) to download...\n", CX24120_FIRMWARE);
++    ret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);
++	if (ret) {
++		err("Could not load firmware (%s): %d\n", CX24120_FIRMWARE, ret);
++		return ret;
++	}
++	dbginfo("Firmware found and it size is %d bytes (%02x %02x .. %02x %02x)\n",
++        (int)fw->size,				// firmware_size in bytes u32*
++        fw->data[0],			// fw 1st byte
++        fw->data[1],			// fw 2d byte
++        fw->data[fw->size - 2],	// fw before last byte
++        fw->data[fw->size - 1]);	// fw last byte
++        
++    ret = cx24120_test_rom(state);
++	ret = cx24120_readreg(state, 0xFB) & 0xFE;
++	ret = cx24120_writereg(state, 0xFB, ret);
++	ret = cx24120_writereg(state, 0xE0, 0x76);
++	ret = cx24120_writereg(state, 0xF7, 0x81);
++	ret = cx24120_writereg(state, 0xF8, 0x00);
++	ret = cx24120_writereg(state, 0xF9, 0x00);
++	ret = cx24120_writeregN(state, 0xFA, fw->data, (fw->size - 1), 0x00);
++	ret = cx24120_writereg(state, 0xF7, 0xC0);
++	ret = cx24120_writereg(state, 0xE0, 0x00);
++	ret = (fw->size - 2) & 0x00FF;
++	ret = cx24120_writereg(state, 0xF8, ret);	// ret now is 0x7a
++	ret = ((fw->size - 2) >> 8) & 0x00FF;
++	ret = cx24120_writereg(state, 0xF9, ret);	// ret now is 0xaf
++	ret = cx24120_writereg(state, 0xF7, 0x00);
++	ret = cx24120_writereg(state, 0xDC, 0x00);
++	ret = cx24120_writereg(state, 0xDC, 0x07);
++	msleep(500);
++	
++	ret = cx24120_readreg(state, 0xE1);		// now is 0xd5 - last byte of the firmware
++    if ( ret == fw->data[fw->size - 1] ) {
++		dbginfo("Firmware uploaded successfully\n");
++		reset_result = 0;
++	} else {
++		err("Firmware upload failed. Last byte returned=0x%x\n", ret );
++		reset_result = -EREMOTEIO;
++	}
++	ret = cx24120_writereg(state, 0xDC, 0x00);		
++	release_firmware(fw);
++	if (reset_result) 
++		return reset_result;
++		
++	//================== Start tuner
++	cx24120_message_fill(&cmd, CMD_START_TUNER, &cx24120_msg_tuner_init[0], 3, 0);	// 0x1B
++	if(cx24120_message_send(state, &cmd)) {
++		err("Error tuner start! :(\n");
++		return -EREMOTEIO;
++	}
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	
++	cmd.id = CMD_VCO_SET;		// 0x10
++	cmd.len = 12;
++	
++	// ######################
++	// Calc VCO
++	xtal_khz = 10111;
++	xxyyzz = 0x400000000ULL;	// 17179869184
++	vco = xtal_khz * 10 * 4;	// 404440
++	inv_vco = xxyyzz / vco;		// 42478 = 0x00A5EE
++	res = xxyyzz % vco;			// 66864 = 0x010530	
++	
++	if( inv_vco > xtal_khz * 10 * 2) ++inv_vco;
++		
++	fH = (inv_vco >> 8) & 0xFF;
++	fL = (inv_vco) & 0xFF;
++    dbginfo("vco= %d, inv_vco= %lld, res= %lld, fL= 0x%x, fH= 0x%x\n", vco, inv_vco, res, fL, fH);
++    // ######################
++    
++	cmd.arg[0] = 0x06;
++	cmd.arg[1] = 0x2B;
++	cmd.arg[2] = 0xD8;
++	cmd.arg[3] = fH;		// 0xA5
++	cmd.arg[4] = fL;		// 0xEE
++	cmd.arg[5] = 0x03;
++	cmd.arg[6] = 0x9D;
++	cmd.arg[7] = 0xFC;
++	cmd.arg[8] = 0x06;
++	cmd.arg[9] = 0x03;
++	cmd.arg[10] = 0x27;
++	cmd.arg[11] = 0x7F;
++	
++	if(cx24120_message_send(state, &cmd)) {
++		err("Error set VCO! :(\n");
++		return -EREMOTEIO;
++	}
++	memset(&cmd, 0, sizeof(struct cx24120_cmd));
++	// set bandwidth
++	cmd.id = CMD_BANDWIDTH;		// 0x15
++	cmd.len = 12;
++	cmd.arg[0] = 0x00;
++	cmd.arg[1] = 0x00;
++	cmd.arg[2] = 0x00;
++	cmd.arg[3] = 0x00;
++	cmd.arg[4] = 0x05;
++	cmd.arg[5] = 0x02;
++	cmd.arg[6] = 0x02;
++	cmd.arg[7] = 0x00;
++	cmd.arg[8] = 0x05;
++	cmd.arg[9] = 0x02;
++	cmd.arg[10] = 0x02;
++	cmd.arg[11] = 0x00;
++	
++	if ( cx24120_message_send(state, &cmd) ) {
++		err("Error set bandwidth! :(\n");
++		return -EREMOTEIO;
++	}
++	ret = cx24120_readreg(state, 0xBA);
++	if ( ret > 3) {
++		dbginfo("Reset-readreg 0xBA: %x\n", ret);
++		err("Error intitilizing tuner! :(\n");
++		return -EREMOTEIO;
++	}
++	dbginfo("Tuner initialized correctly.\n");
++
++	ret = cx24120_writereg(state, 0xEB, 0x0A);
++	if (cx24120_msg_mpeg_output_global_config(state, 0) ||
++		cx24120_msg_mpeg_output_config(state, 0, &initial_mpeg_config) ||
++		cx24120_msg_mpeg_output_config(state, 1, &initial_mpeg_config) ||
++		cx24120_msg_mpeg_output_config(state, 2, &initial_mpeg_config) )
++	{
++		err("Error initilizing mpeg output. :(\n");
++        return -EREMOTEIO;
++	} else {
++		cmd.id = 0x3C;	// 60
++		cmd.len = 0x03;
++		cmd.arg[0] = 0x00;
++		cmd.arg[1] = 0x10;
++		cmd.arg[2] = 0x10;
++		if(cx24120_message_send(state, &cmd)) {
++			err("Error sending final init message. :(\n");
++			return -EREMOTEIO;
++		}	
++    }
++	state->cold_init=1;
++	return 0;
++} 
++EXPORT_SYMBOL(cx24120_init);		// end cx24120_reset
++//===================================================================
++static int cx24120_tune(struct dvb_frontend *fe, bool re_tune,
++        unsigned int mode_flags, unsigned int *delay, fe_status_t *p_status)
++{
++        struct dtv_frontend_properties *p = &fe->dtv_property_cache;
++	struct cx24120_state *state = fe->demodulator_priv;
++	int delay_cnt, sd_idx = 0;
++	fe_status_t status;
++	
++	if (re_tune) {
++		
++//		dbginfo("Compare symrate with table: symrate= %d, in table= %d\n", 
++//				p->u.qpsk.symbol_rate, symrates_pairs[sd_idx].symrate);
++
++		while ( p->symbol_rate > symrates_pairs[sd_idx].symrate ) {
++			++sd_idx;
++		}
++		dbginfo("Found symrate delay = %d\n", symrates_pairs[sd_idx].delay);
++		state->dvb_s2_mode &= 0xFE;			// clear bit -> try not DVB-S2
++		dbginfo("trying DVB-S =================\n");
++		cx24120_set_frontend(fe);
++		
++		delay_cnt = symrates_pairs[sd_idx].delay;
++		dbginfo("Wait for LOCK for DVB-S =================\n");
++		while (delay_cnt >= 0) {
++			cx24120_read_status(fe, &status);
++			if (status & FE_HAS_LOCK) {
++				dbginfo("DVB-S LOCKED================\n");
++				break;
++			}
++			msleep(100);
++			delay_cnt -=100;
++		}
++		dbginfo("Waiting finished - NO lock for DVB-S =================\n");
++		
++		cx24120_read_status(fe, &status);
++		if ( !(status & FE_HAS_LOCK) ) {		// if no lock on S
++			dbginfo("trying DVB-S2 ++++++++++++++++++++++++++\n");
++			state->dvb_s2_mode |= 0x01;			// may be it locked on S2 ?
++			p->fec_inner = FEC_AUTO;
++			cx24120_set_frontend(fe);
++			delay_cnt = symrates_pairs[sd_idx].delay;
++			dbginfo("Wait for LOCK for DVB-S2 ++++++++++++++++\n");
++			while (delay_cnt >= 0) {
++				cx24120_read_status(fe, &status);
++				if (status & FE_HAS_LOCK) {
++					dbginfo("DVB-S2 LOCKED++++++++++++++++\n");
++					break;
++				}
++				msleep(100);
++				delay_cnt -=100;
++			}
++			dbginfo("Waiting finished - NO lock for DVB-S2 ++++++++++++++++\n");
++		}
++	}
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_tune);	// end of cx24120_tune
++//===================================================================
++static int cx24120_get_algo(struct dvb_frontend *fe)
++{
++	return DVBFE_ALGO_HW;
++}
++EXPORT_SYMBOL(cx24120_get_algo);
++//===================================================================
++static int cx24120_sleep(struct dvb_frontend *fe)
++{
++  return 0;
++}
++EXPORT_SYMBOL(cx24120_sleep);
++//===================================================================
++/*static int cx24120_wakeup(struct dvb_frontend *fe)
++ * {
++ *   return 0;
++ * }
++ * EXPORT_SYMBOL(cx24120_wakeup);
++ */
++//===================================================================
++static int cx24120_get_frontend(struct dvb_frontend *fe)
++{
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_get_frontend);
++//===================================================================
++static void cx24120_release(struct dvb_frontend *fe)
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++	dbginfo("Clear state structure\n");
++	kfree(state);
++}
++EXPORT_SYMBOL(cx24120_release);
++//===================================================================
++static int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)	// UNCORRECTED_BLOCKS
++{
++	struct cx24120_state *state = fe->demodulator_priv;
++
++	*ucblocks = (cx24120_readreg(state, CX24120_REG_UCB_H) << 8) |
++		cx24120_readreg(state, CX24120_REG_UCB_L);
++	dbginfo("Blocks = %d\n", *ucblocks);
++	return 0;
++}
++EXPORT_SYMBOL(cx24120_read_ucblocks);
++// ########################################################################################
++static struct dvb_frontend_ops cx24120_ops = {
++
++	.delsys = { SYS_DVBS2 },
++	.info = {
++		.name = "Conexant CX24120/CX24118",
++		.frequency_min = 950000,
++		.frequency_max = 2150000,
++		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
++		.frequency_tolerance = 5000,
++		.symbol_rate_min = 1000000,
++		.symbol_rate_max = 45000000,
++		.caps = 						// 0x500006ff
++			FE_CAN_INVERSION_AUTO |		//0x00 000 001
++			FE_CAN_FEC_1_2 | 			//0x00 000 002
++			FE_CAN_FEC_2_3 | 			//0x00 000 004
++			FE_CAN_FEC_3_4 |			//0x00 000 008
++			FE_CAN_FEC_4_5 | 			//0x00 000 010
++			FE_CAN_FEC_5_6 | 			//0x00 000 020
++			FE_CAN_FEC_6_7 |			//0x00 000 040
++			FE_CAN_FEC_7_8 | 			//0x00 000 080
++			FE_CAN_FEC_AUTO |			//0x00 000 200
++			FE_CAN_QPSK | 				//0x00 000 400
++//???		FE_HAS_EXTENDED_CAPS |		//0x00 800 000   	/* We need more bitspace for newer APIs, indicate this. */
++			FE_CAN_2G_MODULATION |		//0x10 000 000   	/* frontend supports "2nd generation modulation" (DVB-S2) */
++			FE_CAN_RECOVER				//0x40 000 000		/* frontend can recover from a cable unplug automatically */
++	},									//sum=50 000 6FF
++	.release = 					cx24120_release,
++	
++	.init = 					cx24120_init, 
++	.sleep = 					cx24120_sleep,
++	
++	.tune = 					cx24120_tune,
++	.get_frontend_algo = 		cx24120_get_algo,
++	.set_frontend = 			cx24120_set_frontend,
++
++	.get_frontend = 			cx24120_get_frontend,
++	.read_status = 				cx24120_read_status,
++	.read_ber = 				cx24120_read_ber,
++	.read_signal_strength = 	cx24120_read_signal_strength,
++	.read_snr = 				cx24120_read_snr,
++	.read_ucblocks = 			cx24120_read_ucblocks,
++	
++	.diseqc_send_master_cmd = 	cx24120_send_diseqc_msg,
++	
++	.diseqc_send_burst = 		cx24120_diseqc_send_burst,
++	.set_tone = 				cx24120_set_tone,
++	.set_voltage = 				cx24120_set_voltage,
++};
++//===================================================================
++MODULE_PARM_DESC(cx24120_debug, "prints some verbose debugging information (default:0)");
++MODULE_AUTHOR("Sergey Tyurin");
++MODULE_LICENSE("GPL");
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/dvb-frontends/cx24120_const.h linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120_const.h
+--- linux-3.4-r1/drivers/media/dvb-frontends/cx24120_const.h	1970-01-01 03:00:00.000000000 +0300
++++ linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120_const.h	2012-04-03 16:37:20.684139905 +0400
+@@ -0,0 +1,259 @@ 
++/*
++ * Conexant CX24120/CX24118 - DVB-S/S2 demod/tuner driver
++ * DVBS/S2 Satellite demod/tuner driver static definitins
++ *
++ * Copyright (C) 2009 Sergey Tyurin <forum.free-x.de>
++ * Updated 2012 by Jannis Achstetter <jannis_achstetter@web.de>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#define CX24120_FIRMWARE "dvb-fe-cx24120-1.20.58.2.fw"
++
++// ##############################
++// ### cx24120 i2c registers ###
++#define CX24120_REG_CMD_START (0x00)	// write cmd_id, and then start write args to next register:
++#define CX24120_REG_CMD_ARGS (0x01)		// write command arguments, max 4 at once, then next 4, etc.
++#define CX24120_REG_CMD_END (0x1F)		// write 0x01 for end, and read it for command result
++
++#define CX24120_REG_FECMODE (0x39)		// FEC status
++#define CX24120_REG_STATUS (0x3A)		// Tuner status - signal, carrier, sync, lock ...
++#define CX24120_REG_QUALITY_H (0x40)	// SNR high byte
++#define CX24120_REG_QUALITY_L (0x41)	// SNR low byte
++
++#define CX24120_REG_BER_HH (0x47)		// BER high byte of high word
++#define CX24120_REG_BER_HL (0x48)		// BER low byte of high word
++#define CX24120_REG_BER_LH (0x49)		// BER high byte of low word
++#define CX24120_REG_BER_LL (0x4A)		// BER low byte of low word
++
++#define CX24120_REG_SIGSTR_H (0x3A)		// Signal strength high byte & ??? status register ???
++#define CX24120_REG_SIGSTR_L (0x3B)		// Signal strength low byte
++
++#define CX24120_REG_UCB_H (0x50)		// UCB high byte
++#define CX24120_REG_UCB_L (0x51)		// UCB low byte
++
++#define CX24120_REG_REVISION (0xFF)		// Chip revision (ro). Must be 0x7 or 0x5
++
++// ##############################
++/* Command messages */
++enum command_message_id {
++	CMD_VCO_SET			= 0x10,		// cmdlen = 12;
++	CMD_TUNEREQUEST		= 0x11,		// cmd.len = 15;
++	
++	CMD_MPEG_ONOFF		= 0x13,		// cmd.len = 4;
++	CMD_MPEG_INIT		= 0x14,		// cmd.len = 7;
++	CMD_BANDWIDTH		= 0x15,		// cmd.len = 12;
++	CMD_CLOCK_READ		= 0x16,		// read clock from registers 0x01-0x06
++	CMD_CLOCK_SET		= 0x17,		// cmd.len = 10;
++	
++	CMD_DISEQC_MSG1		= 0x20,		// cmd.len = 11;
++	CMD_DISEQC_MSG2		= 0x21,		// cmd.len = d->msg_len + 6;
++	CMD_SETVOLTAGE		= 0x22,		// cmd.len = 2;
++	CMD_SETTONE			= 0x23,		// cmd.len = 4;
++	CMD_DISEQC_BURST	= 0x24,		// cmd.len not used !!!
++	
++	CMD_READ_SNR		= 0x1A,		// Read signal strength
++	CMD_START_TUNER		= 0x1B,		// ???
++	
++	CMD_TUNER_INIT		= 0x3C,		// cmd.len = 0x03;
++};
++// ##############################
++/* signal status */
++#define CX24120_HAS_SIGNAL  (0x01)
++#define CX24120_HAS_CARRIER (0x02)
++#define CX24120_HAS_VITERBI	(0x04)
++#define CX24120_HAS_LOCK 	(0x08)
++#define CX24120_HAS_UNK1 	(0x10)
++#define CX24120_HAS_UNK2 	(0x20)
++#define CX24120_STATUS_MASK (0x0f)
++#define CX24120_SIGNAL_MASK (0xc0)
++
++static u8 cx24120_msg_tuner_init[] = { 0,0,0,0,0,0 };
++static u8 cx24120_msg_read_sigstr[] = {0,0};
++
++static struct cx24120_skystar2_mpeg_config {
++	u8 x1;
++	u8 x2;
++	u8 x3;
++} initial_mpeg_config = {	
++	0xA1, 	// 10100001
++	0x76, 	// 01110110
++	0x07,	// 00000111
++};
++
++static struct cx24120_symrate_delay {
++	u32 symrate;
++	u32 delay;
++} symrates_pairs[] = {
++	{    3000000, 15000 },
++	{    6000000, 10000 },
++	{    8000000,  5000 },
++	{   10000000,  2000 },
++	{0x0FFFFFFFF,   400 },
++};
++
++static struct cx24120_clock_ratios_table {
++	u32 ratio_id;
++	u32 mode_xPSK;
++	u32 fec_mode;
++	u32	m_rat;
++	u32 n_rat;
++	u32 rate;
++} clock_ratios_table[] = {
++{	21	,	0	,	1	,	770068	,	763515	,	258	},
++{	21	,	0	,	100	,	97409	,	80370	,	310	},
++{	21	,	0	,	2	,	137293	,	101802	,	345	},
++{	21	,	0	,	3	,	4633447	,	3054060	,	388	},
++{	21	,	0	,	4	,	2472041	,	1527030	,	414	},
++{	21	,	0	,	5	,	85904	,	50901	,	432	},
++{	21	,	0	,	8	,	2751229	,	1527030	,	461	},
++{	21	,	0	,	101	,	1392872	,	763515	,	467	},
++{	21	,	99	,	100	,	1850771	,	1019430	,	464	},
++{	21	,	99	,	2	,	137293	,	67962	,	517	},
++{	21	,	99	,	3	,	4633447	,	2038860	,	581	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	21	,	99	,	5	,	85904	,	33981	,	647	},
++{	21	,	99	,	8	,	2751229	,	1019430	,	690	},
++{	21	,	99	,	101	,	1392872	,	509715	,	699	},
++{	29	,	0	,	1	,	770068	,	782127	,	252	},
++{	29	,	0	,	100	,	1850771	,	1564254	,	302	},
++{	29	,	0	,	2	,	686465	,	521418	,	337	},
++{	29	,	0	,	3	,	4633447	,	3128508	,	379	},
++{	29	,	0	,	4	,	2472041	,	1564254	,	404	},
++{	29	,	0	,	5	,	429520	,	260709	,	421	},
++{	29	,	0	,	8	,	2751229	,	1564254	,	450	},
++{	29	,	0	,	101	,	1392872	,	782127	,	455	},
++{	29	,	99	,	100	,	1850771	,	1043118	,	454	},
++{	29	,	99	,	2	,	686465	,	347706	,	505	},
++{	29	,	99	,	3	,	4633447	,	2086236	,	568	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	29	,	99	,	5	,	429520	,	173853	,	632	},
++{	29	,	99	,	8	,	2751229	,	1043118	,	675	},
++{	29	,	99	,	101	,	1392872	,	521559	,	683	},
++{	17	,	0	,	1	,	766052	,	763515	,	256	},
++{	17	,	0	,	100	,	96901	,	80370	,	308	},
++{	17	,	0	,	2	,	136577	,	101802	,	343	},
++{	17	,	0	,	3	,	4609283	,	3054060	,	386	},
++{	17	,	0	,	4	,	2459149	,	1527030	,	412	},
++{	17	,	0	,	5	,	85456	,	50901	,	429	},
++{	17	,	0	,	8	,	2736881	,	1527030	,	458	},
++{	17	,	0	,	101	,	1385608	,	763515	,	464	},
++{	17	,	99	,	100	,	1841119	,	1019430	,	462	},
++{	17	,	99	,	2	,	136577	,	67962	,	514	},
++{	17	,	99	,	3	,	4609283	,	2038860	,	578	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	17	,	99	,	5	,	85456	,	33981	,	643	},
++{	17	,	99	,	8	,	2736881	,	1019430	,	687	},
++{	17	,	99	,	101	,	1385608	,	509715	,	695	},
++{	25	,	0	,	1	,	766052	,	782127	,	250	},
++{	25	,	0	,	100	,	1841119	,	1564254	,	301	},
++{	25	,	0	,	2	,	682885	,	521418	,	335	},
++{	25	,	0	,	3	,	4609283	,	3128508	,	377	},
++{	25	,	0	,	4	,	2459149	,	1564254	,	402	},
++{	25	,	0	,	5	,	427280	,	260709	,	419	},
++{	25	,	0	,	8	,	2736881	,	1564254	,	447	},
++{	25	,	0	,	101	,	1385608	,	782127	,	453	},
++{	25	,	99	,	100	,	1841119	,	1043118	,	451	},
++{	25	,	99	,	2	,	682885	,	347706	,	502	},
++{	25	,	99	,	3	,	4609283	,	2086236	,	565	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	25	,	99	,	5	,	427280	,	173853	,	629	},
++{	25	,	99	,	8	,	2736881	,	1043118	,	671	},
++{	25	,	99	,	101	,	1385608	,	521559	,	680	},
++{	5	,	0	,	1	,	273088	,	254505	,	274	},
++{	5	,	0	,	100	,	17272	,	13395	,	330	},
++{	5	,	0	,	2	,	24344	,	16967	,	367	},
++{	5	,	0	,	3	,	410788	,	254505	,	413	},
++{	5	,	0	,	4	,	438328	,	254505	,	440	},
++{	5	,	0	,	5	,	30464	,	16967	,	459	},
++{	5	,	0	,	8	,	487832	,	254505	,	490	},
++{	5	,	0	,	101	,	493952	,	254505	,	496	},
++{	5	,	99	,	100	,	328168	,	169905	,	494	},
++{	5	,	99	,	2	,	24344	,	11327	,	550	},	// work for 0x0d - 11278V - DVB-S2 - 8PSK MPEG-4/HD
++{	5	,	99	,	3	,	410788	,	169905	,	618	},	// 0x0e S2 8psk        // was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	5	,	99	,	5	,	30464	,	11327	,	688	},
++{	5	,	99	,	8	,	487832	,	169905	,	735	},
++{	5	,	99	,	101	,	493952	,	169905	,	744	},
++{	13	,	0	,	1	,	273088	,	260709	,	268	},
++{	13	,	0	,	100	,	328168	,	260709	,	322	},
++{	13	,	0	,	2	,	121720	,	86903	,	358	},
++{	13	,	0	,	3	,	410788	,	260709	,	403	},
++{	13	,	0	,	4	,	438328	,	260709	,	430	},
++{	13	,	0	,	5	,	152320	,	86903	,	448	},
++{	13	,	0	,	8	,	487832	,	260709	,	479	},
++{	13	,	0	,	101	,	493952	,	260709	,	485	},
++{	13	,	99	,	100	,	328168	,	173853	,	483	},
++{	13	,	99	,	2	,	121720	,	57951	,	537	}, // work for 0x8d - dvb-s2 8psk
++{	13	,	99	,	3	,	410788	,	173853	,	604	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	13	,	99	,	5	,	152320	,	57951	,	672	},
++{	13	,	99	,	8	,	487832	,	173853	,	718	},
++{	13	,	99	,	101	,	493952	,	173853	,	727	},
++{	1	,	0	,	1	,	815248	,	763515	,	273	},
++{	1	,	0	,	100	,	51562	,	40185	,	328	},
++{	1	,	0	,	2	,	72674	,	50901	,	365	},
++{	1	,	0	,	3	,	1226323	,	763515	,	411	},
++{	1	,	0	,	4	,	1308538	,	763515	,	438	},
++{	1	,	0	,	5	,	90944	,	50901	,	457	},
++{	1	,	0	,	8	,	1456322	,	763515	,	488	},
++{	1	,	0	,	101	,	1474592	,	763515	,	494	},
++{	1	,	99	,	100	,	979678	,	509715	,	492	},
++{	1	,	99	,	2	,	72674	,	33981	,	547	},
++{	1	,	99	,	3	,	1226323	,	509715	,	615	},	// was 4 - ERRORR!? FEC_4_5 not in DVB-S2
++{	1	,	99	,	5	,	90944	,	33981	,	685	},
++{	1	,	99	,	8	,	1456322	,	509715	,	731	},
++{	1	,	99	,	101	,	1474592	,	509715	,	740	},
++{	9	,	0	,	1	,	815248	,	782127	,	266	},
++{	9	,	0	,	100	,	979678	,	782127	,	320	},
++{	9	,	0	,	2	,	363370	,	260709	,	356	},
++{	9	,	0	,	3	,	1226323	,	782127	,	401	},
++{	9	,	0	,	4	,	1308538	,	782127	,	428	},
++{	9	,	0	,	5	,	454720	,	260709	,	446	},
++{	9	,	0	,	8	,	1456322	,	782127	,	476	},
++{	9	,	0	,	101	,	1474592	,	782127	,	482	},
++{	9	,	99	,	100	,	979678	,	521559	,	480	},
++{	9	,	99	,	2	,	363370	,	173853	,	535	},
++{	9	,	99	,	3	,	1226323	,	521559	,	601	},	// was 4 - ERRORR! FEC_4_5 not in DVB-S2
++{	9	,	99	,	5	,	454720	,	173853	,	669	},
++{	9	,	99	,	8	,	1456322	,	521559	,	714	},
++{	9	,	99	,	101	,	1474592	,	521559	,	723	},
++{	18	,	0	,	1	,	535	,	588	,	233	},
++{	18	,	0	,	2	,	1070	,	882	,	311	},
++{	18	,	0	,	6	,	3210	,	2058	,	399	},
++{	16	,	0	,	1	,	763	,	816	,	239	},
++{	16	,	0	,	2	,	1526	,	1224	,	319	},
++{	16	,	0	,	3	,	2289	,	1632	,	359	},
++{	16	,	0	,	5	,	3815	,	2448	,	399	},
++{	16	,	0	,	7	,	5341	,	3264	,	419	},
++{	22	,	0	,	1	,	535	,	588	,	233	},
++{	22	,	0	,	2	,	1070	,	882	,	311	},
++{	22	,	0	,	6	,	3210	,	2058	,	399	},
++{	20	,	0	,	1	,	143429	,	152592	,	241	},
++{	20	,	0	,	2	,	286858	,	228888	,	321	},
++{	20	,	0	,	3	,	430287	,	305184	,	361	},
++{	20	,	0	,	5	,	717145	,	457776	,	401	},
++{	20	,	0	,	7	,	1004003	,	610368	,	421	},
++{	2	,	0	,	1	,	584	,	588	,	254	},
++{	2	,	0	,	2	,	1169	,	882	,	339	},
++{	2	,	0	,	6	,	3507	,	2058	,	436	},
++{	0	,	0	,	1	,	812	,	816	,	255	},
++{	0	,	0	,	2	,	1624	,	1224	,	340	},
++{	0	,	0	,	3	,	2436	,	1632	,	382	},
++{	0	,	0	,	5	,	4060	,	2448	,	425	},
++{	0	,	0	,	7	,	5684	,	3264	,	446	},
++{	6	,	0	,	1	,	584	,	588	,	254	},
++{	6	,	0	,	2	,	1168	,	882	,	339	},
++{	6	,	0	,	6	,	3504	,	2058	,	436	},
++{	4	,	0	,	1	,	152592	,	152592	,	256	},
++{	4	,	0	,	2	,	305184	,	228888	,	341	},
++{	4	,	0	,	3	,	457776	,	305184	,	384	},
++{	4	,	0	,	5	,	762960	,	457776	,	427	},
++{	4	,	0	,	7	,	1068144	,	610368	,	448	},
++};
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/dvb-frontends/cx24120.h linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120.h
+--- linux-3.4-r1/drivers/media/dvb-frontends/cx24120.h	1970-01-01 03:00:00.000000000 +0300
++++ linux-3.4-r1-S2/drivers/media/dvb-frontends/cx24120.h	2012-04-03 10:27:59.000000000 +0400
+@@ -0,0 +1,59 @@ 
++/*
++ * Conexant CX24120/CX24118 - DVB-S/S2 demod/tuner driver
++ *
++ * Copyright (C) 2008 Patrick Boettcher <pb@linuxtv.org>
++ * Copyright (C) 2009 Sergey Tyurin <forum.free-x.de>
++ * Updated 2012 by Jannis Achstetter <jannis_achstetter@web.de>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef CX24120_H
++#define CX24120_H
++
++#include <linux/dvb/frontend.h>
++
++struct firmware;
++struct dvb_frontend;
++struct i2c_adapter;
++
++struct cx24120_config
++{
++	u8 i2c_addr;
++	int (*request_firmware)(struct dvb_frontend *fe, const struct firmware **fw, char *name);
++	void (*stream_control)(struct dvb_frontend *fe, u8 onoff);
++};
++
++#if defined(CONFIG_DVB_CX24120) || \
++	(defined(CONFIG_DVB_CX24120_MODULE) && defined(MODULE))
++extern struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
++		struct i2c_adapter *i2c);
++extern int cx24120_reset(struct dvb_frontend *fe);
++#else
++static inline
++struct dvb_frontend *cx24120_attach(const struct cx24120_config *config,
++		struct i2c_adapter *i2c)
++{
++	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
++	return NULL;
++}
++static inline int cx24120_reset(struct dvb_frontend *fe)
++{
++	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
++	return -ENODEV;
++}
++#endif
++
++#endif
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/dvb-frontends/Kconfig linux-3.4-r1-S2/drivers/media/dvb-frontends/Kconfig
+--- linux-3.4-r1/drivers/media/dvb-frontends/Kconfig	2012-04-03 15:23:44.976143444 +0400
++++ linux-3.4-r1-S2/drivers/media/dvb-frontends/Kconfig	2012-04-03 15:26:40.760141513 +0400
+@@ -4,6 +4,13 @@
+ comment "Multistandard (satellite) frontends"
+ 	depends on DVB_CORE
+ 
++config DVB_CX24120
++	tristate "Conexant CX24120 based"
++	depends on DVB_CORE && I2C
++	default m if DVB_FE_CUSTOMISE
++	help
++	  A DVB-S/DVB-S2 tuner module. Say Y when you want to support this frontend.
++
+ config DVB_STB0899
+ 	tristate "STB0899 based"
+ 	depends on DVB_CORE && I2C
+diff -NurEbBw --strip-trailing-cr linux-3.4-r1/drivers/media/dvb-frontends/Makefile linux-3.4-r1-S2/drivers/media/dvb-frontends/Makefile
+--- linux-3.4-r1/drivers/media/dvb-frontends/Makefile	2012-04-03 15:23:44.976143444 +0400
++++ linux-3.4-r1-S2/drivers/media/dvb-frontends/Makefile	2012-04-03 15:26:40.760141513 +0400
+@@ -19,6 +19,10 @@
+ obj-$(CONFIG_DVB_CX22700) += cx22700.o
+ obj-$(CONFIG_DVB_S5H1432) += s5h1432.o
+ obj-$(CONFIG_DVB_CX24110) += cx24110.o
++
++# inserted by Custler
++obj-$(CONFIG_DVB_CX24120) += cx24120.o
++
+ obj-$(CONFIG_DVB_TDA8083) += tda8083.o
+ obj-$(CONFIG_DVB_L64781) += l64781.o
+ obj-$(CONFIG_DVB_DIB3000MB) += dib3000mb.o
diff --git a/projects/Odroid_U2/patches/linux/ddfddf8/linux-999.03-mac80211-ignore-ECSA-in-probe-response-frames.patch b/projects/Odroid_U2/patches/linux/ddfddf8/linux-999.03-mac80211-ignore-ECSA-in-probe-response-frames.patch
new file mode 100644
index 0000000..e8674f9
--- /dev/null
+++ b/projects/Odroid_U2/patches/linux/ddfddf8/linux-999.03-mac80211-ignore-ECSA-in-probe-response-frames.patch
@@ -0,0 +1,46 @@
+From 9098cb577d0f4b2dd71f37988515686008b7c733 Mon Sep 17 00:00:00 2001
+From: Stefan Saraev <stefan@saraev.ca>
+Date: Tue, 24 Sep 2013 13:42:50 +0300
+Subject: [PATCH] mac80211: ignore (E)CSA in probe response frames
+
+BP: https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/net/mac80211/mlme.c?id=d70b7616d9080ec9f868fbd31db5fd4341435d61
+
+thanks @bedouin67
+---
+ net/mac80211/mlme.c | 11 +++--------
+ 1 file changed, 3 insertions(+), 8 deletions(-)
+
+diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
+index 5b4328d..1c5a8e6 100644
+--- a/net/mac80211/mlme.c
++++ b/net/mac80211/mlme.c
+@@ -2408,19 +2408,11 @@
+ 	if (bss)
+ 		ieee80211_rx_bss_put(local, bss);
+ 
+-	if (!sdata->u.mgd.associated)
+-		return;
+-
+ 	if (need_ps) {
+ 		mutex_lock(&local->iflist_mtx);
+ 		ieee80211_recalc_ps(local, -1);
+ 		mutex_unlock(&local->iflist_mtx);
+ 	}
+-
+-	if (elems->ch_switch_ie &&
+-	    memcmp(mgmt->bssid, sdata->u.mgd.associated->bssid, ETH_ALEN) == 0)
+-		ieee80211_sta_process_chanswitch(sdata, elems->ch_switch_ie,
+-						 bss, rx_status->mactime);
+ }
+ 
+ 
+@@ -2685,6 +2677,9 @@
+ 	ieee80211_rx_bss_info(sdata, mgmt, len, rx_status, &elems,
+ 			      true);
+ 
++	ieee80211_sta_process_chanswitch(sdata, rx_status->mactime,
++			&elems, true);
++
+ 	if (ieee80211_sta_wmm_params(local, sdata, elems.wmm_param,
+ 				     elems.wmm_param_len))
+ 		changed |= BSS_CHANGED_QOS;
diff --git a/projects/Odroid_U2/patches/u-boot/0000_u-boot_add-bootini-fat.patch b/projects/Odroid_U2/patches/u-boot/0000_u-boot_add-bootini-fat.patch
new file mode 100644
index 0000000..d9c37dc
--- /dev/null
+++ b/projects/Odroid_U2/patches/u-boot/0000_u-boot_add-bootini-fat.patch
@@ -0,0 +1,83 @@
+---
+ cmd/fat.c |   73 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 73 insertions(+)
+
+--- a/cmd/fat.c
++++ b/cmd/fat.c
+@@ -150,3 +150,76 @@ U_BOOT_CMD(
+ 	"      to 'dev' on 'interface'"
+ );
+ #endif
++
++#define BOOTINI_MAGIC  "ODROID4412-UBOOT-CONFIG"
++
++int do_fat_bootini(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
++{
++	unsigned long   filesize = 0;
++	unsigned char   *fp = (unsigned char *)0x5FFF0000, cmd[512], skip = 0, first = 1;
++	unsigned int    wpos = 0;
++
++	// file check & update
++	setenv("msgload", "Loading boot.ini from ");
++	setenv("filesize", "0");
++	run_command("if fatload mmc 0:1 5FFF0000 boot.ini;" \
++		"   then echo $msgload FAT;" \
++		"   fi", 0);
++
++	if((filesize = getenv_ulong("filesize", 16, 0))) {
++		if(filesize > 64 * 1024) {
++			printf("File Size Error! Max file size 64Kbytes. filesize = %d\n", filesize);
++			return  0;
++		}
++
++		while(1) {
++			if(*fp == '#')  skip = 1;
++			else {
++				skip = 0;   wpos = 0;
++				memset(cmd, 0x00, sizeof(cmd));
++			}
++
++			while(*fp != 0x0A) {
++				if((*fp != 0x0D) && (!skip))	cmd[wpos++] = *fp;
++
++				fp++;
++				if(filesize)	filesize--;
++				else		break;
++			}
++
++			if(wpos) {
++				if(wpos < sizeof(cmd)) {
++					if(first) {
++						if(!strncmp(cmd, BOOTINI_MAGIC, sizeof(BOOTINI_MAGIC))) {
++							printf("Find boot.ini file from FAT area!!\n");	first = 0;
++						}
++						else {
++							printf("Find boot.ini file. But this file is not an %s config file!\n", BOOTINI_MAGIC);
++							return  0;
++						}
++					}
++				else {
++					printf("boot.ini command = %s\n", cmd);
++					run_command(cmd, 0);
++				}
++			}
++			wpos = 0;
++		}
++		fp++;
++		if(filesize)	filesize--;
++		else		break;
++		}
++		return  1;
++	}
++	return  0;
++}
++
++U_BOOT_CMD(
++	bootini, 1, 0, do_fat_bootini,
++	"bootini - boot.ini textfile load from FAT32\n",
++	"<interface(only support mmc 0:1/0:2)>\n"
++	"	- boot.ini file load from FAT32 on 'interface'\n"
++	"Will attempt boot from: \n"
++	"	fat mmc 0:1 /boot.ini\n"
++        "on the above sequence\n"
++);
diff --git a/projects/Odroid_U2/patches/u-boot/0001_u-boot_add-bootini-autoboot.patch b/projects/Odroid_U2/patches/u-boot/0001_u-boot_add-bootini-autoboot.patch
new file mode 100644
index 0000000..56cf0a9
--- /dev/null
+++ b/projects/Odroid_U2/patches/u-boot/0001_u-boot_add-bootini-autoboot.patch
@@ -0,0 +1,23 @@
+---
+ include/configs/odroid.h |    3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/include/configs/odroid.h
++++ b/include/configs/odroid.h
+@@ -126,6 +126,7 @@
+ 	"kernel_args=" \
+ 		"setenv bootargs root=/dev/mmcblk${mmcrootdev}p${mmcrootpart}" \
+ 		" rootwait ${console} ${opts}\0" \
++	"boot_ini=bootini\0" \
+ 	"boot_script=" \
+ 		"run loadbootscript;" \
+ 		"source ${scriptaddr}\0" \
+@@ -154,6 +155,8 @@
+ 	"autoboot=" \
+ 		"if test -e mmc 0 boot.scr; then; " \
+ 			"run boot_script; " \
++		"elif test -e mmc 0 boot.ini; then; " \
++			"run boot_ini;" \
+ 		"elif test -e mmc 0 Image.itb; then; " \
+ 			"run boot_fit;" \
+ 		"elif test -e mmc 0 zImage; then; " \
diff --git a/projects/Odroid_U2/patches/xorg-server/xorg-server-0005-mali-swapbuffers-fix.patch b/projects/Odroid_U2/patches/xorg-server/xorg-server-0005-mali-swapbuffers-fix.patch
new file mode 100644
index 0000000..0c81b0c
--- /dev/null
+++ b/projects/Odroid_U2/patches/xorg-server/xorg-server-0005-mali-swapbuffers-fix.patch
@@ -0,0 +1,244 @@
+---
+ hw/xfree86/dri2/dri2.c    |   28 ++++++++++++++
+ hw/xfree86/dri2/dri2.h    |    2 +
+ hw/xfree86/dri2/dri2ext.c |   86 +++++++++++++++++++++++++++++++++++++++-------
+ 3 files changed, 103 insertions(+), 13 deletions(-)
+
+--- a/hw/xfree86/dri2/dri2.c
++++ b/hw/xfree86/dri2/dri2.c
+@@ -99,6 +99,7 @@ typedef struct _DRI2Drawable {
+     int swap_limit;             /* for N-buffering */
+     unsigned blocked[3];
+     Bool needInvalidate;
++    Bool client_created;
+     int prime_id;
+     PixmapPtr prime_slave_pixmap;
+     PixmapPtr redirectpixmap;
+@@ -113,6 +114,7 @@ typedef struct _DRI2Screen {
+     int fd;
+     unsigned int lastSequence;
+     int prime_id;
++    Bool need_async_swapbuffers_reply;
+ 
+     DRI2CreateBufferProcPtr CreateBuffer;
+     DRI2DestroyBufferProcPtr DestroyBuffer;
+@@ -243,6 +245,7 @@ DRI2AllocateDrawable(DrawablePtr pDraw)
+     if (pPriv == NULL)
+         return NULL;
+ 
++    pPriv->client_created = FALSE;
+     pPriv->dri2_screen = ds;
+     pPriv->drawable = pDraw;
+     pPriv->width = pDraw->width;
+@@ -363,6 +366,15 @@ DRI2CreateDrawable2(ClientPtr client, Dr
+     int rc;
+ 
+     pPriv = DRI2GetDrawable(pDraw);
++    if (pPriv && dri2_id_out == NULL && pPriv->client_created) {
++        /* We already allocated a DRI2Drawable for this drawable, the client
++         * has called into this function (so will receive invalidate events)
++         * and now we're being called by the client again (we know this because
++         * the caller doesn't care about the dri2_id). This means we don't need
++         * to allocate another one, we have nothing else to do. */
++        pPriv->prime_id = dri2_client->prime_id;
++        return Success;
++    }
+     if (pPriv == NULL)
+         pPriv = DRI2AllocateDrawable(pDraw);
+     if (pPriv == NULL)
+@@ -377,6 +389,11 @@ DRI2CreateDrawable2(ClientPtr client, Dr
+ 
+     if (dri2_id_out)
+         *dri2_id_out = dri2_id;
++    else {
++        /* The client has called in for the first time, it will now receive
++         * invalidate events. Record this for later. */
++        pPriv->client_created = TRUE;
++    }
+ 
+     return Success;
+ }
+@@ -1088,7 +1105,11 @@ DRI2WaitSwap(ClientPtr client, DrawableP
+     return FALSE;
+ }
+ 
+-
++Bool
++DRI2NeedAsyncSwapBuffersReply(DrawablePtr pDraw)
++{
++    return DRI2GetScreen(pDraw->pScreen)->need_async_swapbuffers_reply;
++}
+ 
+ int
+ DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
+@@ -1605,6 +1626,11 @@ DRI2ScreenInit(ScreenPtr pScreen, DRI2In
+ 
+         if (info->driverName) {
+             ds->driverNames[0] = info->driverName;
++            /* Mali incorrectly assumes that a return from SwapBuffers means that
++             * buffers have been swapped, it doesn't wait for the relevant event.
++             * In this case, we work around this annoyance by delaying the
++             * SwapBuffers reply until the swap has actually completed. */
++            ds->need_async_swapbuffers_reply = strcmp(info->driverName, "armsoc") == 0;
+         } else {
+             ds->driverNames[0] = ds->driverNames[1] = dri2_probe_driver_name(pScreen, info);
+             if (!ds->driverNames[0])
+--- a/hw/xfree86/dri2/dri2ext.c
++++ b/hw/xfree86/dri2/dri2ext.c
+@@ -53,6 +53,14 @@
+ 
+ static int DRI2EventBase;
+ 
++/* Data shared by ProcDRI2SwapBuffers and the asynchronous callback
++ * DRI2SwapEvent */
++struct SwapBuffersData {
++	CARD64 swap_target;
++	int refcnt;
++	DrawablePtr pDrawable;
++	CARD16 sequence;
++};
+ 
+ static Bool
+ validDrawable(ClientPtr client, XID drawable, Mask access_mode,
+@@ -366,6 +374,24 @@ load_swap_reply(xDRI2SwapBuffersReply *
+     rep->swap_lo = sbc & 0xffffffff;
+ }
+ 
++static void swap_buffers_data_unref(struct SwapBuffersData *data)
++{
++	if (--data->refcnt == 0)
++		free(data);
++}
++
++static void send_swap_buffers_reply(ClientPtr client, struct SwapBuffersData *data)
++{
++    xDRI2SwapBuffersReply rep = {
++        .type = X_Reply,
++        .length = 0,
++        .sequenceNumber = data->sequence,
++    };
++
++    load_swap_reply(&rep, data->swap_target);
++    WriteToClient(client, sizeof(xDRI2SwapBuffersReply), &rep);
++}
++
+ static CARD64
+ vals_to_card64(CARD32 lo, CARD32 hi)
+ {
+@@ -376,11 +402,11 @@ static void
+ DRI2SwapEvent(ClientPtr client, void *data, int type, CARD64 ust, CARD64 msc,
+               CARD32 sbc)
+ {
+-    DrawablePtr pDrawable = data;
++    struct SwapBuffersData *sbdata = data;
+     xDRI2BufferSwapComplete2 event = {
+         .type = DRI2EventBase + DRI2_BufferSwapComplete,
+         .event_type = type,
+-        .drawable = pDrawable->id,
++        .drawable = sbdata->pDrawable->id,
+         .ust_hi = (CARD64) ust >> 32,
+         .ust_lo = ust & 0xffffffff,
+         .msc_hi = (CARD64) msc >> 32,
+@@ -388,6 +414,12 @@ DRI2SwapEvent(ClientPtr client, void *da
+         .sbc = sbc
+     };
+ 
++    if (DRI2NeedAsyncSwapBuffersReply(sbdata->pDrawable)) {
++        send_swap_buffers_reply(client, sbdata);
++        AttendClient(client);
++    }
++
++    swap_buffers_data_unref(data);
+     WriteEventsToClient(client, 1, (xEvent *) &event);
+ }
+ 
+@@ -395,14 +427,11 @@ static int
+ ProcDRI2SwapBuffers(ClientPtr client)
+ {
+     REQUEST(xDRI2SwapBuffersReq);
+-    xDRI2SwapBuffersReply rep = {
+-        .type = X_Reply,
+-        .sequenceNumber = client->sequence,
+-        .length = 0
+-    };
+     DrawablePtr pDrawable;
+-    CARD64 target_msc, divisor, remainder, swap_target;
++    CARD64 target_msc, divisor, remainder;
++    struct SwapBuffersData *data;
+     int status;
++    Bool need_async_swap_reply;
+ 
+     REQUEST_SIZE_MATCH(xDRI2SwapBuffersReq);
+ 
+@@ -410,6 +439,8 @@ ProcDRI2SwapBuffers(ClientPtr client)
+                        DixReadAccess | DixWriteAccess, &pDrawable, &status))
+         return status;
+ 
++    need_async_swap_reply = DRI2NeedAsyncSwapBuffersReply(pDrawable);
++
+     /*
+      * Ensures an out of control client can't exhaust our swap queue, and
+      * also orders swaps.
+@@ -417,18 +448,49 @@ ProcDRI2SwapBuffers(ClientPtr client)
+     if (DRI2ThrottleClient(client, pDrawable))
+         return Success;
+ 
++    data = malloc(sizeof(struct SwapBuffersData));
++    /* DRI2SwapEvent() above might feel like the obvious place to free the
++     * data struct we just allocated. But consider the following sequence of
++     * events (and understand that swap_target is stored in data):
++     * 1. DRI2SwapBuffers accesses swap_target
++     * 2. DRI2SwapBuffers calls into ScheduleSwap
++     * 3. ScheduleSwap blits and calls DRI2SwapEvent before returning
++     * 4. Back in DRI2SwapBuffers, we access swap_target again
++     *
++     * If we had freed data in step 3, we would have a use-after-free in
++     * step 4.
++     *
++     * So, we set up a refcount of 2. One ref is owned by this function, and
++     * one ref is owned by DRI2SwapEvent. We only free the data once both
++     * functions are done. */
++    data->refcnt = 2;
++    data->pDrawable = pDrawable;
++    data->sequence = client->sequence;
++
+     target_msc = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
+     divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
+     remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);
+ 
++    /* If we're sending the reply later, we need to avoid processing any
++     * more requests from this client until that point. */
++    if (need_async_swap_reply)
++        IgnoreClient(client);
++
+     status = DRI2SwapBuffers(client, pDrawable, target_msc, divisor, remainder,
+-                             &swap_target, DRI2SwapEvent, pDrawable);
+-    if (status != Success)
++                             &data->swap_target, DRI2SwapEvent, data);
++
++    if (status != Success) {
++        swap_buffers_data_unref(data);
++        swap_buffers_data_unref(data);
++        if (need_async_swap_reply)
++            AttendClient(client);
+         return BadDrawable;
++    }
+ 
+-    load_swap_reply(&rep, swap_target);
++    if (!need_async_swap_reply)
++        send_swap_buffers_reply(client, data);
+ 
+-    WriteToClient(client, sizeof(xDRI2SwapBuffersReply), &rep);
++    swap_buffers_data_unref(data);
+ 
+     return Success;
+ }
+--- a/hw/xfree86/dri2/dri2.h
++++ b/hw/xfree86/dri2/dri2.h
+@@ -359,4 +359,6 @@ extern _X_EXPORT int DRI2GetParam(Client
+                                   CARD64 *value);
+ 
+ extern _X_EXPORT DrawablePtr DRI2UpdatePrime(DrawablePtr pDraw, DRI2BufferPtr pDest);
++
++extern Bool DRI2NeedAsyncSwapBuffersReply(DrawablePtr pDraw);
+ #endif
